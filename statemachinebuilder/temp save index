<!DOCTYPE html>
<html lang="en" style="overflow: hidden;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottie State Machine Flowchart Creator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@400;500;600;700&display=swap">
    <script type="module" src="https://cdn.skypack.dev/@dotlottie/player-component@2.4.1"></script>

    <style>
    body {
  font-family: 'Hanken Grotesk', sans-serif;
  margin: auto;

  background-color: #f0f2f5;
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100vh;
  width: 100%;
  overflow: hidden;
  color: #333;
}
      /* --- NEW: Loader Overlay Styles --- */
      #loader-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(240, 242, 245, 0.95); /* Match body background but slightly transparent */
          backdrop-filter: blur(4px);
          -webkit-backdrop-filter: blur(4px);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
          flex-direction: column;
          gap: 16px;
          transition: opacity 0.5s ease-out;
      }
      .loader {
          border: 5px solid #f3f3f3; /* Light grey */
          border-top: 5px solid #4a90e2; /* Blue */
          border-radius: 50%;
          width: 50px;
          height: 50px;
          animation: spin 1s linear infinite;
      }
      #loader-overlay p {
          font-size: 18px;
          font-weight: 500;
          color: #555;
      }
      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }
      /* --- END NEW --- */

      /* --- NEW: Left Panel Marker List Styles --- */
      #left-panel-header {
          padding: 14px 20px; /* Adjusted padding */
          border-bottom: 1px solid #e0e0e0;
          flex-shrink: 0;
           /* --- NEW: Flexbox for alignment --- */
          display: flex;
          justify-content: space-between;
          align-items: center;
          
      }
      #marker-list {
          flex-grow: 1;
          overflow-y: auto;
          padding: 16px;
          display: flex;
          flex-direction: column;
          gap: 12px;
      }
      .marker-card {
          background-color: #f8f9fa;
          border: 1px solid #e9ecef;
          border-radius: 12px;
          padding: 12px 16px;
          padding: 0;
          cursor: grab;
          display: flex;
          align-items: center;
          gap: 0px;
          flex-direction: column;
          transition: background-color 0.2s, box-shadow 0.2s, transform 0.2s;
          user-select: none;
          overflow: hidden; /* To contain the rounded corners of the preview */
      }
      .marker-card:hover {
          background-color: #ffffff;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
          transform: translateY(-2px);
      }
      .marker-preview {
          height: 80px; /* Fixed height for the preview area */
          width: 100%;
          background-color: #e9ecef; /* Placeholder background */
          border-bottom: 1px solid #dee2e6;
      }
      .marker-info {
          display: flex;
          align-items: center;
          justify-content: space-between; /* Push content to edges */
          padding: 12px 16px;
          width: 100%;
          box-sizing: border-box;
      }
      .marker-info-left {
          display: flex;
          flex-direction: column; /* Stack name and frame range */
          gap: 2px;
      }
      .marker-card .marker-name {
          font-weight: 600;
          color: #343a40;
      }
      .marker-card .marker-frames {
          font-size: 11px;
          color: #868e96;
          font-weight: 500;
      }
      .marker-card .marker-interactions {
          font-size: 11px;
          font-weight: 600;
          color: #4a90e2; /* Blue text */
          background-color: #e7f3ff; /* Light blue background */
          padding: 4px 10px;
          border-radius: 999px; /* Pill shape */
          transition: background-color 0.2s, color 0.2s;
      }
      .marker-card .marker-interactions:hover {
          background-color: #4a90e2; /* Solid blue on hover */
          color: #ffffff; /* White text on hover */
      }
      .marker-card .marker-interactions.hidden {
          display: none;
      }
      /* --- NEW: Add Segment Button in Left Panel --- */
      .add-segment-card {
          border: 2px dashed #d1d5db; /* Gray-300 */
          border-radius: 12px;
          padding: 16px 20px; /* Reduced vertical padding */
          text-align: center;
          font-weight: 600;
          color: #6b7280; /* Gray-500 */
          cursor: pointer;
          transition: all 0.2s ease-in-out;
          background-color: #f9fafb; /* Gray-50 */
          margin-bottom: 10px;
      }
      .add-segment-card:hover {
          border-color: #4a90e2; /* Blue */
          color: #4a90e2;
          background-color: #e7f3ff; /* Light blue */
      }
      /* --- END NEW --- */

      /* --- NEW: Main Layout & Collapsible Left Panel --- */
      #main-wrapper {
          display: flex;
          width: 100%;
          height: 100%;
          /* --- MODIFIED: Adjust padding based on panel state --- */
          transition: padding-left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          padding-left: 555px; /* Default width of the expanded left panel */
      }

      #left-panel {
          position: fixed;
          top: 0;
          left: 0;
          height: 100vh; /* Use viewport height */
          width: 280px;
          background-color: #ffffff;
          border-right: 1px solid #e0e0e0;
          z-index: 200;
          display: flex;
          flex-direction: column;
          overflow: visible; /* Prevent content from spilling out during transitions */
          /* --- MODIFIED: Transition transform for sliding --- */
          transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 4px 0 15px -5px rgba(0,0,0,0.05);
      }

      /* --- NEW: Toggle Button for Left Panel --- */
      #left-panel-toggle {
          position: relative; /* Changed from absolute */
          width: 32px;
          height: 32px;
          background-color: #f0f2f5;
          border: 1px solid #e0e0e0;
          border-radius: 10px;
          display: flex;
          justify-content: center;
          align-items: center;
          cursor: pointer;
          color: #888;
          transition: all 0.2s ease-in-out;
          flex-shrink: 0; /* Prevent button from shrinking */
      }
      #left-panel-toggle i {
          transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      /* --- END NEW --- */



      #main-wrapper.left-panel-collapsed {
          padding-left: 40px; /* Increased from 20px */
      }

      #main-wrapper.left-panel-collapsed #left-panel {
          transform: translateX(calc(-100% + 24px)); /* Increased from 20px */
      }
      /* --- NEW: Rotate icon when panel is collapsed --- */
      #main-wrapper.left-panel-collapsed #left-panel-toggle i {
          transform: rotate(180deg);
      }
      /* --- NEW: Shift toggle button to the edge when collapsed --- */
      #main-wrapper.left-panel-collapsed #left-panel-toggle {
          transform: translateX(calc(100% + 4px)); /* 100% of its own width + 4px for spacing */
      }
      /* --- END NEW --- */
      /* --- END NEW --- */

      /* --- NEW: Styles for the scrollable content area within the left panel --- */
      #left-panel-scroll-area {
          flex-grow: 1; /* Allows it to take up remaining vertical space */
          overflow-y: auto; /* Enables vertical scrolling */
          /* --- REMOVED: Padding-top is no longer needed as the button is in the header --- */
      }
      /* --- END NEW --- */

      .error{
        display: none !important;
      }
      #add-segments-button,
      #connect-nodes-button { 
        display: none !important;
      }

      /* --- NEW: Hide the individual animation dropdown in the side panel --- */
      #animation-dropdown-group {
          display: none !important;
      }

      /* --- NEW: Style for the global animation dropdown --- */
      #global-animation-controls {
          position: absolute;
          top: 20px;
          left: 20px;
          z-index: 101; /* Above controls */
          width: 280px;
          background-color: #ffffff;
          border-radius: 16px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
          padding: 0; /* The dropdown-group inside will have padding */
          display: none;
      }

      /* --- MODIFIED: Style changes for global animation dropdown --- */
      #global-animation-controls .dropdown-group {
          background-color: #ffffff; /* Make background white */
          border: none; /* Remove border */
          align-items: center; /* Vertically align icon and text */
          gap: 12px; /* Adjust gap */
          padding-left: 12px; 
          padding-right: 4px;/* Add padding for the icon */
          padding-top: 16px;
          padding-bottom: 16px;
          margin-top: 0;
      }

      #global-animation-controls .dropdown-group label {
          display: none; /* Hide the "GLOBAL ANIMATION" label */
      }

      /* Remove the column layout for the label/dropdown container */
      #global-animation-controls .dropdown-group > div:first-of-type {
         gap: 0; /* Remove gap between hidden label and dropdown */
      }

      /* --- NEW: State Machine Play Button --- */
      #play-state-machine-button {
          position: relative; /* MODIFIED: No longer absolutely positioned on its own */
          /* MODIFIED: top, left, and z-index are now controlled by the #controls container */
          width: 50px;
          height: 50px;
          /* MODIFIED: Use a green gradient for the background */
          background-image: linear-gradient(135deg, #4CAF50, #2E7D32);
          border: none;
          border-radius: 50%;
          /* MODIFIED: Add a more pronounced shadow for a 3D effect */
          box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 2px 2px rgba(255,255,255,0.3);
          display: flex;
          justify-content: center;
          align-items: center;
          cursor: pointer;
          transition: all 0.2s ease-in-out;
          color: #ffffff !important; /* MODIFIED: Make the icon white and override other styles */
      }
      #play-state-machine-button:hover {
          transform: scale(1.1);
          /* MODIFIED: Enhance shadows and highlights on hover */
          box-shadow: 0 6px 12px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.4);
          background-image: linear-gradient(135deg, #5cb85c, #388e3c); /* Slightly brighter gradient on hover */
      }
      #play-state-machine-button i {
          font-size: 20px;
          /* REMOVED: No longer need to nudge the icon, flexbox handles centering */
      }
      /* --- END NEW --- */

      /* --- NEW: Modern Vertical Floating Bar for Controls --- */
      #controls {
          position: absolute;
          top: 50%;
          left: 24px; /* MODIFIED: Adjusted for alignment */
          transform: translateY(-50%);
          display: flex;
          flex-direction: column;
          gap: 20px; /* MODIFIED: Add gap to space out the play button */
          z-index: 100;
          align-items: center; /* Center items horizontally */
          /* --- REMOVED: Background is now on individual control groups --- */
      }
      /* --- NEW: Wrapper for the main control buttons --- */
      #main-controls-wrapper {
          display: flex;
          flex-direction: column;
          gap: 8px;
          background-color: #ffffff;
          padding: 10px;
          border-radius: 999px; /* Pill shape */
          box-shadow: 0 8px 24px rgba(0,0,0,0.12);
          transition: box-shadow 0.2s ease-in-out;
      }

      #controls button {
          width: 44px; /* Slightly smaller for a tighter bar */
          height: 44px;
          padding: 0;
          font-size: 18px; /* Slightly smaller icons */
          cursor: pointer;
          background-color: transparent; /* Buttons are transparent */
          color: #555; /* Dark grey icon color */
          border: none;
          border-radius: 50%; /* Keep them circular within the bar */
          display: flex;
          justify-content: center;
          align-items: center;
          transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
          box-shadow: none; /* Remove individual button shadows */
      }

      #controls button:hover {
          background-color: #f0f2f5; /* Light grey background on hover */
          color: #333; /* Slightly darker icon on hover */
      }

      #controls button:active {
          background-color: #e4e6e9; /* Slightly darker for active state */
      }
      /* --- END NEW --- */


        #add-action-node-button:disabled {
          color: rgb(148, 148, 148);
          position: relative; /* Needed for pseudo-element positioning */
          
      }

       #add-action-node-button:disabled:hover{
          opacity: 1;
          color: rgb(148, 148, 148);
          visibility: visible;
      }

      #add-action-node-button:disabled::after {
          content: 'Create a Global Node to use an Action node';
          position: absolute;
          left: 120%; /* Position to the right of the button */
          top: 50%;
          transform: translateY(-50%);
          background-color: #333;
          color: white;
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 13px;
          font-weight: 500;
          white-space: nowrap;
          z-index: 110; /* Ensure it's above other elements */
          opacity: 0;
          visibility: hidden;
          transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
      }

      #add-action-node-button:disabled:hover::after {
          opacity: 1;
          
          visibility: visible;
      }


         #flowchart-area {
            width: 100%;
            height: 100%;
            /* --- MODIFIED: app-container is now the flex item --- */
            flex-grow: 1;
            background-color: #f5f5f5; /* Lighter background to distinguish from canvas-container */
            
            /* --- NEW: Add dotted background --- */
            background-image: radial-gradient(#d1d5db 1px, transparent 1px);
            background-size: 16px 16px;
            /* --- END NEW --- */

            position: relative; /* Keep for internal absolute positioning */
            overflow: hidden; /* Clip canvas content to this viewport */
            border-radius: 12px;

            cursor: default; /* Default cursor for the grey area */
        }


        #canvas-container {
            position: absolute;
            left: 0;
            top: 0;
            /* width and height will be dynamically set by JavaScript */
            background-color: transparent; /* Actual canvas background */
            cursor: grab; /* Specific cursor for the pannable white canvas */
        }

        .node {
            width: 180px; /* Corresponds to NODE_WIDTH in JS */
            min-height: 100px; /* Corresponds to NODE_HEIGHT in JS */
            background-color: #ffffff; /* Cleaner white background */
            border: 1px solid #e0e0e0; /* Softer border */
            border-radius: 20px; /* More rounded corners */
            position: absolute; /* Position relative to canvas-container */
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 16px; /* Slightly adjusted padding */
            box-sizing: border-box;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* Softer, more modern shadow */
            font-size: 14px;
            text-align: left;
            transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out; /* Smooth transitions */
            user-select: none;
            z-index: 20;
        }

        /* NEW: Invisible hover area around the node */
        .node::before {
            content: '';
            position: absolute;
            /* Use CSS variable for dynamic hover area. calc() is used to make it negative. */
            top: calc(-1 * var(--node-hover-padding, 8%)); /* Fallback to 8% */
            left: calc(-1 * var(--node-hover-padding, 8%));
            right: calc(-1 * var(--node-hover-padding, 8%));
            bottom: calc(-1 * var(--node-hover-padding, 8%));
            /* Make the area invisible */
            background-color: transparent;
            /* Ensure the hover area has rounded corners to match the node */
            border-radius: 24px; /* Slightly more than the node's 16px */
            z-index: -1; /* Position it behind the node's content */
        }

        /* --- NEW: Animation for node entrance --- */
        @keyframes node-enter-animation {
            from {
                transform: scale(0.6);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        .node.entering {
            animation: node-enter-animation 0.35s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }
        /* --- END NEW --- */

        /* NEW: Global State Node */
        .global-state-node {
            width: 120px;
            height: 120px;
            background-color: #fffbe6; /* Light yellow */
            border: 2px solid #ffd600; /* Amber solid border */
            border-radius: 50%; /* Circular */
            position: absolute;
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center; /* This will center the text horizontally */
            justify-content: center;
            padding: 15px;
            box-sizing: border-box;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            text-align: center;
            user-select: none;
            z-index: 25; /* Higher than regular nodes */
        }
        .global-state-node:hover {
            box-shadow: 4px 4px 12px rgba(0,0,0,0.25);
            border-color: #ffc107;
        }
        .global-state-node.selected-for-connection {
            border-color: #ff9800; /* Amber, to match the other selection */
            box-shadow: 0 0 0 4px #ff9800; /* Amber glow */
        }
        /* --- NEW: Entrance animation for the global state node --- */
        .global-state-node.entering {
            animation: node-enter-animation 0.35s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }
        .global-state-node.active {
            border-color: #D2691E; /* Brownish-orange border */
            box-shadow: 0 0 0 4px #F4A460, 3px 3px 8px rgba(0,0,0,0.2); /* Lighter brownish-orange glow */
        }

        /* NEW: Port for the Global State Node */
        .global-state-node .node-port {
            opacity: 0.8; /* Make it visible by default */
            transform: scale(1);
            transition: opacity 0.2s, transform 0.2s;
            background-color: #ff9800; /* Orange to match guard connections */
        }

        /* NEW: Action Node Styles */
       .action-node {
            background-color: #e8eaf6; /* Indigo light */
            border-color: #9fa8da; /* Indigo lighter */
            width: 160px; /* MODIFIED: Was 100px */
            height: 110px; /* MODIFIED: Was 100px */
            padding: 10px;
            justify-content: center;
            align-items: center;
            text-align: center;
            transform: translateY(0px);
        }
        .action-node .edit-node-icon,
        .action-node .node-title,
        .action-node .node-details {
            display: none; /* Hide text and edit icon */
        }
        .action-node.no-action::before {
            content: ''; /* The circle is now only a fallback */
            display: none;
            width: 40px;
            height: 40px;
            border: 4px solid #5c6bc0; /* Indigo */
            border-radius: 50%;
            background-color: #c5cae9;
        }

        /* NEW: Styles for text inside the action node */
        .action-node-display {
            font-size: 14px;
            font-weight: bold;
            color: #3f51b5; /* Indigo */
        }
        .action-node-display .action-target {
            display: block;
            font-size: 12px;
            font-weight: normal;
            color: #5c6bc0;
        }

        .node:hover {
            border-color: #c0c0c0; /* Slightly darker border on hover */
            box-shadow: 0 6px 16px rgba(0,0,0,0.12); /* Lift up on hover */
        }

        .node.active {
            border-color: #2196f3; /* Blue border for active node */
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.3), 0 4px 12px rgba(0,0,0,0.1); /* Softer blue glow */
        }

        .node.selected-for-connection {
            border-color: #ff9800;
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.4); /* Softer orange glow */
        }

        .node-title {
            font-weight: bold;
            margin-bottom: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            width: 100%;
            color: #1a237e;
        }
        .node-details {
            font-size: 12px;
            color: #555;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Increased gap for better spacing between items */
            width: 100%;
            margin-top: 8px; /* Increased margin for more space from the title */
            pointer-events: none;
        }
        .node-details i {
            font-size: 12px;
            color: #666;
        }

        .node-detail-chip {
            display: inline-flex;
            align-items: center;
            font-size: 12px; /* Match parent font-size */
            font-weight: 500; /* Made the text a bit bolder */
            color: #555; /* Match parent color */
            white-space: nowrap;
            gap: 8px;
        }

        .chip-animation,
        .chip-loop,
        .chip-speed { background-color: transparent; }

        .edit-node-icon {
            display: none; /* Removed as requested */
        }
        .edit-node-icon:hover {
            background-color: #455a64;
        }

        /* Updated node port styles */
        .node-port {
            position: absolute;
            width: 16px; /* Original size */
            height: 16px; /* Original size */
            border-radius: 50%; /* Circle shape */
            border: 4px solid white; /* Original border */
            background-color: #28a745; /* Green for all ports */
            z-index: 15;
            cursor: crosshair;
            opacity: 0; /* Hidden by default */
            transform: scale(0); /* Scaled down by default */
            /* Faster appearance, delayed disappearance */
            transition: opacity 0.15s ease-in, transform 0.15s ease-in;
            transition-delay: 0.2s; /* Delay for disappearing */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Show and animate ports on node hover */
       body:not(.body-is-pill-dragging) .node-wrapper:hover .node-port {
            opacity: 1;
            transform: scale(1); /* Original scale up */
            transition-delay: 0s; /* No delay on appearance */
        }

        /* --- NEW: Translate animation for ports on node hover --- */
        body:not(.body-is-pill-dragging) .node-wrapper:hover .node-port.right-port {
            transform: scale(1.1) translateX(6px); /* Move right port outwards */
        }
        body:not(.body-is-pill-dragging) .node-wrapper:hover .node-port.left-port {
            transform: scale(1.1) translateX(-6px); /* Move left port outwards */
        }
        /* --- END NEW --- */

        /* This rule allows hovering the port itself, but not during a pill drag */
        body:not(.body-is-pill-dragging) .node-port:hover {
            opacity: 1;
            transform: scale(1.2); /* Slightly larger on direct port hover */
            transition-delay: 0s; /* No delay on appearance */
        }
        /* Positioning for each port */
        .node-port.top-port {
            top: -10px; /* Original offset */
            left: calc(50% - 10px); /* Original offset */
           
            display: none !important; /* Still disable top/bottom for now */
            pointer-events: none !important;
        }
        .node-port.right-port {
            right: -10px; /* Original offset */
            top: calc(50% - 10px); /* Original offset */
            /* FIX: Center port vertically (16px height / 2) */
        }
        .node-port.bottom-port {
            bottom: -10px; /* Original offset */
            left: calc(50% - 10px); /* Original offset */
           
            display: none !important; /* Still disable top/bottom for now */
            pointer-events: none !important;
        }
        .node-port.left-port {
            left: -10px; /* Original offset */
            top: calc(50% - 10px); /* Original offset */
        }

        /* Class to force immediate hiding by JS */
        .node-port.hidden-by-js {
            opacity: 0 !important;
            transform: scale(0) !important;
            transition-delay: 0s !important; /* No delay for immediate hiding */
        }

        /* Highlighted destination port in connection mode */
        .node-port.highlighted-destination-port {
            opacity: 1 !important;
            transform: scale(1.2) !important;
            pointer-events: none !important; /* Ensure node click passes through */
            transition-delay: 0s !important; /* No delay for highlighting */
        }
        /* NEW: Hide ports on action nodes completely */
        .action-node .node-port {
            display: none !important;
        }


        /* Modal Dialog Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000; /* Default z-index for modals */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        /* Update modal-content to use flexbox */
        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 32px;
            width: 90%;
            max-width: 800px; /* Increased max-width to accommodate preview */
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            animation-name: animatetop;
            animation-duration: 0s;
            position: relative;
            display: flex; /* Make it a flex container */
            gap: 30px; /* Space between preview and content */
            flex-direction: column;
        }

        .preview-container {
             /* Prevent it from shrinking */
            width: 200px; /* Fixed width for the preview area */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0; /* Light background for the preview area */
            border-radius: 12px;
            overflow: hidden; /* Ensure content stays within bounds */
            padding: 15px; /* Add some padding inside the preview container */
            box-shadow: inset 0 0 8px rgba(0,0,0,0.1); /* Subtle inner shadow */
        }

        /* NEW: Wrapper for the main content area of the modal */
        .modal-main-content {
            flex: 1.3; /* Allows this wrapper to take up available space */
            display: flex; /* Makes its children (header, body, footer) stack vertically */
            flex-direction: column;
        }

        @keyframes animatetop {
            from {transform: translateY(-100px); opacity: 0}
            to {transform: translateY(0); opacity: 1}
        }
        .modal-header {
            display: flex;
            justify-content: space-between; /* To push close button to right */
            align-items: center; /* Vertically align input and close button */
            padding-bottom: 0px; /* Keep some padding if needed for other elements */
            margin-bottom: 20px; /* Keep margin bottom for spacing below header */

            margin-left: 20px; /* Remove previous margin-left */
            /* Add a subtle separator */
            margin-left: 14px;
        }

        /* Style for the node name input field in the header */
        .modal-header #node-name {
            flex-grow: 1; /* Allow input to take available space */
            width: auto; /* Override modal-body width */
            padding: 0; /* Remove default padding */
            margin-bottom: 0; /* Remove default margin-bottom from modal-body rule */
            font-size: 28px; /* Bigger text */
            font-weight: bold;
            color: #333;
            background-color: transparent; /* No background */
            border: none; /* No border in unselected state */
            box-shadow: none; /* No shadow */
            border-radius: 0; /* No border radius */
            box-sizing: content-box; /* Ensures padding/border doesn't add to width */
            outline: none; /* Remove default focus outline */
        }

        /* On selection (focus), only have bottom border */
        .modal-header #node-name:focus {
            border: none; /* Ensure no border on other sides */
            border-bottom: 2px solid #2196f3; /* Blue bottom border */
            /* Add some padding for visual separation */
            transition: border-bottom 0.2s ease-in-out; /* Smooth transition for border */
        }

        /* Adjust the close button if needed to align better after input changes */


        .modal-header h2 {
            margin: 0;
            font-size: 24px;
            color: #333;
        }

        .close-button {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: none;
            padding-bottom: 6px; /* Keep close button transition instant */
        }

        .close-button:hover,
        .close-button:focus {
            color: #666;
        }



        .modal-body input[type="range"],
        .modal-body input[type="checkbox"],
        .modal-body input[type="text"],
        .modal-body input[type="number"] { /* Added number type */
           
            /*width: calc(100% - 16px);*/
            width: 46px;
            padding: 10px;
            border: 0px solid #ccc;
            border-radius: 10px;
            box-sizing: border-box;
            font-size: 15px;
        }

       
        /* Hide native select element */
        .modal-body select {
            display: none;
        }

        .modal-body label {
            margin-bottom: 0; /* Remove default margin from label to let gap handle it */
            font-weight: bold; /* Keep bold if desired */
            color: #555; /* Keep color if desired */
            font-size: 12px; /* Keep font-size if desired */
            letter-spacing: 1px;
        }

        .dropdown-group {
            background-color: #e6f6ff7a; /* Softer, light grey background */
            border: 2px solid #b8cde329; /* Subtle border */
            border-radius: 16px; /* Modern, less pronounced rounding */
            padding: 12px 16px; /* Adjusted padding */
            margin-top: 0px;
            margin-bottom: 0px; /* Space between dropdown groups */
            display: flex; /* Use flexbox for label and select alignment */
            gap: 8px; /* Space between label and select */
            width: auto; /* Allow dropdown groups to size based on content or flex */
            flex: 1; /* Distribute space equally among dropdowns */
            position: relative; /* Needed for absolute positioning of custom dropdown options */
            cursor: pointer; /* Indicate clickable area */
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out; /* Smooth transitions */
        }

        /* Custom Dropdown Styles */
        .custom-dropdown-container {
            position: relative;
            flex-grow: 1; /* Allows the container to take available space */
        }

        .custom-dropdown-display {
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            color: #333;
            padding-right: 20px; /* Space for the arrow icon */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            width: 100%; /* Ensure it takes full width of its flex item */
            box-sizing: border-box; /* Include padding in width */
        }

        .custom-dropdown-options {
            position: absolute;
            background-color: #ffffff;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1050; /* Ensure it's above other elements */
            border-radius: 12px; /* Match parent rounding */
            overflow-y: auto;
            width: 250px; /* Set a minimum width for better readability */
            left: 0;
            top: calc(100% + 18px); /* Increased vertical space */
            border: 1px solid #e0e0e0; /* Softer border */
            padding: 6px; /* Padding inside the options box */
            /* --- NEW: Animation Properties --- */
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95, 0.95) translateY(-10px);
            transform-origin: top;
            transition: opacity 300ms cubic-bezier(0.45,0, 0.3, 1), transform 300ms cubic-bezier(0.45,0, 0.3, 1), visibility 300ms;
            /* --- END NEW --- */
        }

        .custom-dropdown-options.open {
            opacity: 1;
            visibility: visible;
            transform: scale(1, 1) translateY(0);
        }

        #global-animation-options.open {
            transform: translateX(-32px);
        }

        .custom-dropdown-option {
            padding: 10px 14px; /* Increased padding for more spacious items */
            cursor: pointer;
            font-size: 15px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 8px; /* Rounded corners for each option */
            transition: background-color 0.15s ease-in-out; /* Smooth hover effect */
        }

        .custom-dropdown-option:hover {
            background-color: #f1f3f5; /* Light grey for hover */
        }

        .custom-dropdown-option.selected {
            background-color: #e9ecef; /* Darker grey for selected option */
            font-weight: 600; /* Semi-bold for selected option */
        }


        .modal-body input[type="range"] {
            width: 100%;
            padding: 0;
        }
        .modal-body .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-body .checkbox-group label {
            margin-bottom: 0;
            margin-left: 8px;
        }


        /* Styles for the toggle switch */
        .toggle-group {
            display: flex;
             gap: 10px;
            justify-content: space-between; /* Pushes label and switch to ends */
            align-items: center;
            flex-direction: row;
            border-radius: 8px;
            padding: 15px;
        }

        .toggle-group label {
           margin: auto;
            font-weight: 400;
            color: #555;
            font-size: 12px;
            text-transform: uppercase;
            flex-grow: 1; /* Allow label to take available space */
        }

        /* The switch - the box around the slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 52px; /* Width of the toggle */
            height: 32px; /* Height of the toggle */
        }

        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 24px; /* Height of the draggable circle/thumb */
            width: 24px;  /* Width of the draggable circle/thumb */
            left: 4px; /* Initial position of the thumb */
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: #2196F3; /* Color when toggle is ON */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(20px); /* Move thumb to the right when ON */
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%; /* Make the thumb circular */
        }


        .modal-footer {

            padding-top: 20px;
            margin-top: 25px;
            text-align: right;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* General button styles within modal-footer */
  .modal-footer button {
      padding: 12px 25px; /* Default padding for other buttons like Cancel */
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 8px; /* Default border-radius for other buttons */
      transition: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  /* Specific styles for the circular Save button */
  .modal-footer button.save {
      background-color: #28a745;
      color: white;
      width: 50px;   /* Fixed width for circular shape */
      height: 50px;  /* Fixed height for circular shape */
      padding: 0;    /* Remove padding to center icon */
      border-radius: 50%; /* Make it circular */
      display: flex; /* Use flexbox to center content (icon) */
      justify-content: center; /* Center horizontally */
      align-items: center; /* Center vertically */
      font-size: 20px; /* Adjust icon size */
      margin-left: 10px; /* Adjust spacing from Cancel button if needed */
      
  }

  .modal-footer button.save:hover {
      background-color: #218838;
  }

  /* Specific styles for the circular Delete button */
  .modal-footer button.delete {
      background-color: #dc3545;
      color: white;
      width: 50px;   /* Fixed width for circular shape */
      height: 50px;  /* Fixed height for circular shape */
      padding: 0;    /* Remove padding to center icon */
      border-radius: 50%; /* Make it circular */
      display: flex; /* Use flexbox to center content (icon) */
      justify-content: center; /* Center horizontally */
      align-items: center; /* Center vertically */
      font-size: 20px; /* Adjust icon size */
  }

  .modal-footer button.delete:hover {
      background-color: #c82333;
  }

  /* Ensure other buttons (like Cancel) retain their original look */
  .modal-footer button.cancel {
      background-color: #6c757d;
      color: white;
      margin-right: 10px; /* Keep margin for spacing */
      padding: 12px 25px; /* Reapply specific padding for cancel button */
      font-size: 16px; /* Reapply specific font-size for cancel button */
      border-radius: 8px; /* Reapply specific border-radius for cancel button */
      width: 50px;   /* Fixed width for circular shape */
      height: 50px; /* Fixed height for circular shape */
      border-radius: 50%; /* Make it circular */
  }
  .modal-footer button.cancel:hover {
      background-color: #5a6268;
  }

        /* Connection SVG Styling */
        #connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            cursor: grab;
            transform: translateY(5px);
        }

        .connection-line { /* This class will now apply to SVG <path> elements */
            stroke: #3498db;
            stroke-width: 1.4;
            fill: none;
            pointer-events: none;
            cursor: pointer;
            transition: none;
            opacity: 1.0; /* Make lines fully opaque */
        }
        .connection-line:hover {
            stroke: #2980b9;
            stroke-width: 3.5;
        }
        /* NEW: Guard Connection Line */
        .guard-connection-line {
            stroke: #dc3545; /* Solid Red */
            stroke-width: 2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
            opacity: 0.7;
        }
        .guard-connection-line:hover {
            stroke: #2980b9;
            stroke-width: 3.5;
        }
        /* NEW: Styles for Guard Connection Text Pills */
        .guard-connection-text-bg {
           fill: #f5f5f5;
    stroke: #e57373;
            stroke-width: 1;
            rx: 8;
            ry: 8;
            pointer-events: all;
            cursor: pointer;
            transition: fill 0.2s ease-in-out;
        }
        .guard-connection-text-bg:hover {
            fill: #ffcdd2; /* Slightly darker light red on hover */
        }
        .guard-connection-text {
            font-size: 12px;
            fill: #c62828; /* Darker Red for text */
            text-anchor: middle;
            dominant-baseline: middle;
            font-weight: bold;
            user-select: none;
            pointer-events: none;
        }
        .guard-connection-text .variable-pill {
           font-size: 11px;
            font-weight: 700;
           fill: #ffffff; /* amber-900 */
            /* The background will be handled by a <rect> element created in JS,
               but we can define the text properties here. */
        }
      .connection-text-group .variable-pill-bg {
           fill: #e57373; /* A medium red, darker than the main pill bg */
            stroke: #ef9a9a; /* Lighter red stroke */
            stroke-width: 1;
            rx: 8; /* Match the main pill's rounding */
            ry: 8;
        }


        .connection-line.selected-connection {
            stroke: #ff5722;
            stroke-width: 5;
        }
        .connection-line.active-connection {
            opacity: 1.0; /* Full opacity for active connections */
        }
        .connection-line-arrow {
            fill: #3498db; /* Match the line color */
            pointer-events: none;
        }

        .connection-text-bg {
            fill: #e0f2f7;
            stroke: #a7d9ed;
            stroke-width: 1;
            rx: 8;
            ry: 8;
            pointer-events: all;
            cursor: pointer;
            transition: none;
        }
        .connection-text-bg:hover {
            fill: #cce9f2;
            stroke: #8cc2da;
        }

        .connection-text {
            font-size: 12px;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: middle; /* Better vertical centering for text */
            font-weight: bold;
            user-select: none;
            pointer-events: none;
        }

        /* Ghost line styles */
        #ghost-connection-line {
            stroke: #999;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 2, 6; /* Dotted line */
            pointer-events: none;
            display: none; /* Hidden by default */
        }
        #ghost-connection-arrow {
            fill: #999;
            pointer-events: none;
            display: none; /* Hidden by default */
        }


        /* Connection Editor Dialog */
        .connection-editor-modal {
            position: fixed;
            z-index: 1002; /* Z-index for connection editor */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            /* --- NEW: Use opacity for fade animation --- */
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            justify-content: center;
            align-items: center;
            display: flex;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s;
        }
        .connection-editor-modal.open {
            opacity: 1;
            visibility: visible;
            display: flex;
            flex-direction: column;
        }

        .connection-editor-content {
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #ddd;
            border-radius: 16px; /* Slightly more rounded */
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            /* --- NEW: Animation properties for scale/fade --- */
            transform: scale(0.9);
            opacity: 0;
            /* --- FIX: Explicitly set the transform origin to prevent glitchy scaling animations --- */
            transform-origin: center;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            will-change: transform, opacity;
        }
        .connection-editor-modal.open .connection-editor-content {
            transform: scale(1);
            opacity: 1;
        }
        /* Dynamic fields container */
        #dynamic-interaction-fields {
           
            padding-top: 0px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            margin: 10px 0;

        }
        .dynamic-field-group {
            
            justify-content: space-between;
            display: flex;
        }
        .dynamic-field-group label {
            display: block;
            margin-bottom: 5px;
           
            font-weight: 500;
            font-size: 14px;
            color: #555;
            letter-spacing: 1px;
            margin: auto;
            margin-left: 10px;
        }
        .dynamic-field-group {
            font-size: 14px;
            color: #333;
        }
        .dynamic-field-group input[type="text"],
        .dynamic-field-group input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ccc;
            border-radius: 24px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #ffffff7a;
            height: 36px;
        }

        /* NEW: Style for the full-width pill button */
        .full-width-pill-button {
            width: 100%;
            padding: 12px;
            font-size: 15px;
            font-weight: bold;
            color: #333;
            background-color: #d4edda; /* Pastel green background */
            color: #155724; /* Dark green text for contrast */
            border: 1px solid #c3e6cb; /* Matching pastel green border */
            border-radius: 999px; /* Pill shape */
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .full-width-pill-button:hover {
            background-color: #c3e6cb; /* Slightly darker green on hover */
            border-color: #b1dfbb;
        }

        .connection-editor-content .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px; /* Adjust margin for spacing */
        }
        .modal-footer {
            display: flex;
            gap: 10px;
            flex-direction: row;
        }

        /* Specific styles for connection editor buttons */
        .connection-editor-content .modal-footer button.cancel {
            background-color: #6c757d;
            color: white;
            padding: 12px 25px; /* Reapply specific padding for cancel button */
            font-size: 16px; /* Reapply specific font-size for cancel button */
            border-radius: 8px; /* Reapply specific border-radius for cancel button */
            transition: none; /* Keep button transitions instant */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-right: 10px; /* Add some margin for spacing */
        }
        .connection-editor-content .modal-footer button.cancel:hover {
            background-color: #5a6268;
        }


        .mode-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            z-index: 1001;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        #connect-mode-indicator {
            background-color: #ff9800;
            color: white;
        }
        /* NEW: Guard Mode Indicator */
        #guard-mode-indicator {
            background-color: #fbc02d; /* Yellow */
            color: #333;
        }

        #connection-exists-indicator { /* New style for connection exists message */
            background-color: #dc3545; /* Red background */
            color: white;
        }

        /* Custom alert styling */
        .custom-alert-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Ensure it's on top of other modals */
        }
        .custom-alert-box {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 350px;
            width: 90%;
        }
        .custom-alert-box p {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        .custom-alert-box button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
        }
        .custom-alert-box button:hover {
            background-color: #0056b3;
        }

        .chip-marker{
          display: none;
        }


        /* Styles for the State Preview Window */
      #state-preview-window {
          position: fixed;
          top: 0; /* Flush with the top of the viewport */
          right: 0; /* Flush with the right of the viewport */
          width: 350px; /* Adjust as needed */
          height: 100%; /* Full viewport height */
          background-color: #ffffff;
          border-radius: 0; /* Remove border-radius for a sidebar look */
          box-shadow: -6px 0 20px rgba(0, 0, 0, 0); /* Adjusted shadow for sidebar */
          z-index: 1000; /* Ensure it's above other content but below modals */
          transform: translateX(0); /* Initial state: fully visible */
          transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Smooth slide animation */
          display: flex;
          flex-direction: column; /* Content and toggle button side-by-side */
      }

      #state-preview-window.hidden {
          transform: translateX(calc(100% - 30px)); /* Hide, leaving only the 30px button visible */
          box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1); /* Lighter shadow when tucked away */
      }

      #preview-content {
          flex-grow: 1; /* Takes up most of the space */
          padding: 0; /* Remove padding to allow content to be flush */
          overflow-y: auto; /* Enable scrolling for the entire panel if content overflows */
          height: 100%; /* Ensure it takes full height to manage scrolling correctly */
      }

      #preview-toggle-button {
          width: 30px; /* Width of the button 'knotch' */
          height: 60px; /* Height of the button 'knotch' */
          background-color: #4a90e2; /* Blue, matching other controls */
          color: white;
          display: flex;
          justify-content: center;
          align-items: center;
          cursor: pointer;
          font-size: 18px;
          position: absolute; /* Position relative to #state-preview-window */
          left: -30px; /* Protrude by its own width */
          top: 50%; /* Center vertically */
          transform: translateY(-50%);
          border-top-left-radius: 8px; /* Rounded corners for the knotch */
          border-bottom-left-radius: 8px;
          box-shadow: -2px 0 5px rgba(0, 0, 0, 0.15); /* Shadow for the button */
          transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Add transition for button */
      }

      #preview-toggle-button:hover {
          background-color: #357bd8;
          box-shadow: -3px 0 8px rgba(0, 0, 0, 0.2);
      }

      /* Icon rotation for hide/show */
      #preview-toggle-button i {
          transition: transform 0.3s ease-in-out;
      }

      /* Arrow points right when window is visible (initial state) and then rotates to point left when window is hidden */
      #state-preview-window:not(.hidden) #preview-toggle-button i {
          transform: rotate(0deg); /* Arrow points right (inwards from the perspective of the *tucked* window) */
      }

      #state-preview-window.hidden #preview-toggle-button i {
          transform: rotate(180deg); /* Arrow points left (outwards from the perspective of the *tucked* window) */
      }

      /* NEW: Styles for the global state properties when inside the preview window */
      #global-state-properties-container {
          display: none; /* Hidden by default */
          flex-direction: column;
          height: 100%;
          width: 100%;
          padding: 0px 20px;
          box-sizing: border-box;
          overflow-y: auto;
          border: 1px solid #e2e2e2;
          overflow-x: hidden;
      }

      #global-state-properties-container .modal-header h2 {
          font-size: 24px;
          color: #333;
      }

      #global-state-properties-container .modal-body {
          padding-top: 6px;
      }

      #global-state-properties-container .modal-footer {
          margin-top: auto; /* Pushes footer to the bottom */
          padding: 15px 0px;
      }
      /* NEW: Match the input style of the node properties panel */
      #global-state-properties-container .modal-body #global-state-container-name-input {
          width: 100%;
          padding: 10px;
          margin-bottom: 24px;
          padding-bottom: 8px;
          font-size: 20px; /* Match node name font size */
          font-weight: bold;
          color: #333;
          background-color: transparent;
          border: none;
          box-shadow: none;
          border-radius: 0; /* Sharp corners */
          outline: none;
          border-bottom: 2px solid transparent; /* Subtle underline */
          transition: border-bottom 0.2s ease-in-out;
          box-sizing: border-box; /* Ensure padding doesn't affect width */
      }
      #global-state-properties-container .modal-body #global-state-container-name-input:focus {
          border-bottom: 2px solid #2196f3; /* Blue bottom border on focus */
      }
      #global-state-properties-container .dynamic-field-group label[for="global-state-container-name-input"] {
          display: none; /* Hide any explicit label as it's now implied */
      }
      /* --- FIX: Apply focus style with higher specificity --- */
      #node-properties-modal .modal-header #node-name:focus {
          border-bottom-color: #2196f3; /* Blue bottom border on focus */
      }


      /* Specific styles for the node-properties-modal */
              #node-properties-modal.modal { /* Target specifically the node properties modal */
                  background-color: transparent; /* Remove the black overlay for this modal only */
                  justify-content: stretch; /* Stretch horizontally */
                  align-items: stretch;     /* Stretch vertically */
                  padding: 0; /* Remove any padding that might prevent it from taking full space */
              }

              /* Update modal-content specifically for node-properties-modal */
              #node-properties-modal .modal-content {
                  background-color: #ffffff; /* Keep background white */
                  padding: 0; /* Remove padding for full-screen effect */
                  border: 1px solid #ddd; /* Keep border if desired, or remove */
                  border-radius: 0; /* Remove border-radius for sharp edges */
                  width: 100%; /* Make it take full width */
                  max-width: none; /* Remove max-width constraint */
                  height: 100%; /* Make it take full height */
                  box-shadow: none; /* Remove box shadow */
                  animation-name: none; /* Remove animation for instant appearance */
                  gap: 0; /* Remove gap between preview and main content */
                  flex-direction: column; /* Keep column direction for modal-content */
              }

              /* Adjust preview-container and modal-main-content for the specific node-properties-modal */
              #node-properties-modal .preview-container {
                  position: relative; /* Needed for absolute positioning of the overlay */
                  flex-shrink: 0; /* Prevent the preview from shrinking */
                  width: auto;
                  padding: 20px; /* Add back desired padding inside the preview */
                  border-radius: 0;
                  background-color: #f0f0f0b9;
                  box-shadow: none;
                  display: flex;
                  flex-direction: column;
                  justify-content: flex-start;
                  align-items: center;
              }

              /* NEW: Wrapper for canvas to handle overlay clipping */
              #canvas-wrapper {
                  position: relative; /* Full width of its container */
                  width: 99.1%; /* Full width of its container */
                  flex-grow: 1; /* Allow it to take up available vertical space */
                  border-radius: 12px 12px 0 0; /* Only round the top corners */
                  overflow: hidden; /* This is crucial for clipping */
                  border: 1px solid #ccc;
                  border-bottom: none; /* Remove bottom border as it will be on the slider */
              }


              /* NEW: Speed Control Overlay */
              #speed-control-overlay {
                  width: 100%; /* Take full width of parent */
                  background: rgba(255, 255, 255, 0.65); /* Light, semi-transparent background */
                  backdrop-filter: blur(8px); /* Frosted glass effect */
                  -webkit-backdrop-filter: blur(10px);
                  padding: 12px 15px; /* Slightly more vertical padding */
                  border-radius: 0 0 12px 12px; /* Round the bottom corners */
                  display: flex;
                  align-items: center;
                  gap: 12px;
                  color: #333; /* Dark text for readability on light background */
                  border: 1px solid #ccc;
                  border-top: none; /* Top border is handled by the canvas wrapper */
                  box-sizing: border-box; /* Ensure padding/border are included in width */
              }

              /* Style the slider within the overlay */
              #speed-control-overlay #speed-slider {
                  flex-grow: 1;
                  margin: 0;
                  width: auto; /* Override any other width settings */
                  padding: 0; /* Remove default padding */
                  background: #e5e5e5; /* Make track transparent */
              }

              /* NEW: White Theme Slider Styles */
              #speed-slider {
                  -webkit-appearance: none;
                  appearance: none;
                  height: 6px; /* Thinner bar for a lighter feel */
                  background: rgba(0, 0, 0, 0.1); /* Light grey track */
                  border-radius: 3px;
                  outline: none;
                  transition: opacity .2s;
              }

              /* Webkit (Chrome, Safari) Thumb */
              #speed-slider::-webkit-slider-thumb {
                  -webkit-appearance: none;
                  appearance: none;
                  width: 18px;
                  height: 18px;
                  background: #4a90e2; /* Primary blue color for visibility */
                  border: 2px solid white; /* Keep white border for contrast */
                  border-radius: 50%;
                  cursor: pointer;
                  margin-top: -3px; /* Center thumb on the 6px track */ /* FIX: Center thumb on the 6px track */
                  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
              }

              /* Mozilla (Firefox) Thumb */
              #speed-slider::-moz-range-thumb {
                  width: 18px;
                  height: 18px;
                  background: #4a90e2; /* Primary blue color for visibility */
                  border: 2px solid white; /* Keep white border for contrast */
                  border-radius: 50%;
                  cursor: pointer;
                  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
              }

              /* Remove default track styles for Firefox */
              #speed-slider::-moz-range-track {
                  width: 100%;
                  height: 6px; /* Thinner bar for a lighter feel */
                  background: rgba(0, 0, 0, 0.1); /* Light grey track */
                  border-radius: 3px;
                  border: none;
              }

              /* Style the speed value text */
              #speed-control-overlay #speed-value {
                  font-weight: 600;
                  font-size: 13px;
                  min-width: 40px; /* Reserve space to prevent layout shift */
                  text-align: center;
              }

              #node-properties-modal .modal-main-content {
                  flex: 1;
                  overflow-y: auto; /* Allow this section to scroll if content overflows */
                  display: flex; /* Make it a flex container to manage children */
                  flex-direction: column; /* Stack children vertically */
              }

              /* Hide the scrollbar but keep it scrollable */
              #node-properties-modal .modal-main-content::-webkit-scrollbar {
                  display: none; /* For Chrome, Safari, and Opera */
              }
              #node-properties-modal .modal-main-content {
                  -ms-overflow-style: none;  /* For Internet Explorer and Edge */
                  scrollbar-width: none;  /* For Firefox */
              }

              #node-properties-modal .modal-header {
                  margin-bottom: 20px;
                  padding: 20px 20px 0 20px; /* Apply padding here */
              }

              /* Minor adjustment for input in modal header specific to node properties modal */
              #node-properties-modal .modal-header #node-name {
                  font-size: 24px;
                  padding-left: 0;
                  padding-right: 0;
                  margin-left: 0;
                  margin-right: 0;
                  margin-top: 10px;
                  width: 100%;
                  
              }

              #node-properties-modal .modal-body {
                  padding: 0 20px; /* Apply horizontal padding here */
                  flex-grow: 1;
                  display: flex;
                  flex-direction: column;
              }

              #node-properties-modal .modal-footer {
                  position: sticky;
                  bottom: 0;
                  background-color: #ffffff;
                  padding: 15px 20px; /* Apply padding here */
                  margin-top: auto; /* Pushes footer to bottom in flex container */
                  border-top: 0px solid #e0e0e0; /* Separator line */
                  /* Ensure it's above the scrolling content if z-index issues arise */
                  z-index: 10;
              }

              /* --- NEW: Hide the save button ONLY for the state node properties panel --- */
              #node-properties-modal .modal-footer button.save {
                  display: none;
              }

              /* Ensure generic modal styles for other modals remain unchanged */
              .modal { /* This will still apply to other modals like connection-editor-modal */
                  /* The original styles for .modal */
                  display: none;
                  position: fixed;
                  z-index: 1000;
                  left: 0;
                  top: 0;
                  width: 100%;
                  height: 100%;
                  overflow: auto;
                  background-color: rgba(0,0,0,0.5); /* Keep semi-transparent background for other modals */
                  justify-content: center;
                  align-items: center;
              }

              /* And other .modal-content styles not overridden by #node-properties-modal .modal-content */
              .modal-content {
                  background-color: #ffffff;
                  padding: 30px; /* Original padding for other modals */
                  border: 1px solid #ddd;
                  border-radius: 32px;
                  width: 90%;
                  max-width: 800px;
                  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
                  animation-name: animatetop;
                  animation-duration: 0s;
                  position: relative;
                  display: flex;
                  gap: 30px;
                  flex-direction: column;
              }

        .node.initial-node {
            background-color: #ffffff; /* Keep the node background white, same as other nodes. */
        }
        /* Style for the 'Initial' pill */
        .node.initial-node::after {
            content: 'Initial';
            position: absolute;
            top: 12px;
            right: 12px;
            background-color: #28a745; /* Green pill background */
            color: #ffffff; /* White text */
            padding: 3px 8px;
            border-radius: 999px; /* Pill shape */
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Green text for the title of the initial node */
        .node.initial-node .node-title {
            color: #2e7d32; /* Dark green */
        }

        /* NEW: Global State Description Text */
        .global-state-description {
            width: 100%;
            background-color: #fffbe6; /* Light yellow */
            color: #854d0e; /* Dark amber text */
            text-align: left;
            border-radius: 8px;
            padding: 10px 14px;
            border: 1px solid #fde68a; /* Yellow border */
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 20px; /* Space between description and input */
            box-sizing: border-box;
        }
        
        /* NEW: Prompt for creating a global node from the action panel */
        .action-node-prompt {
            background-color: #fffbe6; /* Light yellow */
            color: #854d0e; /* Dark amber text */
            border: 1px solid #fde68a; /* Yellow border */
            border-radius: 16px;
            padding: 25px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: auto; /* This will vertically center the box in the flex container */
            width: 100%;
            max-width: 300px;
        }

        .action-node-prompt p {
            margin: 0;
            font-size: 15px;
            font-weight: 500;
            line-height: 1.5;
        }

        .action-node-prompt button {
            background-color: #f59e0b; /* Amber */
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        /* END NEW */

        /* Lighter green text for the details of the initial node */
        .node.initial-node .node-details,
        .node.initial-node .node-details i {
            color: #4caf50; /* Lighter green */
        }

        /* NEW: Styles for the combined input group in the guard modal */
        .combined-input-group {
            display: flex;
            align-items: stretch; /* Make children fill the height */
            background-color: #e6f6ff7a;
            border: 2px solid #b8cde329;
            border-radius: 16px;
            margin-top: 8px;
           
        }
        .combined-input-separator {
            width: 1px;
            background-color: #d0e0f0; /* A slightly darker separator line */
            margin: 0px 0; /* Vertical margin to not touch the top/bottom */
            opacity: 0.7;
        }

          /* --- NEW: Target Icon Button on Preview --- */
        .preview-target-button {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            width: 38px;
            height: 38px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px; /* This creates the "squircle" shape */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 16px;
            color: #555;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: none;
        }

        .preview-target-button:hover {
            background-color: white;
            border-color: rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        /* Style for when the button is toggled 'on' */
        .preview-target-button.active {
            background-color: #4a90e2; /* Blue to indicate active state */
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }
        /* --- END NEW --- */

        /* --- NEW: Styles for the interaction dropdown with target button --- */
        #interaction-group-wrapper {
            display: flex;
            align-items: stretch; /* MODIFIED: Stretch items to match height */
            gap: 10px;
            margin-top: 8px;
        }
        #interaction-group-wrapper #interaction-preset-dropdown-group {
            flex-grow: 1; /* Allow dropdown to take available space */
            margin-top: 0; /* Remove margin as it's on the wrapper now */
        }
        #edit-click-area-button {
            width: 70px; /* Keep width fixed */
            flex-shrink: 0; /* Prevent button from shrinking */
            padding: 0;
            border-radius: 12px;
            background-color: #d4edda; /* Pastel green background */
            color: #155724; /* Dark green text for contrast */
            border: 1px solid #c3e6cb; /* Matching pastel green border */
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: none; /* Hidden by default, shown by JS */
            /* --- NEW: Use flexbox to center the icon --- */
            align-items: center;
            justify-content: center;
        }
        #edit-click-area-button:hover {
            background-color: #c3e6cb; /* Slightly darker green on hover */
            border-color: #b1dfbb;
        }
        /* --- END NEW --- */

        /* --- NEW: CSS Variables for Modal Animations --- */
        :root {
            --iframe-content-duration: 450ms;
            --iframe-backdrop-duration: 300ms;
            --iframe-slide-in-easing: cubic-bezier(0.7, 0, 0.9, 0.9);
            --iframe-slide-out-easing: cubic-bezier(0.7, 0, 0.9, 0.9);
            --iframe-backdrop-easing: linear;
        }
        /* --- END NEW --- */



        /* --- NEW: Darker, blurry backdrop for the crop tool modal --- */
        #crop-tool-modal {
            background-color: rgba(0, 0, 0, 0.65); /* Darker background */
            backdrop-filter: blur(8px); /* Apply blur effect */
            -webkit-backdrop-filter: blur(8px); /* For Safari */
            opacity: 1; /* Start with full opacity when displayed */
            transition: opacity var(--iframe-backdrop-duration) var(--iframe-backdrop-easing);
        }

        /* NEW: Apply scale transform only to the content inside the crop modal */
        #crop-tool-modal .modal-content {
            /* Transitions are now on the children, not the main content container */
        }

        /* NEW: Add transitions for the header (buttons) */
        #crop-tool-modal .modal-header {
            transition: transform var(--iframe-content-duration) var(--iframe-slide-out-easing), opacity var(--iframe-content-duration) var(--iframe-slide-out-easing);
        }

        /* NEW: Add transitions for the iframe */
        #crop-tool-modal #crop-tool-iframe {
            transition: transform var(--iframe-content-duration) var(--iframe-slide-out-easing), opacity var(--iframe-content-duration) var(--iframe-slide-out-easing);
        }




        /* --- NEW: Darker, blurry backdrop for the click area modal --- */
        #click-area-modal {
            background-color: rgba(0, 0, 0, 0.65); /* Darker background */
            backdrop-filter: blur(8px); /* Apply blur effect */
            -webkit-backdrop-filter: blur(8px); /* For Safari */
            /* --- NEW: Add backdrop transition --- */
            opacity: 1;
            transition: opacity var(--iframe-backdrop-duration) var(--iframe-backdrop-easing);
        }

        /* --- NEW: Add transitions for the click area modal's children --- */
        #click-area-modal .modal-header {
            transition: transform var(--iframe-content-duration) var(--iframe-slide-out-easing), opacity var(--iframe-content-duration) var(--iframe-slide-out-easing);
        }

        #click-area-modal #click-area-iframe {
            transition: transform var(--iframe-content-duration) var(--iframe-slide-out-easing), opacity var(--iframe-content-duration) var(--iframe-slide-out-easing);
        }

        /* --- NEW: Toast Notification Styles --- */
        .toast-notification {
            position: fixed;
            top: -100px; /* Start off-screen */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(50, 50, 50, 0.9);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            color: white;
            padding: 12px 24px;
            border-radius: 999px; /* Pill shape */
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 9999;
            font-size: 15px;
            font-weight: 500;
            opacity: 0;
            transition: top 0.5s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: none; /* Toasts don't block clicks */
        }
        /* --- NEW: Separator with Pill Text --- */
        .separator-with-text {
            display: flex;
            align-items: center;
            text-align: center;
            color: #888;
            margin: 10px 0 14px 0; /* Top, H, Bottom */
        }
        .separator-line {
            flex-grow: 1;
            border-bottom: 1px solid #eee;
        }
        .separator-pill {
            padding: 4px 12px;
            background-color: #f0f2f5; /* Light grey background */
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin: 0 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        /* --- END NEW --- */

        /* --- NEW: Keyframes for button pop animation --- */
        @keyframes button-pop {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.92);
            }
            100% {
                transform: scale(1);
            }
        }
        /* --- END NEW --- */

        /* --- NEW: Keyframes for click area button save animation --- */
        @keyframes icon-scale-in-out {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .icon-saved {
            animation: icon-scale-in-out 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }

        @keyframes button-shockwave {
            0% {
                transform: scale(1);
                opacity: 0.6;
                box-shadow: 0 0 0 0px rgba(40, 167, 69, 0.6);
            }
            100% {
                transform: scale(1);
                opacity: 0;
                box-shadow: 0 0 0 12px rgba(40, 167, 69, 0);
            }
        }
        .button-shockwave-effect {
            position: relative; /* Needed for the ::after pseudo-element */
        }
        .button-shockwave-effect::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px; /* Match the button's border-radius */
            animation: button-shockwave 0.5s ease-out forwards;
        }
        /* --- END NEW --- */

        /* --- NEW: Styles for the boolean toggle in the action editor --- */
        .boolean-toggle-container {
            display: flex;
            width: 100%;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }
        .boolean-toggle-option {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            background-color: #f8f9fa;
            color: #6c757d;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .boolean-toggle-option.active {
            background-color: #4a90e2;
            color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        /* --- END NEW --- */

        /* --- NEW: Styles for the Global Variable Editor Block --- */
        .variable-editor-block {
            background-color: #ffffff; /* Light grey background */
            border: 1px solid #e9ecef; /* Softer border */
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
        }
        .variable-editor-block:hover {
            border-color: #dee2e6;
            box-shadow: 0 4px 8px rgba(0,0,0,0.06);
        }

        /* --- NEW: Subtle, underline-style input for variable name --- */
        .variable-name-input {
            width: 100%;
            padding: 4px 0; /* Minimal vertical padding */
            padding-bottom: 2px;
            margin-bottom: 10px; /* Space below */
            font-size: 20px; /* Larger font size */
            font-weight: 600; /* Bolder */
            color: #343a40;
            background-color: transparent;
            border: none;
            border-bottom: 0px solid transparent; /* Subtle underline */
            box-shadow: none;
            border-radius: 0;
            outline: none;
            transition: border-color 0.2s ease-in-out;
        }
        .variable-name-input:focus {
            border-bottom-color: #4a90e2; /* Blue on focus */
        }

        /* --- NEW: Style for the delete variable button --- */
        .delete-variable-button {
            background: none; border: none; color: #adb5bd;
            cursor: pointer; font-size: 14px; opacity: 0.7;
            transition: all 0.2s;
        }
        .delete-variable-button:hover {
            color: #dc3545; /* Red on hover */
            opacity: 1;
            transform: scale(1.1);
        }
        /* --- END NEW --- */

        
        /* --- NEW: Shockwave animation for connection pill --- */
        .connection-text-group .shockwave {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(33, 150, 243, 0.7); /* Blueish color */
            transform: scale(0);
            opacity: 1;
            pointer-events: none;
            animation: shockwave-effect 0.6s ease-out;
        }

        @keyframes shockwave-effect {
            to {
                transform: scale(4.5);
                opacity: 0;
            }
        }
        /* --- END NEW --- */

        /* --- NEW: Animation for Node Properties Panel Content --- */
       #node-properties-modal .preview-container,
        #node-properties-modal .modal-main-content {
            /* Use the same easing as the variable block slide */
            transition: opacity 0.3s ease-out, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .panel-content-exit {
            opacity: 0 !important;
            transform: translateX(50px) !important; /* Slide RIGHT (out) */
        }
        /* --- END NEW --- */

        /* --- NEW: Style for marker preview canvas --- */
        .marker-preview canvas {
            width: 100%;
            height: 100%;
        }

        /* --- NEW: Styles for State Machine Player Modal --- */
        #state-machine-player-modal {
            background-color: rgba(0, 0, 0, 0.65); /* Darker background */
            backdrop-filter: blur(8px); /* Apply blur effect */
            -webkit-backdrop-filter: blur(8px); /* For Safari */
            opacity: 1;
            transition: opacity var(--iframe-backdrop-duration) var(--iframe-backdrop-easing);
            overflow: hidden;
        }
        /* --- MODIFIED: Use a more subtle fade-in and slide-down animation --- */
        #state-machine-player-modal .modal-content {
            /* A gentle "ease out back" for a subtle bounce effect */
            transition: transform 500ms cubic-bezier(0.34, 1.2, 0.64, 1), opacity 400ms ease-out;
        }

        /* --- MODIFIED: Styles for the player modal's content to look like a window --- */
        #state-machine-player-modal .modal-content {
            background-color: #ffffff; /* Give the window a solid background */
            border-radius: 12px; /* Round the corners of the window */
            overflow: hidden; /* Clip the content (title bar and iframe) */
            padding: 0; /* Remove padding to have content flush with edges */
            display: flex;
            gap:0;
            flex-direction: column;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2), 0 5px 10px rgba(0,0,0,0.1); /* Add a more pronounced shadow */
        }

        /* --- NEW: Title bar for the player window --- */
        #player-title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #f0f2f5; /* Light grey title bar */
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
            user-select: none;
        }
        #player-title-bar .title {
            font-weight: 600;
            color: #555;
        }
        #player-title-bar .window-controls {
            display: flex;
            gap: 15px;
        }
        .window-control-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: rgba(0,0,0,0.5);
            margin: auto;
            cursor: pointer;
        }
        /* --- END NEW --- */

        .guard-numeric-value-container{
            flex: 2.2;
            justify-content: center;
        }

        /* --- NEW: Styles for stepper buttons in modals (e.g., Guard editor) --- */
        .modal-stepper-button {
            background-color: #e9ecef; /* Light gray background */
            border: none;
            font-size: 18px;
            font-weight: 500;
           
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 8px; /* Circular shape */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s, transform 0.1s;
            margin: auto 4px;
            background: none;
        }

        .modal-stepper-button:hover {
            background-color: #dee2e6; /* Slightly darker on hover */
        }

        .modal-stepper-button:active {
            transform: scale(0.9); /* Pop effect on click */
        }
        /* --- END NEW --- */

         .guard-value-input{
            height: 45px;
            margin: auto 0px;
            text-align: center;
           
            border: none;
        }

        /* --- ADD THIS NEW RULE --- */
        .action-node-display.single-action-layout {
            gap: 8px; /* A bit more space between the symbol and the pill */
            padding: 10px 6px; /* Adjust padding for the new layout */
            justify-content: center;
        }

        /* --- ADD THIS NEW RULE --- */
        .action-node-symbol-large {
            font-size: 20px; /* Larger font for the symbol */
            font-weight: 700; /* Bolder */
            color: #3f51b5; /* Indigo color */
            line-height: 1.2;
            text-align: center;
        }

        /* --- ADD THIS NEW RULE --- */
        .action-node-variable-pill-large {
            background-color: #e7f3ff; /* Light blue background */
            color: #4a90e2; /* Blue text */
            border: 1px solid #d1e7ff;
            border-radius: 999px; /* Pill shape */
            padding: 4px 12px; /* A bit more padding than the small inner pill */
            font-size: 12px; /* Slightly larger text */
            font-weight: 600;
            width: 90%; /* Don't take 100% width */
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-sizing: border-box;
        }




        .action-node-display {
                display: flex;
                flex-direction: column;
                align-items: center; /* Center pills horizontally */
                justify-content: center; /* Center pills vertically */
                gap: 5px; /* MODIFIED: Was 6px */
                width: 100%;
                height: 100%;
                padding: 6px; /* MODIFIED: Was 8px */
                box-sizing: border-box;
            }

          .action-node-pill {
            background-color: #e7f3ff; /* Light blue background */
            color: #4a90e2; /* Blue text */
            border: 1px solid #d1e7ff;
            border-radius: 999px; /* Pill shape */
            padding: 5px 8px; /* MODIFIED: Was 3px 8px */
            font-size: 11px;
            font-weight: 600;
            width: 100%;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-sizing: border-box;
             transition: opacity 0.2s ease-in-out; 
        }

            .action-node-overflow-text {
                font-size: 10px;
                font-weight: 700;
                color: #90a4ae; /* Blue Grey */
                margin-top: -2px; /* Pull it slightly closer to the last pill */
            }

            input::-webkit-outer-spin-button,
                input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
                }

                /* Hide spin buttons on number inputs in Firefox */
                input[type="number"] {
                -moz-appearance: textfield;
                }

                .guard-boolean-value-container{
                    flex: 2;
                    justify-content: center;
                }
                .guard-boolean-value-display{
                    margin: auto 16px;
                }
                .guard-boolean-value-toggle{
                    background: transparent;
                    border: none;
                    font-size: 18px;
                    cursor: pointer;
                    color: #223f61;
                    padding-top: 4px;
                }

                .variable-editor-block {
                    /* Add this to make opacity and transform animatable */
                    transition: opacity 0.3s ease-out, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                }

                .variable-editor-block.slide-in-start {
                    opacity: 0;
                    transform: translateX(50px); /* Start 50px to the right */
                }

                /* CSS for the button's FLIP animation */
                #add-variable-button {
                    /* This transition property is key for the FLIP */
                    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                }

                /* --- NEW: Styles for the Global Variable Editor Block --- */
                .variable-editor-block {
                    background-color: #ffffff; /* Light grey background */
                    border: 1px solid #e9ecef; /* Softer border */
                    border-radius: 16px;
                    padding: 16px;
                    margin-bottom: 16px;
                    /* --- MODIFICATION: Add overflow: hidden and animate more properties --- */
                    overflow: hidden; /* This is crucial for the height animation */
                    transition: opacity 0.3s ease-out, 
                                transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                                height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                                padding-top 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                                padding-bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                                margin-bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    /* --- END MODIFICATION --- */
                    box-shadow: 0 2px 4px rgba(0,0,0,0.04);
                }
            /* --- MODIFIED: Animation for Node Properties Panel Content (with BOUNCY curve) --- */
                    #node-properties-modal .preview-container,
                        #node-properties-modal .modal-main-content {
                            /* Use the same easing as the variable block slide */
                            transition: opacity 0.3s ease-out, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                        }

                        .panel-content-exit {
                            opacity: 0 !important;
                            transform: translateX(50px) !important; /* Slide RIGHT (out) */
                        }
                        /* --- END MODIFIED --- */

                        /* --- MODIFIED: Add transition properties to Global/Action panel children (with SIDE-SLIDE curve) --- */
                        #global-state-properties-container > *,
                        #action-node-properties-container > * {
                            /* Use the same easing as the variable block slide */
                            transition: opacity 0.3s ease-out, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                        }
                    /* --- END MODIFIED --- */


                        .marker-card .marker-interactions:hover {
          background-color: #4a90e2; /* Solid blue on hover */
          color: #ffffff; /* White text on hover */
      }
      /* --- ADD THESE STYLES --- */
      .edit-segment-btn {
          background: #e9ecef;
          border: none;
          width: 30px;
          height: 30px;
          border-radius: 8px;
          cursor: pointer;
          color: #6c757d;
          font-size: 13px;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
      }
      .edit-segment-btn:hover {
          background: #dee2e6;
          color: #343a40;
      }
      /* --- END ADD --- */
      .marker-card .marker-interactions.hidden {
          display: none;
      }

      #share-tutorial-modal .modal-content {
            /* This animation is just for the new modal */
            animation: share-modal-animatetop 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        @keyframes share-modal-animatetop {
            from {transform: translateY(-50px); opacity: 0}
            to {transform: translateY(0); opacity: 1}
        }
        .share-step {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .share-step-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .share-step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #e7f3ff;
            color: #4a90e2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            flex-shrink: 0;
        }
        .share-step-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        .share-step-desc {
            font-size: 14px;
            color: #555;
            margin: 0 0 0 40px; /* Aligns with title */
            line-height: 1.5;
        }
        .share-modal-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 18px;
            font-size: 15px;
            font-weight: 600;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .share-modal-button.primary {
            background-color: #4a90e2;
            color: white;
            position: relative; /* For loader */
        }
        .share-modal-button.primary:hover {
            background-color: #357bd8;
        }
        .share-modal-button.secondary {
            background-color: #ffffff;
            color: #333;
            border: 1px solid #e0e0e0;
            width: fit-content;
            margin-left: 40px;
        }
        .share-modal-button.secondary:hover {
            background-color: #f8f9fa;
            border-color: #ccc;
        }
        .share-modal-button.secondary:disabled {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
            opacity: 1;
            cursor: not-allowed;
        }
        .share-modal-link {
            font-size: 14px;
            font-weight: 600;
            color: #4a90e2;
            text-decoration: none;
            margin-left: 40px;
            padding: 8px 12px;
            background-color: #e7f3ff;
            border-radius: 8px;
            width: fit-content;
            transition: background-color 0.2s;
        }
        .share-modal-link:hover {
            background-color: #dbeeff;
        }
        .share-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 0 14px;
            margin-left: 40px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .share-input-wrapper:focus-within {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }
        .share-input-wrapper i {
            color: #999;
        }
        .share-input-wrapper input {
            flex-grow: 1;
            border: none;
            outline: none;
            padding: 12px 0;
            font-size: 15px;
            background: none;
        }
        .button-loader {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            position: absolute;
            right: 18px;
        }
        /* --- END Share Modal Styles --- */

        .variable-pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px; /* Pill shape */
        background-color: #e7f3ff; /* Light blue */
        color: #4a90e2; /* Blue text */
        font-weight: 600;
        font-size: 11px; /* Slightly smaller than label */
        margin-right: 0px; /* Space between pill and text */
        vertical-align: middle; /* Align nicely with text */
        text-transform: none; /* Prevent inheriting uppercase from label */
        padding-bottom: 4px; /* Slightly more padding at bottom */
        margin-bottom: 2px;         
    }

    .variable-editor-block.dropdown-open {
            overflow: visible;
            /* Add z-index and position to ensure the open
               dropdown appears above its siblings */
            z-index: 10;
            position: relative;
        }

   .modal-body #global-state-container-name-input{
        margin-bottom: 16px !important;
    }

    .action-node-url-indicator {
            position: absolute;
            top: 10px;
            right: 12px;
            font-size: 14px;
            color: #4a90e2; /* Blue */
            opacity: 0.7;
            z-index: 1; /* Just above the node's content */
        }

        /* --- MODIFICATION: Ensure action-node is a positioning context --- */
       .action-node {
            background-color: #e8eaf6; /* Indigo light */
            border-color: #9fa8da; /* Indigo lighter */
            width: 160px; /* MODIFIED: Was 100px */
            height: 110px; /* MODIFIED: Was 100px */
            padding: 10px;
            justify-content: center;
            align-items: center;
            text-align: center;
            transform: translateY(0px);
            position: relative; /* This is needed for the absolute icon */
        }

        #rewire-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3); /* Semi-transparent black */
            backdrop-filter: blur(1px);
            -webkit-backdrop-filter: blur(1px);
            z-index: 50; /* Above connections (5) but below highlighted nodes (51) */
            opacity: 0;
            pointer-events: none; /* Allows mouse events to pass through */
            transition: opacity 0.2s ease-in-out;
        }

    </style>
</head>
<body>
    <template id="action-row-template">
    <div class="action-editor-row" style=" border-radius: 16px; padding: 0px; display: flex; flex-direction: column; gap: 0px; ">
        
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div class="dropdown-group action-variable-dropdown-group" style="display: none; flex: 1; margin: 0; border: none; background: transparent; padding: 0;">
                <!-- Variable Dropdown will be populated here by JS -->
            </div>
             <button class="delete-action-button" title="Delete Action" style="width: 30px; height: 30px; border-radius: 8px; border: none; background-color: #fbe9e7; color: #c62828; cursor: pointer; font-size: 14px; display: none;">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>

        <div class="combined-input-group">
            <div class="dropdown-group action-type-dropdown-group" style="flex: 3; margin: 0; border: none; background: transparent;">
                <!-- Action Type Dropdown will be populated here by JS -->
            </div>
            <div class="combined-input-separator" style="display: none;"></div>
            <div class="action-value-field" style="display: none; align-items: center; justify-content: center; flex: 1; gap: 12px; padding: 0 10px 0 4px;">
                <div class="action-numeric-container" style="display: flex; align-items: center; justify-content: center; width: 100%; gap: 2px;">
                    <input type="number" class="action-value-input" placeholder="Value" style="text-align: center; flex-grow: 1; border: none; background: transparent; font-size: 16px; margin: 0; -moz-appearance: textfield; width: 40px;">
                    <div class="stepper-buttons-vertical" style="display: flex; flex-direction: column; align-items: center;">
                        <button class="increment-action-value" style="background: transparent; border: none; font-size: 14px; color: #555; cursor: pointer; padding: 0 8px; line-height: 1;">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="decrement-action-value" style="background: transparent; border: none; font-size: 14px; color: #555; cursor: pointer; padding: 0 8px; line-height: 1;">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                </div>
                <div class="action-boolean-container" style="display: none; align-items: center; justify-content: center; width: 100%; gap: 6px; margin-left: 10px;">
                    <span class="action-boolean-value-display" style="font-weight: bold; font-size: 16px; color: #333; flex-grow: 1; text-align: center; margin-bottom: 1px;"></span>
                    <button class="action-boolean-value-toggle" title="Toggle value" style="background: none; border: none; box-shadow: none; cursor: pointer; margin-left: 12px; font-size: 16px; color: #555; padding: 0; padding-top: 1px;"><i class="fas fa-sync-alt"></i></button>
                </div>
            </div>
        </div>
    </div>
</template>




  <!-- NEW: Loader Overlay -->
  <div id="loader-overlay">
      <div class="loader"></div>
      <p>Loading..</p>
  </div>

  <!-- NEW: Main wrapper for the new layout -->
  <div id="main-wrapper">

      <!-- NEW: Main Application Container -->
      <!-- MODIFIED: Removed inline style -->
      <div id="app-container" style="position: relative; width: 100%; height: 100%;">
          <!-- NEW: Collapsible Left Panel (Moved inside app-container) -->
          <div id="left-panel">
                <div id="left-panel-header">
                    <h2 id="left-panel-title">Segments</h2>
                    <button id="left-panel-toggle" title="Toggle Panel">
                        <i class="fas fa-chevron-left"></i> 
                    </button>
                </div>
                <div id="left-panel-scroll-area">
                    <!-- Dynamic content (header, marker list) will be loaded here -->
                </div>
          </div>
          <div id="controls">
              <!-- NEW: Wrapper for the main control buttons -->
              <div id="main-controls-wrapper">
                  <button id="add-segments-button" title="Crop/Expand Lottie (Add Segments)"><i class="fas fa-crop-alt"></i></button>
                  <button id="add-node-button" title="Add State"><i class="fas fa-plus"></i></button>
                  <button id="add-action-node-button" title="Add Action Node"><i class="fas fa-bolt"></i></button>
                  <button id="connect-nodes-button" title="Connect States"><i class="fas fa-link"></i></button>
                  <button id="add-animation-json-button" title="Add Lottie Animation from JSON"><i class="fas fa-file-import"></i></button>                  
                  <button id="add-global-state-button" title="Add Global Variable" style="padding: 0 0 0 1px;"><i class="fas fa-globe"></i></button>
                  <button id="load-json-button" title="Load State Machine from JSON"><i class="fas fa-upload"></i></button>
                  <button id="export-json-button" title="Export State Machine to JSON"><i class="fas fa-download"></i></button>
                  <button id="load-lottie-button" title="Load State Machine from .lottie"><i class="fas fa-file-archive"></i></button>
                  <button id="export-lottie-button" title="Export State Machine to .lottie"><i class="fas fa-file-export"></i></button>
              </div>
              <button id="play-state-machine-button" title="Play State Machine"><i class="fas fa-play"></i></button>
          </div>
          <div id="state-preview-window">
            <div id="preview-toggle-button">
        <i class="fas fa-chevron-right"></i>
    </div>
              <div id="node-properties-modal" class="modal" style="display: flex;overflow: hidden;">
                  <div class="modal-content" style=" justify-content: space-between;">
                     <div class="preview-container">
                         <div class="panel-type-indicator" style="
                                            margin: 0 auto;
                                            margin-bottom: 12px;
                                            font-size: 14px;
                                            letter-spacing: 1.4px;
                                            font-weight: bold;
                                            text-transform: uppercase;
                                            opacity: 0.5;
                                        ">State Node</div>
                         <div id="canvas-wrapper">
                             <canvas id="modal-lottie-canvas" style="width: 100%; height: 100%;"></canvas>
                             <style>
                                 /* --- NEW: Checkerboard background for the preview canvas --- */
                                 #modal-lottie-canvas {
                                     background-color: #f0f0f0; /* Fallback color */
                                     background-image:
                                         linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
                                         linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
                                         linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
                                         linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
                                     background-size: 20px 20px;
                                     background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                                 }
                             </style>
                             <button id="preview-target-toggle" class="preview-target-button" title="Toggle Target Mode">
                                <i class="fas fa-crosshairs"></i>
                            </button>
                         </div>
                         <div id="speed-control-overlay">
                             <i class="fas fa-tachometer-alt"></i>
                             <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="1.0">
                             <span id="speed-value">1.0x</span>
                         </div>
                     </div>
                      <div class="modal-main-content">
                          <div class="modal-header">
                               <input type="text" id="node-name" value="New Node" placeholder="Node Name">
                              <span class="close-button" style="display: none;">&times;</span>
                          </div>
                          <div class="modal-body">
                            <div style="display: flex; flex-direction:column; justify-content: space-between; gap: 16px;">
                            <div class="dropdown-group" id="animation-dropdown-group">
                              <div style="
              display: flex;
              flex-direction: column;
              gap: 0.3rem;
          ">
                                  <label for="animation-select">ANIMATION</label>
                                  <div class="custom-dropdown-container">
                                      <div class="custom-dropdown-display" data-target-select="animation-select"></div>
                                      <div class="custom-dropdown-options" id="animation-options"></div>
                                      <select id="animation-select" style="display: none;"></select> </div>
                              </div>
                              <i class="fas fa-chevron-down dropdown-indicator" style = "margin: auto; margin-right: 1rem;"></i>
                            </div>
                              <div class="dropdown-group" id="marker-dropdown-group">
                                <div style="
              display: flex;
              flex-direction: column;
              gap: 0.3rem;
          ">
                                  <label for="marker-select">SEGMENT</label>
                                  <div class="custom-dropdown-container">
                                      <div class="custom-dropdown-display" data-target-select="marker-select"></div>
                                      <div class="custom-dropdown-options" id="marker-options"></div>
                                      <select id="marker-select" style="display: none;"></select> </div>
                                </div>
                              <i class="fas fa-chevron-down dropdown-indicator" style = "margin: auto; margin-right: 1rem;"></i>
                            </div>
                          </div>
                          <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 16px;">
              <div class="toggle-group" id="broadcast-entry-toggle-group" style="display:none;">
                  <div style=" flex-direction: column; gap:3px; flex:1; pointer-events: none;">
                  <label for="broadcast-entry-checkbox" style = "font-weight: 400;">Broadcast on entry:</label><span id="broadcast-entry-node-name" style =  "font-weight: 700; font-size: 14px;">nodeName_entry</span></div>
                  <div class="switch">
                      <input type="checkbox" id="broadcast-entry-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
              <div class="toggle-group">
                  <div style=" flex-direction: column; gap:3px; flex:1">
                  <label for="loop-checkbox" style="pointer-events:none; font-size: 12px;">LOOP ANIMATION</label></div>
                  <div class="switch">
                      <input type="checkbox" id="loop-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
              <div class="toggle-group" id="play-in-reverse-toggle-group">
                <div style="flex-direction: column; gap:3px; flex:1">
                  <label for="play-in-reverse-checkbox" style="font-weight: 400;">Play in Reverse</label>
                </div>
                  <div class="switch">
                      <input type="checkbox" id="play-in-reverse-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
              <div class="toggle-group" id="freeze-on-first-frame-toggle-group">
                  <div style="flex-direction: column; gap:3px; flex:1">
                    <label for="freeze-on-first-frame-checkbox" style="font-weight: 400;">Freeze On First Frame</label>
                  </div>
                    <div class="switch">
                        <input type="checkbox" id="freeze-on-first-frame-checkbox">
                        <span class="slider round"></span>
                    </div>
                </div>
              <div class="toggle-group" id="initial-node-toggle-group">
                          <div style="flex-direction: column; gap:3px; flex:1">
                            <label for="initial-node-checkbox" style="font-weight: 400;">Make this initial node</label>
                          </div>
                            <div class="switch">
                                <input type="checkbox" id="initial-node-checkbox">
                                <span class="slider round"></span>
                            </div>
                        </div>

              <div class="toggle-group" id="broadcast-exit-toggle-group"  style="display:none;">
                <div style="flex-direction: column; gap:3px; flex:1">
                  <label for="broadcast-exit-checkbox" style = "font-weight: 400;">Broadcast on exit:</label> <span id="broadcast-exit-node-name" style = "font-weight: 700; font-size: 14px;">nodeName_exit</span></div>
                  <div class="switch">
                      <input type="checkbox" id="broadcast-exit-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
          </div>

                          </div>
                          <div class="modal-footer">
                            <button id="delete-node-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                            <button id="save-node-properties" class="save"><i class="fas fa-check"></i></button>
                          </div>
                      </div>
                      </div>
              </div>
      </div>

      <!-- NEW: Container for Action Node Properties -->
    <div id="action-node-properties-container" style="display: none; border: 1px solid #ebebeb; flex-direction: column; height: 100%;">
        <!-- The content inside will be laid out vertically by default,
             but we'll ensure it's a flex column for consistency. -->
        <div class="panel-type-indicator" style="
                            margin: 0 auto;
                            margin-bottom: 10px;
                            margin-top: 20px;
                            font-size: 14px;
                            letter-spacing: 1.4px;
                            font-weight: bold;
                            text-transform: uppercase;
                            opacity: 0.5;
                        ">Action Node</div>
        <div class="modal-body" style="padding: 0px 20px;">
            <p class="global-state-description">When this node is reached, it will perform the selected action on the global variable.</p>
            <!-- This section will be populated by JS, reusing the action editor structure -->
            <div id="action-node-editor-content">
                <div id="node-actions-list" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Action rows will be dynamically added here by JavaScript -->
                </div>

                <!-- Button to add a new action -->
                <button id="add-node-action-button" class="full-width-pill-button" style="margin-top: 15px; background-color: #e7f3ff; color: #4a90e2; border-color: #d1e7ff;">
                    <i class="fas fa-plus" style="margin-right: 8px;"></i>
                    Add Action
                </button>
                    </div>
        </div>
        <div id="action-node-url-section">
    
    <div style="padding: 0 20px; padding-top: 10px;">
        <div class="dynamic-field-group" style="flex-direction: column; gap: 8px;">
                <div class="combined-input-group">
                    <div class="dropdown-group" style="flex: 1; margin: 0; border: none; background: transparent; align-items: stretch; padding-top: 12px; padding-bottom: 12px;">
                        <div style="display: flex; flex-direction: column; gap: 0.3rem; flex: 1;">
                            <label for="action-node-url-input" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">URL TO OPEN</label>
                            <div style="display:flex; align-items: center; gap: 10px; margin-top: 4px; padding-left: 2px;">
                                <i class="fas fa-link" style="color: #888; font-size: 14px; margin-right: 0px; margin-left: -12px; padding-left: 10px;"></i>
                                <input type="text" id="action-node-url-input" placeholder="https://example.com" style=" width: 100%; border: none; background: transparent; font-size: 16px; margin: 0; padding: 0; margin-left: 2px;">
                            </div>
                        </div>
                    </div>
                </div>
                <p style="font-size: 13px; color: #777; margin-left: 10px; margin-top: 8px;">If a URL is set, it will be opened when this action is triggered.</p>
            </div>
    </div>
</div>
        <div class="modal-footer" style="justify-content: space-between; padding: 20px 30px 30px 30px; margin-top: auto;">
             <button id="delete-action-node-button" class="delete"><i class="fas fa-trash-alt"></i></button>
             <button id="save-action-node-properties" class="save"><i class="fas fa-check"></i></button>
        </div>
    </div>

    <!-- NEW: Template for the Action Editor (to be cloned) -->
    <template id="action-editor-template">
        <!-- MODIFIED: Use the combined input group structure -->
        <div class="combined-input-group">
            <div class="dropdown-group" style="flex: 3; margin: 0; border: none; background: transparent;">
                <!-- Dropdown structure will be generated here -->
            </div>
            <div class="combined-input-separator" style="display: none;"></div>
            <div class="action-value-field" style="display: none; align-items: center; justify-content: center; flex: 2; gap: 12px; padding: 0 16px;">
                <!-- MODIFIED: Wrap numeric input in its own container -->
                <div class="action-numeric-container" style="display: flex; align-items: center; justify-content: center; width: 100%; gap: 12px;">
                    <button class="decrement-action-value" style="background: transparent; border: none; font-size: 22px; font-weight: 500; color: #555; cursor: pointer; padding: 0 8px;">-</button>
                    <input type="number" class="action-node-value-input" placeholder="Value" style="text-align: center; flex-grow: 1; border: none; background: transparent; font-size: 16px; margin: 0; -moz-appearance: textfield; width: 40px;">
                    <button class="increment-action-value" style="background: transparent; border: none; font-size: 22px; font-weight: 500; color: #555; cursor: pointer; padding: 0 8px;">+</button>
                    <style>.action-node-value-input::-webkit-outer-spin-button, .action-node-value-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }</style>
                </div>
                <!-- NEW: Container for Boolean Input -->
                <div class="action-boolean-container" style="display: none; align-items: center; justify-content: center; width: 100%; gap: 16px;">
                    <span class="action-boolean-value-display" style="font-weight: bold; font-size: 16px; color: #333; flex-grow: 1; text-align: center;"></span>
                    <button class="action-boolean-value-toggle" style="background: none; border: none; cursor: pointer; font-size: 16px; color: #555; padding: 5px;" title="Toggle value"><i class="fas fa-sync-alt"></i></button>
                </div>
            </div>
        </div>
        <!-- The old dynamic-field-group is no longer needed -->
    </template>

    <!-- NEW: Container for Global State Properties (Moved outside #flowchart-area) -->
    <div id="global-state-properties-container" style="display: none;">
        <div class="panel-type-indicator" style="
                            margin: 0 auto;
                            margin-top: 20px;
                            font-size: 14px;
                            letter-spacing: 1.4px;
                            font-weight: bold;
                            text-transform: uppercase;
                            opacity: 0.5;
                        ">Global Node</div>
        <div class="modal-body">
            <p class="global-state-description">A Global Variable can be used to create conditional transitions between states.</p>
            <input type="text" id="global-state-container-name-input" placeholder="Container Name">
            
            <!-- This div will hold the list of variable editors -->
            <div id="global-variable-list">
                <!-- This area will be populated by JavaScript -->
            </div>

            <!-- This is the new button to add more variables -->
            <button id="add-variable-button" 
                    class="full-width-pill-button" 
                    style="margin-top: 10px; background-color: #e7f3ff; color: #4a90e2; border-color: #d1e7ff;">
                <i class="fas fa-plus" style="margin-right: 8px;"></i>
                Add New Variable
            </button>

        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="delete-global-state-button" class="delete"><i class="fas fa-trash-alt"></i></button>
            <button id="save-global-state" class="save" title="Save and Close Panel"><i class="fas fa-check"></i></button>
        </div>
    </div>

    <input type="file" id="json-file-input" accept=".json" style="display: none;">
    <input type="file" id="lottie-file-input" accept=".lottie" style="display: none;">
    <input type="file" id="animation-json-file-input" accept=".json" style="display: none;">

    <!-- NEW: Global Animation Dropdown -->
    <div id="global-animation-controls">
        <div class="dropdown-group" style="margin-bottom: 0;">
            <!-- Add animation icon -->
            <i class="fas fa-film" style="color: #555; font-size: 16px;"></i>
            <div style="display: flex; flex-direction: column; gap: 0.3rem; flex: 1;"> <!-- Add flex:1 to take up space -->
                <label for="global-animation-select">GLOBAL ANIMATION</label>
                <div class="custom-dropdown-container">
                    <div class="custom-dropdown-display" id="global-animation-display" data-target-select="global-animation-select"></div>
                    <div class="custom-dropdown-options" id="global-animation-options"></div>
                    <select id="global-animation-select" style="display: none;"></select>
                </div>
            </div>
            <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
        </div>
    </div>


    <div id="flowchart-area">
            <div id="rewire-overlay"></div>
        <div id="canvas-container">
            <svg id="connection-svg">
                <path id="ghost-connection-line"></path>
                <polygon id="ghost-connection-arrow"></polygon>
            </svg>
        </div>
    </div>

    <span id="connect-mode-indicator" class="mode-indicator">Click first node, then second node.</span>
    <span id="guard-mode-indicator" class="mode-indicator" style="display: none;">Click the Global Variable, then the target State.</span>
    <span id="connection-exists-indicator" class="mode-indicator" style="display: none;">Connection already exists!</span>
    </div> <!-- End of #app-container -->


    <div id="crop-tool-modal" class="modal">
          <div class="modal-content" style="gap: 6px; width: 100%; max-width: 1100px; height: 95vh; padding: 0; flex-direction: column; background-color: transparent; border: none; box-shadow: none;">
              <div class="modal-header" style="padding-top: 0px; margin-bottom: 12px; justify-content: center; align-items: center; gap: 20px;">
                  <div style="display: flex; align-items: center; gap: 20px;">
                      <button id="save-crop-changes-button" class="save" title="Save and Apply Changes" 
                              style="width: auto; height: 40px; font-size: 16px; box-shadow: none; border-radius: 999px; padding: 0 20px; background-color: #28a745; border: none; color:white; display: flex; align-items: center; gap: 8px;"
                              onmouseover="this.style.backgroundColor='#218838'" 
                              onmouseout="this.style.backgroundColor='#28a745'">
                          <i class="fas fa-check"></i> Save
                      </button>
                      <button id="close-crop-modal-button" class="cancel" title="Cancel and Close" 
                          style="width: auto; height: 40px; font-size: 16px; box-shadow: none; border-radius: 999px; padding: 0 20px; background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; display: flex; align-items: center; gap: 8px;"
                          onmouseover="this.style.backgroundColor='#f1b0b7'" 
                          onmouseout="this.style.backgroundColor='#f8d7da'"
                          onmousedown="this.style.backgroundColor='#eea2a9'"
                          onmouseup="this.style.backgroundColor='#f1b0b7'">
                      <i class="fas fa-times"></i> Cancel
                  </button>
                  </div>
              </div>
              <iframe id="crop-tool-iframe" style="width: 100%; height: 100%; border: none; border-radius: 20px;"></iframe>
          </div>
      </div>

    <!-- NEW: Modal for the Click Area Editor -->
    <div id="click-area-modal" class="modal" style="z-index: 1003;">
        <!-- --- MODIFIED: Increased width and max-width for a larger editor --- -->
        <div class="modal-content" style="width: 95%; max-width: 1400px; height: 95vh; max-height: 1000px; padding: 10px; flex-direction: column; background-color: transparent; border: none; box-shadow: none;">
            <div class="modal-header" style="padding-bottom: 5px; margin-bottom: -45px; justify-content: center; align-items: center; gap: 6px;">
                <div style="display: flex; align-items: center; gap: 4px;">
                    <button id="save-click-area-button" class="save" title="Save Click Area" style="width: auto; height: 40px; font-size: 16px; margin-right: 15px; box-shadow: none; border-radius: 999px; padding: 0 20px; background-color: #28a745; border: none; color:white; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.backgroundColor='#218838'" onmouseout="this.style.backgroundColor='#28a745'">
                        <i class="fas fa-check" style="margin-right: 8px;"></i> Save
                    </button>
                    <button id="close-click-area-modal-button" class="cancel" title="Cancel and Close" 
                            style="width: auto; height: 40px; font-size: 16px; box-shadow: none; border-radius: 999px; padding: 0 20px; background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; display: flex; align-items: center; gap: 8px;"
                            onmouseover="this.style.backgroundColor='#f1b0b7'" 
                            onmouseout="this.style.backgroundColor='#f8d7da'"
                            onmousedown="this.style.backgroundColor='#eea2a9'"
                            onmouseup="this.style.backgroundColor='#f1b0b7'">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
            <iframe id="click-area-iframe" style="width: 100%; border: none; flex: 1;"></iframe>
        </div>
    </div>

    <div id="connection-editor-modal" class="connection-editor-modal">
        <div class="connection-editor-content">
            <div class="modal-header">
                <h2 id="connection-modal-title">Transition Settings</h2>
                <span class="close-button">&times;</span>
            </div>
            
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 18px;">
                <!-- NEW: Transition Type Toggle -->
                <div class="dynamic-field-group" style="flex-direction: column; gap: 8px;">
                    <label style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px; margin-left: 8px; display: none;">TRANSITION TYPE</label>
                    <div id="transition-type-toggle" class="boolean-toggle-container">
                        <div class="boolean-toggle-option" data-value="Transition">Instant</div>
                        <div class="boolean-toggle-option" data-value="Tweened">Interpolated</div>
                    </div>
                </div>
                <!-- NEW: Wrapper for interaction dropdown and target button -->
                <div id="interaction-group-wrapper">
                    <div class="dropdown-group" id="interaction-preset-dropdown-group">
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <label for="interaction-preset-select">TRIGGER INTERACTION</label>
                            <div class="custom-dropdown-container">
                                <div class="custom-dropdown-display" data-target-select="interaction-preset-select"></div>
                                <div class="custom-dropdown-options" id="interaction-preset-options"></div>
                                <select id="interaction-preset-select" style="display: none;"></select>
                            </div>
                         </div>
                            <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
                    </div>
                   <button id="edit-click-area-button" title="Edit Click Area"><i class="fas fa-crosshairs"></i></button>
                 </div>

                
                <div id="dynamic-interaction-fields">
                    <div class="dynamic-field-group" id="loop-count-field" style="display: none; flex-direction: row; align-items: center; justify-content: space-between; margin-top: 0px;">
                        <label for="loop-count-input" style="flex-shrink: 0; font-size: 14px; text-transform: uppercase; color: #555; letter-spacing: 1px;">NUMBER OF LOOPS</label>
                        <input type="number" id="loop-count-input" min="1" value="1" style="width: 100px; margin: auto 0;">
                    </div>
                    <!-- The "Change Target Area" button has been moved -->
                    <div class="dynamic-field-group" id="custom-event-name-field" style="display: none; flex-direction: row; align-items: center; gap: 10px; margin-top: 15px;">
                        <label for="custom-event-name-input" style="margin-bottom: 0; flex-shrink: 0;">Custom Event Name:</label>
                        <input type="text" id="custom-event-name-input" placeholder="e.g., user_action_event" style="width: auto; flex-grow: 1;">
                    </div>
                    <!-- Tweened Transition Fields (Moved here) -->
                    <div class="dynamic-field-group" id="tweened-duration-field" style="display: none; margin-top: 0px; flex-direction: row; align-items: center; gap: 10px;">
                        <label for="tweened-duration-input" style="margin-left: 10px; flex-shrink: 0;">DURATION</label>
                        <input type="number" id="tweened-duration-input" min="0" step="0.1" value="0.5" style="width: 100px; margin: auto 0;">
                    </div>
                    <div class="dynamic-field-group" id="tweened-easing-field" style="display: none; flex-direction: row; align-items: center; gap: 62px; margin-top: 0px;">
                        <label for="tweened-easing-input" style="margin-left: 10px; flex-shrink: 0;">EASING</label>
                        <div style="position: relative; flex-grow: 1; display: flex; align-items: center;">
                            <input type="text" id="tweened-easing-input" placeholder="e.g., 0.42, 0, 0.58, 1" style="width: 100%; margin: 0; padding-right: 130px; box-sizing: border-box;">
                            <div class="dropdown-group" id="easing-preset-dropdown-group" style="width: 100px; position: absolute; right: 0; top: 0; height: 30px; margin: 3px; padding: 0 12px; border: none; background: #e6f6ff; align-items: center;">
                                <div class="custom-dropdown-container" style="width: 120px;">
                                    <div class="custom-dropdown-display" id="easing-preset-display" style="font-size: 12px; padding-right: 4px; padding-bottom: 1px;">linear</div>
                                    <div class="custom-dropdown-options" id="easing-preset-options" style="width: 150px; right: -32px; left: auto;">
                                        <div class="custom-dropdown-option" data-value="[0.42, 0, 1, 1]">ease-in</div>
                                        <div class="custom-dropdown-option" data-value="[0, 0, 0.58, 1]">ease-out</div>
                                        <div class="custom-dropdown-option" data-value="[0.42, 0, 0.58, 1]">ease-in-out</div>
                                        <div class="custom-dropdown-option" data-value="[0, 0, 1, 1]">linear</div>
                                        <div class="custom-dropdown-option" data-value="custom">custom</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-down dropdown-indicator" style="margin-left: 0px;"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- NEW: Actions Section -->
                <div id="actions-section" style="display: none; overflow-y: auto; max-height: 420px;">
                    <div class="separator-with-text">
                        <div class="separator-line"></div>
                        <span class="separator-pill">Actions on Transition</span>
                    
                        <div class="separator-line"></div>
                    </div>

                    <!-- This div will hold the list of action editor rows -->
                    <div id="transition-actions-list" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Action rows will be dynamically added here by JavaScript -->
                    </div>

                    <!-- Button to add a new action -->
                    <button id="add-transition-action-button" class="full-width-pill-button" style="margin-top: 15px; background-color: #e7f3ff; color: #4a90e2; border-color: #d1e7ff;">
                        <i class="fas fa-plus" style="margin-right: 8px;"></i>
                        Add Action
                    </button>

                    <div id="transition-url-section" style="display: none; margin-top: 20px;">
                       
                        <div class="dynamic-field-group" style="flex-direction: column; gap: 8px;">
                        <div class="combined-input-group" style="margin-top: 0px;">
                            <div class="dropdown-group" style="flex: 1; margin: 0; border: none; background: transparent; align-items: stretch; padding-top: 12px; padding-bottom: 12px;">
                                <div style="display: flex; flex-direction: column; gap: 0.3rem; flex: 1;">
                                    <label for="transition-url-input" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">URL TO OPEN</label>
                                    <div style="display:flex; align-items: center; gap: 10px; margin-top: 4px; padding-left: 2px;">
                                        <i class="fas fa-link" style="color: #888; font-size: 14px; margin-right: 0px; margin-left: -12px; padding-left: 10px;"></i>
                                        <input type="text" id="transition-url-input" placeholder="https://example.com" style=" width: 100%; border: none; background: transparent; font-size: 16px; margin: 0; padding: 0; margin-left: 2px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p style="font-size: 13px; color: #777; margin-left: 10px; margin-top: 8px;">If a URL is set, it will be opened when this transition is triggered.</p>
                    </div>
                    </div>

                                    </div>

                                    

            </div>
        
            <div class="modal-footer">
                <button id="delete-connection-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                <div>
                    <button id="save-connection-editor" class="save"><i class="fas fa-check"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Modal for State Machine Player -->
    <div id="state-machine-player-modal" class="modal" style="z-index: 1004;">
        <!-- --- MODIFIED: The modal-content is now the window itself --- -->
        <div class="modal-content" style="width: 95%; height: 95vh; max-width: 1000px;">
            <!-- --- NEW: Title bar with window controls --- -->
            <div id="player-title-bar">
                <span class="title">State Machine Player</span>
                <div class="window-controls">
                    <button id="share-player-json-button" title="Share player JSON" style="cursor: pointer; background-color: #e0f2f7; color: #0369a1; border-radius: 999px; padding: 4px 12px; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 6px; border: 1px solid #a7d9ed;">
                        <i class="fas fa-share-alt"></i>
                        <span>Share</span>
                    </button>

                    <!-- NEW: Pill-shaped download button -->
                    <button id="download-player-lottie-button" title="Download as .lottie file" style="cursor: pointer; background-color: #e0f2f7; color: #0369a1; border-radius: 999px; padding: 4px 12px; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 6px; border: 1px solid #a7d9ed;">
                        <i class="fas fa-download"></i>
                        <span>Download</span>
                    </button>
                    <!-- END NEW -->

                    <button id="close-state-machine-player-button" class="window-control-btn" style="background-color: #ff5f57;" title="Close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <iframe id="state-machine-player-iframe" style="width: 100%; border: none; flex: 1;"></iframe>
        </div>
    </div>

    <!-- NEW: Guard Condition Editor Modal -->
    <div id="guard-condition-modal" class="connection-editor-modal">
        <div class="connection-editor-content">
            <div class="modal-header">
                <h2>Transition Settings</h2>
                <span class="close-button">&times;</span>
            </div>

            <div class="modal-body" style="display: flex; flex-direction: column; gap: 10px;">
                <div class="dynamic-field-group" style="flex-direction: column; gap: 8px;">
                <label style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px; margin-left: 8px; display: none;">TRANSITION TYPE</label>
                <div id="guard-transition-type-toggle" class="boolean-toggle-container">
                    <div class="boolean-toggle-option" data-value="Transition">Instant</div>
                    <div class="boolean-toggle-option" data-value="Tweened">Interpolated</div>
                </div>
            </div>

            <div class="combined-input-group">
                    <div class="dropdown-group" id="guard-condition-type-dropdown-group" style="flex: 3.5; margin-bottom: 0; margin-top: 0; border: none; background: transparent;">
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <label for="guard-condition-type-select" id="guard-condition-label" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">CONDITION</label>
                            <div class="custom-dropdown-container">
                                <div class="custom-dropdown-display" data-target-select="guard-condition-type-select"></div>
                                <div class="custom-dropdown-options" id="guard-condition-type-options"></div>
                                <select id="guard-condition-type-select" style="display: none;"></select>
                            </div>
                        </div>
                        <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto 1rem auto auto;"></i>
                    </div>
                    <div class="combined-input-separator"></div>
                    <!-- NEW: Container for the numeric input with steppers -->
                       <div id="guard-numeric-value-container" style="display: none; align-items: center; justify-content: center; flex: 2.2; gap: 12px; padding: 0 16px;">
                        <button id="decrement-guard-value" style="background-color: #e9ecef; border: none; font-size: 18px; font-weight: 600; color: #495057; cursor: pointer; width: 28px; height: 28px; border-radius: 50%; transition: background-color 0.2s, transform 0.1s;" onmouseover="this.style.backgroundColor='#dee2e6'" onmouseout="this.style.backgroundColor='#e9ecef'" onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">-</button>
                        <input type="number" id="guard-value-input" placeholder="Value" style="text-align: center; flex-grow: 1; border: none; background: transparent; font-size: 16px; margin: 0; -moz-appearance: textfield; width: 40px;">
                      <button id="increment-guard-value" style="background-color: #e9ecef; border: none; font-size: 18px; font-weight: 600; color: #495057; cursor: pointer; width: 28px; height: 28px; border-radius: 50%; transition: background-color 0.2s, transform 0.1s;" onmouseover="this.style.backgroundColor='#dee2e6'" onmouseout="this.style.backgroundColor='#e9ecef'" onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">+</button>
                        <style>
                            #guard-value-input::-webkit-outer-spin-button, #guard-value-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
                        </style>
                    </div>
                    <!-- END NEW -->
                    <!-- Dedicated UI for Boolean -->
                    <div id="guard-boolean-value-container" style="display: none; align-items: center; justify-content: center; flex: 1; padding: 10px 16px; font-size: 16px; position: relative;">
                        <span id="guard-boolean-value-display" style="font-weight: bold; font-size: 16px; color: #333;"></span>
                        <button id="guard-boolean-value-toggle" style="background: none; border: none; cursor: pointer; margin-left: 12px; font-size: 16px; color: #555; padding: 5px;" title="Toggle value">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>


            <div id="guard-dynamic-fields" style="gap: 16px; display: flex; flex-direction: column;">
                <!-- Tweened fields will be dynamically added here by JS -->
            </div>
            </div>
            <!-- NEW: Transition Type Toggle for Guards -->
            
            <div class="modal-footer">
                <button id="delete-guard-connection-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                <button id="save-guard-condition" class="save"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>
    <!-- NEW: Moved preview toggle button to be a direct child of app-container -->
    

  </div> <!-- End of #main-wrapper -->

  <div id="share-tutorial-modal" class="modal" style="z-index: 1005;">
        <div class="modal-content" style="max-width: 550px; padding: 0; border-radius: 24px; overflow: hidden; gap: 0; background-color: #f8f9fa;">
            <!-- Modal Header -->
            <div class="modal-header" style="padding: 20px 28px; margin-bottom: 0; border-bottom: 1px solid #e0e0e0; background-color: #ffffff; margin-left: 0;">
                <h2 style="font-size: 22px; font-weight: 700; color: #333;">Generate Your Shareable Code</h2>
                <span class="close-button" id="close-share-modal-button" style="padding-bottom: 0;">&times;</span>
            </div>
            
            <!-- Modal Body with Steps -->
            <div class="modal-body" style="padding: 28px; display: flex; flex-direction: column; gap: 24px;">
                
                <!-- Step 1: Copy Data -->
                <div class="share-step">
                    <div class="share-step-header">
                        <span class="share-step-number">1</span>
                        <h3 class="share-step-title">Copy data</h3>
                    </div>
                    <p class="share-step-desc">Click the button to copy the necessary player data to your clipboard.</p>
                    <button id="share-modal-copy-button" class="share-modal-button secondary">
                        <i class="fas fa-copy"></i>
                        <span>Copy Data</span>
                    </button>
                </div>

                <!-- Step 2: Go to Website -->
                <div class="share-step">
                    <div class="share-step-header">
                        <span class="share-step-number">2</span>
                        <h3 class="share-step-title">Go to jsonkeeper.com</h3>
                    </div>
                    <p class="share-step-desc">Paste the data on the website to get a link, then come back.</p>
                    <a href="https://jsonkeeper.com/" target="_blank" class="share-modal-link">
                        https://jsonkeeper.com
                        <i class="fas fa-external-link-alt" style="font-size: 12px; margin-left: 6px;"></i>
                    </a>
                </div>

                <!-- Step 3: Paste Link -->
                <div class="share-step">
                    <div class="share-step-header">
                        <span class="share-step-number">3</span>
                        <h3 class="share-step-title">Paste the link here</h3>
                    </div>
                    <p class="share-step-desc">Paste the link from jsonkeeper.com into the field below.</p>
                    <div class="share-input-wrapper">
                        <i class="fas fa-link"></i>
                        <input type="text" id="share-modal-link-input" placeholder="Paste your link here">
                    </div>
                </div>

            </div>

            <!-- Modal Footer -->
            <div class="modal-footer" style="padding: 20px 28px; border-top: 1px solid #e0e0e0; background-color: #ffffff; justify-content: flex-end;">
                <!-- Generate Button (changes to result) -->
                <div id="share-modal-generate-container" style="width: 100%;">
                    <button id="share-modal-generate-button" class="share-modal-button primary" style="width: 100%;">
                        <span>Generate Code</span>
                        <div class="button-loader" style="display: none;"></div>
                    </button>
                </div>
                
                <!-- Result Container (hidden by default) -->
                <div id="share-modal-result-container" style="display: none; width: 100%; text-align: left;">
                    <p style="font-weight: 600; color: #333; margin: 0 0 10px 0;">Your shareable link is ready:</p>
                    <div style="display: flex; align-items: center; gap: 10px; background-color: #f0fdf4; border: 1px solid #c3e6cb; border-radius: 12px; padding: 4px 4px 4px 14px;">
                        <i class="fas fa-link" style="color: #155724; font-size: 14px;"></i>
                        <input type="text" id="share-modal-final-link" readonly 
                               style="flex-grow: 1; border: none; outline: none; background: none; font-size: 14px; color: #155724; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <button id="share-modal-copy-final-link-button" 
                                class="share-modal-button" 
                                style="background-color: #28a745; color: white; border-radius: 8px; padding: 8px 16px; flex-shrink: 0;">
                            <i class="fas fa-copy"></i>
                            <span>Copy</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Hidden textarea for reliable copying -->
    <textarea id="hidden-copy-textarea" style="position: absolute; left: -9999px; top: 0; opacity: 0;"></textarea>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // --- State Machine Converter Library ---
        // This code is now embedded directly in the HTML to prevent loading errors.
        
        // -- SECTION 1: EXPORT LOGIC (UI Data -> New JSON Schema) --
        
        /**
         * A collection of helper functions to ensure Inputs and Interactions exist, preventing duplicates.
         */

        /**
         * Checks if a URL matches the jsonkeeper.com format.
         * @param {string} url - The URL to validate.
         * @retursssns {boolean} - True if the URL is a valid jsonkeeper link.
         */
        function isValidJsonKeeperLink(url) {
            // MODIFIED: Made the 'www.' part optional to match links like https://jsonkeeper.com/b/ID
            const jsonKeeperRegex = /^https:\/\/(www\.)?jsonkeeper\.com\/b\/[A-Z0-9]{4,}$/;
            return jsonKeeperRegex.test(url);
        }

        /**
         * Fetches a URL and checks if it contains valid state machine JSON.
         * @param {string} url - The URL to fetch.
         * @returns {Promise<boolean>} - True if the content is valid JSON with 'initial' and 'states' keys.
         */
      async function isValidJsonContent(url) {
            console.log(`[Validation] Fetching URL: ${url}`);
            try {
                // We will use this single proxy.
                const proxyUrl = `https://api.codetabs.com/v1/proxy/?quest=${encodeURIComponent(url)}`;
                
                console.log(`[Validation] Attempting fetch via proxy: ${proxyUrl}`);
                
                // This is the *only* declaration of 'response' in this block.
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    console.error(`[Validation] Proxy fetch failed with status: ${response.status}`);
                    try {
                        const errorText = await response.text();
                        console.error(`[Validation] Error details: ${errorText}`);
                    } catch (e) {
                        console.error(`[Validation] Could not read error response body: ${e}`);
                    }
                    return false;
                }
                
                const text = await response.text();
                console.log(`[Validation] Received content (first 200 chars): ${text.substring(0, 200)}...`);

                const data = JSON.parse(text);

                // This is the new validation logic checking for your 3 required keys.
                // Note: I corrected "stateMahhine" to "stateMachine"
                if (data && data.animation && data.stateMachine && data.layout) {
                    console.log("[Validation] JSON content is valid. Found 'animation', 'stateMachine', and 'layout' keys.");
                    return true;
                } else {
                    console.warn("[Validation] JSON content is missing required keys ('animation', 'stateMachine', 'layout').");
                    return false;
                }
            } catch (error) {
                console.error("[Validation] Error fetching or parsing JSON:", error);
                if (error instanceof SyntaxError) {
                    console.error("[Validation] The fetched content was not valid JSON.");
                }
                return false;
            }
        }




         const ensure = {
             eventInputExists: (eventName, globalInputs) => {
                if (!globalInputs.some(input => input.name === eventName)) {
                    globalInputs.push({ type: 'Event', name: eventName });
                }
             },
             interactionExists: (type, eventName, details, actions, globalInteractions) => {
                // NEW: Check for actions as well for uniqueness
                const actionsString = JSON.stringify(actions.sort((a, b) => a.type.localeCompare(b.type)));

                 const interactionExists = globalInteractions.some(i =>
                     i.type === type &&
                     // Check if at least one action is a 'Fire' action with the correct eventName
                     i.actions?.some(a => a.type === 'Fire' && a.inputName === eventName) &&
                     (details.layerName === undefined || i.layerName === details.layerName) &&
                     (details.stateName === undefined || i.stateName === details.stateName) &&
                     // Compare actions
                     JSON.stringify(i.actions.sort((a, b) => a.type.localeCompare(b.type))) === actionsString
                 );

                 if (!interactionExists) {
                     globalInteractions.push({
                         type: type,
                         ...details,
                         actions: actions
                     });
                 }
             }
         };




         



        

         /**
             * Renders a single action editor row from a template and appends it to a container.
             * @param {object} actionObject - The action data object { type, value, variableId }.
             * @param {HTMLElement} container - The DOM element to append the new row to.
             */
            function renderActionRow(actionObject, container) {
                if (!globalState || !actionObject) return;

                const template = document.getElementById('action-row-template').content.cloneNode(true);
                const actionRow = template.querySelector('.action-editor-row');
                
                // Store the data directly on the element for easy access later
                actionRow.dataset.action = JSON.stringify(actionObject);

                // --- 1. Populate Target Variable Dropdown ---
                const variableDropdownContainer = actionRow.querySelector('.action-variable-dropdown-group');
                variableDropdownContainer.innerHTML = `
                    <label>TARGET VARIABLE</label>
                    <div class="custom-dropdown-container">...</div>
                `; // Simplified for brevity - populate using your existing populateDropdowns logic
                // ... (code to populate variable dropdown, selecting actionObject.variableId) ...


                // --- 2. Populate Action Type Dropdown ---
                const typeDropdownContainer = actionRow.querySelector('.action-type-dropdown-group');
                // ... (code to populate action type dropdown based on selected variable's type, selecting actionObject.type) ...


                // --- 3. Populate Value Field ---
                const valueField = actionRow.querySelector('.action-value-field');
                updateActionValueField(actionObject.type, actionObject.value, valueField);


                // --- 4. Add Event Listeners ---
                const deleteButton = actionRow.querySelector('.delete-action-button');
                deleteButton.addEventListener('click', () => {
                    actionRow.remove();
                    // IMPORTANT: Trigger a save immediately after deleting an action
                    // You would call a function here like `saveActionsForCurrentModal()`
                });

                // ... (Add 'change' and 'input' listeners for the dropdowns and value fields) ...
                // These listeners should also trigger an immediate save.

                container.appendChild(template);
            }



        // --- NEW: Moved this function up to be accessible by the import function ---
        function generateId() { 
            return 'id_' + Math.random().toString(36).substr(2, 9); 
        }

         /**
          * Builds the array of Guards for a given transition based on the UI's simple trigger.
          */
        function buildGuardsForTransition(connection, globalInputs, globalInteractions, nodeIdToNameMap, globalState, nodes) {
                        // --- (This part is unchanged) ---
                        const fromNode = nodes.find(n => n.id === connection.fromNodeId);
                        const playInReverse = fromNode?.playInReverse || false;

                        const fromStateName = nodeIdToNameMap.get(connection.fromNodeId);
                        const interactionType = connection.interactionType;
                        let eventName, interactionSchemaType, details;

                        switch (interactionType) {
                            case 'onPointerEnter':
                            case 'onPointerExit':
                            case 'onPointerDown':
                            case 'onPointerUp':
                            case 'onPointerMove':
                            case 'onClick':
                                const toNodeOnClick = nodes.find(n => n.id === connection.toNodeId);
                                const toStateName = toNodeOnClick ? toNodeOnClick.name : 'unknown';
                                const interactionName = interactionType.replace('on', '').toLowerCase();
                                const layerName = `${fromStateName}_${interactionName}_to_${toStateName}`;

                                interactionSchemaType = interactionType === 'onClick' ? 'Click' : interactionType.charAt(2).toUpperCase() + interactionType.slice(3);
                                details = { layerName: layerName };
                                if (toNodeOnClick && toNodeOnClick.type === 'action') {
                                    eventName = null;
                                } else {
                                    eventName = `${interactionType}_${layerName}_Event`;
                                }
                                break;
                            case 'onComplete':
                                interactionSchemaType = 'OnComplete';
                                details = { stateName: fromStateName, ...(playInReverse && { mode: 'Reverse' }) };
                                eventName = `${interactionType}_${fromStateName}_Event`;
                                break;
                            case 'onLoopComplete':
                                // --- MODIFICATION: Was 'OnComplete', changed to 'OnLoopComplete' ---
                                interactionSchemaType = 'OnLoopComplete'; 
                                details = { stateName: fromStateName, ...(playInReverse && { mode: 'Reverse' }) };
                                const toNode = nodes.find(n => n.id === connection.toNodeId);
                                if (toNode && toNode.type === 'action') {
                                    eventName = null;
                                } else {
                                    // --- MODIFICATION: Use correct eventName for loops ---
                                    eventName = `onLoopComplete_${fromStateName}_Event`;
                                }
                                break;
                            default:
                                return [];
                        }

                        // --- (This section is the core of the update) ---

                        // This 'actions' array is for the final exported 'interaction' object.
                        // It will contain the state transition trigger ('Fire') plus all user-defined actions.
                        const actions = [];
                        if (eventName) {
                            actions.push({ type: 'Fire', inputName: eventName });
                        }

                        // Find the source of the user-defined actions. It could be on the connection
                        // itself or from a destination Action Node.
                        let sourceOfActions = null;
                        const toNode = nodes.find(n => n.id === connection.toNodeId);
                        if (toNode && toNode.type === 'action' && toNode.action) {
                            sourceOfActions = toNode.action;
                        } else if (connection.action) {
                            sourceOfActions = connection.action;
                        }

                        // Ensure `actionsToPerform` is always an array for consistent processing.
                        let actionsToPerform = [];
                        if (sourceOfActions) {
                            if (Array.isArray(sourceOfActions)) {
                                actionsToPerform = sourceOfActions;
                            } else {
                                // BACKWARD COMPATIBILITY: If the action is a single object (from an older save),
                                // wrap it in an array so the loop below still works.
                                actionsToPerform = [sourceOfActions];
                            }
                        }

                        // Now, loop through the array of actions and add them to the exported 'actions' list.
                        if (actionsToPerform.length > 0 && globalState && globalState.inputs.length > 0) {
                            actionsToPerform.forEach(actionObject => {
                                // --- START MODIFICATION ---
                                // Safety check for malformed action objects OR "No action" types
                                if (!actionObject || !actionObject.type || actionObject.type === 'No action' || actionObject.type === '') {
                                    return; // Skip this action
                                }
                                // --- END MODIFICATION ---

                                // Find the target variable using the stored ID.
                                // Fallback to the first variable if variableId is missing (for older saves).
                                const targetVariable = globalState.inputs.find(v => v.id === actionObject.variableId)
                                                    || globalState.inputs[0];

                                if (targetVariable) {
                                    // Create the action object for the JSON export, using the variable's NAME.
                                    let exportedAction = { type: actionObject.type, inputName: targetVariable.name };
                                    
                                    // If the action has a 'value', convert it to the correct type.
                                    if (actionObject.hasOwnProperty('value')) {
                                        // Use the found targetVariable's type for correct value conversion.
                                        if (targetVariable.type === 'Numeric') {
                                            exportedAction.value = parseFloat(actionObject.value) || 0;
                                        } else if (targetVariable.type === 'Boolean') {
                                            exportedAction.value = (actionObject.value === 'true' || actionObject.value === true);
                                        } else {
                                            exportedAction.value = actionObject.value;
                                        }
                                    }
                                    // Add the fully formed action to our list for the interaction.
                                    actions.push(exportedAction);
                                }
                            });
                        }

                        // --- START: MODIFIED BLOCK ---
                        // Check if the destination is an Action Node and has a URL action
                        if (toNode && toNode.type === 'action' && toNode.openUrlAction && toNode.openUrlAction.url) {
                            actions.push({
                                type: 'OpenUrl',
                                url: toNode.openUrlAction.url,
                                target: toNode.openUrlAction.target || '_blank'
                            });
                        }
                        // --- NEW: Check if the connection ITSELF has a URL action ---
                        else if (connection.openUrlAction && connection.openUrlAction.url) {
                            actions.push({
                                type: 'OpenUrl',
                                url: connection.openUrlAction.url,
                                target: connection.openUrlAction.target || '_blank'
                            });
                        }
                        // --- END: MODIFIED BLOCK ---


                        // --- (This part is unchanged) ---

                        // Ensure the event input and the interaction exist in the global lists.
                        // The 'actions' array we just built is passed to ensure.interactionExists.
                        if (eventName) {
                            ensure.eventInputExists(eventName, globalInputs);
                        }
                        ensure.interactionExists(interactionSchemaType, eventName, details, actions, globalInteractions);

                        // Return the guard that listens for our unique event to trigger the state transition.
                        // --- MODIFICATION: Return an empty array if toNode is an action node ---
                        if (toNode && toNode.type === 'action') {
                            return [];
                        }
                        // --- END MODIFICATION ---
                        return [{ type: 'Event', inputName: eventName }];
                    }
        /**
         * EXPORT FUNCTION: Converts UI data into the new, advanced state machine JSON.
         
                function convertNodesAndConnectionsToJson(nodes, connections, initialNodeName, globalState, guardConnections) {
                    const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
                    const globalInputs = [];
                    
                    let isGlobalStateUsedInAction = connections.some(conn => conn.action && conn.action.type) ||
                                                    nodes.some(node => node.type === 'action' && node.action && node.action.type);
                    let isGlobalStateUsedInGuard = guardConnections && guardConnections.length > 0;

                    const stateMachineInteractions = [];

                    // 1. Create Inputs from the globalState node's 'inputs' array
                    if (globalState && globalState.inputs && globalState.inputs.length > 0) {
                        globalState.inputs.forEach(inputVar => {
                            let jsonValue;
                            if (inputVar.type === 'Numeric') {
                                jsonValue = parseFloat(inputVar.initialValue) || 0;
                            } else if (inputVar.type === 'Boolean') {
                                jsonValue = (inputVar.initialValue === 'true' || inputVar.initialValue === true);
                            } else {
                                jsonValue = inputVar.initialValue;
                            }
                            globalInputs.push({
                                type: inputVar.type,
                                name: inputVar.name,
                                value: jsonValue,
                            });
                        });
                    } else {
                        isGlobalStateUsedInAction = false;
                        isGlobalStateUsedInGuard = false;
                    }

                    const statesArray = nodes.filter(node => node.type !== 'action').map(node => {
                        const isLoopANumber = typeof node.loop === 'number' && node.loop > 0;
                        const transitionsForThisNode = connections.filter(c => c.fromNodeId === node.id);
                        return {
                            name: node.name,
                            type: "PlaybackState",
                            animation: node.animationId,
                            loop: node.loop === true || isLoopANumber,
                            ...(isLoopANumber && { loopCount: node.loop }),
                            ...(node.playInReverse && { mode: "Reverse" }),
                            speed: node.speed,
                            designer: {
                                x: node.x,
                                y: node.y
                            },
                            segment: node.marker || undefined,
                            autoplay: node.autoplay,
                            transitions: transitionsForThisNode.map(conn => {
                                const guards = buildGuardsForTransition(conn, globalInputs, stateMachineInteractions, nodeIdToNameMap, globalState, nodes);
                                const toNode = nodes.find(n => n.id === conn.toNodeId);
                                if (toNode && toNode.type === 'action') {
                                    return null;
                                }
                                if (conn.transitionType === 'Tweened') {
                                    return {
                                        type: "Tweened",
                                        toState: nodeIdToNameMap.get(conn.toNodeId),
                                        duration: conn.duration || 0.5,
                                        easing: conn.easing || [0, 0, 1, 1],
                                        guards: guards
                                    };
                                }
                                return {
                                    type: "Transition",
                                    toState: nodeIdToNameMap.get(conn.toNodeId),
                                    guards: guards
                                };
                            }).filter(t => t !== null),
                            entryActions: [],
                            exitActions: [],
                        };
                    });

                    // Conditionally add the GlobalState object to the statesArray
                    if (globalState && (isGlobalStateUsedInAction || isGlobalStateUsedInGuard)) {
                        statesArray.push({
                            name: globalState.name,
                            type: "GlobalState",
                            designer: {
                                x: globalState.x,
                                y: globalState.y
                            },
                            // ================================================================= //
                            // START OF REPLACEMENT LOGIC FOR GUARD CONNECTIONS                  //
                            // ================================================================= //
                            transitions: guardConnections.map(gc => {
                                // For each connection, map its 'conditions' array to a 'guards' array.
                                const guards = gc.conditions.map(condition => {
                                    // Find the variable details using the stored variableId.
                                // --- NEW: If the condition is 'None', skip it ---
                                if (condition.condition === 'None') {
                                    return null;
                                }
                                // --- END NEW ---

                                    const variable = globalState.inputs.find(v => v.id === condition.variableId);
                                    if (!variable) return null; // Safety check in case variable was deleted

                                    // Convert the value to the correct type for the JSON schema.
                                    let compareToValue = condition.value;
                                    if (variable.type === 'Numeric') {
                                    // --- FIX: Use parseFloat on condition.value ---
                                    compareToValue = parseFloat(condition.value) || 0;
                                    } else if (variable.type === 'Boolean') {
                                        compareToValue = (condition.value === 'true' || condition.value === true);
                                    }

                                    // Return the schema-compliant guard object.
                                    return {
                                        type: variable.type,
                                        inputName: variable.name,
                                        conditionType: condition.condition,
                                        compareTo: compareToValue,
                                    };
                                }).filter(Boolean); // Filter out any nulls if a variable wasn't found.
 
                                // Return the final transition object.
                                if (gc.transitionType === 'Tweened') {
                                    return {
                                        type: "Tweened",
                                        toState: nodeIdToNameMap.get(gc.toNodeId),
                                        duration: gc.duration || 0.5,
                                        easing: gc.easing || [0.42, 0, 0.58, 1],
                                        guards: guards // Use the newly created guards array.
                                    };
                                }
                                return {
                                    type: "Transition",
                                    toState: nodeIdToNameMap.get(gc.toNodeId),
                                    guards: guards // Use the newly created guards array.
                                };
                            })
                            // ================================================================= //
                            // END OF REPLACEMENT LOGIC                                          //
                            // ================================================================= //
                        });
                    }

                    const actionNodesArray = nodes.filter(node => node.type === 'action').map(actionNode => {
                        const incomingConnection = connections.find(conn => conn.toNodeId === actionNode.id);
                        if (!incomingConnection) return null;

                        const fromStateName = nodeIdToNameMap.get(incomingConnection.fromNodeId);

                        // --- START FIX: Convert internal action format to export format ---
                        let convertedActions = [];
                        // Ensure `actionNode.action` is an array for consistent processing.
                        const actionsToPerform = (Array.isArray(actionNode.action) ? actionNode.action : [actionNode.action]).filter(Boolean);

                        if (actionsToPerform.length > 0 && globalState && globalState.inputs.length > 0) {
                            actionsToPerform.forEach(actionObject => {
                                // Safety check for malformed or old data
                                if (!actionObject || !actionObject.type || !actionObject.variableId) {
                                    console.warn(`[Export] Skipping malformed action in Action Node "${actionNode.name}":`, actionObject);
                                    return;
                                }

                                // Find the target variable using the stored ID.
                                const targetVariable = globalState.inputs.find(v => v.id === actionObject.variableId);

                                if (targetVariable) {
                                    // Create the action object for the JSON export, using the variable's NAME.
                                    let exportedAction = { type: actionObject.type, inputName: targetVariable.name };
                                    
                                    // If the action has a 'value', convert it to the correct type.
                                    if (actionObject.hasOwnProperty('value')) {
                                        // Use the found targetVariable's type for correct value conversion.
                                        if (targetVariable.type === 'Numeric') {
                                            exportedAction.value = parseFloat(actionObject.value) || 0;
                                        } else if (targetVariable.type === 'Boolean') {
                                            exportedAction.value = (actionObject.value === 'true' || actionObject.value === true);
                                        } else {
                                            exportedAction.value = actionObject.value;
                                        }
                                    }
                                    // Add the fully formed action to our list for the interaction.
                                    convertedActions.push(exportedAction);
                                } else {
                                     console.warn(`[Export] Action Node "${actionNode.name}" references a missing variableId "${actionObject.variableId}". Action skipped.`);
                                }
                            });
                        }
                        // --- END FIX ---

                        return {
                            name: actionNode.name,
                            designer: {
                                x: actionNode.x,
                                y: actionNode.y
                            },
                            action: convertedActions, // <-- Use the new converted array
                            trigger: {
                                fromState: fromStateName,
                                interactionType: incomingConnection.interactionType,
                                interactionDetails: incomingConnection.interactionDetails
                            }
                        };
                    }).filter(Boolean);
                    return {
                        initial: initialNodeName,
                        inputs: globalInputs,
                        states: statesArray,
                        actionNodes: actionNodesArray,
                        interactions: stateMachineInteractions,
                    };
                }
        */
        


        /**
 * EXPORT FUNCTION: Converts UI data into the new, advanced state machine JSON.
 */
               function convertNodesAndConnectionsToJson(nodes, connections, initialNodeName, globalState, guardConnections) {
    const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
    const globalInputs = [];
    
    // This logic is no longer needed to decide if the node itself is exported
    // let isGlobalStateUsedInAction = connections.some(conn => conn.action && conn.action.type) ||
    //                                 nodes.some(node => node.type === 'action' && ( (node.action && node.action.length > 0) || node.openUrlAction) );
    // let isGlobalStateUsedInGuard = guardConnections && guardConnections.length > 0;

    const stateMachineInteractions = [];

    // 1. Create Inputs from the globalState node's 'inputs' array
    if (globalState && globalState.inputs && globalState.inputs.length > 0) {
        globalState.inputs.forEach(inputVar => {
            let jsonValue;
            if (inputVar.type === 'Numeric') {
                jsonValue = parseFloat(inputVar.initialValue) || 0;
            } else if (inputVar.type === 'Boolean') {
                jsonValue = (inputVar.initialValue === 'true' || inputVar.initialValue === true);
            } else {
                jsonValue = inputVar.initialValue;
            }
            globalInputs.push({
                type: inputVar.type,
                name: inputVar.name,
                value: jsonValue,
            });
        });
    }

    const statesArray = nodes.filter(node => node.type !== 'action').map(node => {
        const isLoopANumber = typeof node.loop === 'number' && node.loop > 0;
        const transitionsForThisNode = connections.filter(c => c.fromNodeId === node.id);
        return {
            name: node.name,
            type: "PlaybackState",
            animation: node.animationId,
            loop: node.loop === true || isLoopANumber,
            ...(isLoopANumber && { loopCount: node.loop }),
            ...(node.playInReverse && { mode: "Reverse" }),
            speed: node.speed,
            designer: {
                x: node.x,
                y: node.y
            },
            segment: node.marker || undefined,
            autoplay: node.autoplay,
            transitions: transitionsForThisNode.map(conn => {
                const guards = buildGuardsForTransition(conn, globalInputs, stateMachineInteractions, nodeIdToNameMap, globalState, nodes);
                const toNode = nodes.find(n => n.id === conn.toNodeId);
                if (toNode && toNode.type === 'action') {
                    return null;
                }
                const designerData = {
                    fromPort: conn.fromPortType,
                    toPort: conn.toPortType,
                    forceCShape: conn.forceCShape
                };
                if (conn.transitionType === 'Tweened') {
                    return {
                        type: "Tweened",
                        toState: nodeIdToNameMap.get(conn.toNodeId),
                        duration: conn.duration || 0.5,
                        easing: conn.easing || [0, 0, 1, 1],
                        guards: guards,
                        designer: designerData
                    };
                }
                return {
                    type: "Transition",
                    toState: nodeIdToNameMap.get(conn.toNodeId),
                    guards: guards,
                    designer: designerData
                };
            }).filter(t => t !== null),
            entryActions: [],
            exitActions: [],
        };
    });

    // --- START: MODIFIED BLOCK ---
    // Conditionally add the GlobalState object to the statesArray
    // The check is now simple: if the globalState object exists in our editor,
    // we must export it and its position.
    if (globalState) {
        statesArray.push({
            name: globalState.name,
            type: "GlobalState",
            designer: {
                x: globalState.x,
                y: globalState.y
            },
            transitions: guardConnections.map(gc => {
                const guards = gc.conditions.map(condition => {
                    if (condition.condition === 'None') {
                        return null;
                    }
                    const variable = globalState.inputs.find(v => v.id === condition.variableId);
                    if (!variable) return null; 

                    let compareToValue = condition.value;
                    if (variable.type === 'Numeric') {
                        compareToValue = parseFloat(condition.value) || 0;
                    } else if (variable.type === 'Boolean') {
                        compareToValue = (condition.value === 'true' || condition.value === true);
                    }
                    return {
                        type: variable.type,
                        inputName: variable.name,
                        conditionType: condition.condition,
                        compareTo: compareToValue,
                    };
                }).filter(Boolean); 

                const designerData = {}; 

                if (gc.transitionType === 'Tweened') {
                    return {
                        type: "Tweened",
                        toState: nodeIdToNameMap.get(gc.toNodeId),
                        duration: gc.duration || 0.5,
                        easing: gc.easing || [0.42, 0, 0.58, 1],
                        guards: guards,
                        designer: designerData
                    };
                }
                return {
                    type: "Transition",
                    toState: nodeIdToNameMap.get(gc.toNodeId),
                    guards: guards,
                    designer: designerData
                };
            })
        });
    }
    // --- END: MODIFIED BLOCK ---

    const actionNodesArray = nodes.filter(node => node.type === 'action').map(actionNode => {
        const incomingConnection = connections.find(conn => conn.toNodeId === actionNode.id);
        if (!incomingConnection) return null;

        const fromStateName = nodeIdToNameMap.get(incomingConnection.fromNodeId);

        let convertedActions = [];
        
        // --- 1. Process Variable-Based Actions ---
        const actionsToPerform = (Array.isArray(actionNode.action) ? actionNode.action : [actionNode.action]).filter(Boolean);
        if (actionsToPerform.length > 0 && globalState && globalState.inputs.length > 0) {
            actionsToPerform.forEach(actionObject => {
                if (!actionObject || !actionObject.type || actionObject.type === 'No action' || actionObject.type === '' || !actionObject.variableId) {
                    return; 
                }
                const targetVariable = globalState.inputs.find(v => v.id === actionObject.variableId);
                if (targetVariable) {
                    let exportedAction = { type: actionObject.type, inputName: targetVariable.name };
                    if (actionObject.hasOwnProperty('value')) {
                        if (targetVariable.type === 'Numeric') {
                            exportedAction.value = parseFloat(actionObject.value) || 0;
                        } else if (targetVariable.type === 'Boolean') {
                            exportedAction.value = (actionObject.value === 'true' || actionObject.value === true);
                        } else {
                            exportedAction.value = actionObject.value;
                        }
                    }
                    convertedActions.push(exportedAction);
                } else {
                    console.warn(`[Export] Action Node "${actionNode.name}" references a missing variableId "${actionObject.variableId}". Action skipped.`);
                }
            });
        }

        // --- 2. NEW: Process URL Action ---
        if (actionNode.openUrlAction && actionNode.openUrlAction.url) {
            convertedActions.push({
                type: 'OpenUrl',
                url: actionNode.openUrlAction.url,
                target: actionNode.openUrlAction.target || '_blank' // Default to _blank
            });
        }
        // --- END NEW ---

        return {
            name: actionNode.name,
            designer: {
                x: actionNode.x,
                y: actionNode.y
            },
            action: convertedActions, // This now contains *all* action types
            trigger: {
                fromState: fromStateName,
                interactionType: incomingConnection.interactionType,
                interactionDetails: incomingConnection.interactionDetails
            }
        };
    }).filter(Boolean);

    return {
        initial: initialNodeName,
        inputs: globalInputs,
        states: statesArray,
        actionNodes: actionNodesArray,
        interactions: stateMachineInteractions,
    };
}
                        // -- SECTION 2: IMPORT LOGIC (New JSON Schema -> UI Data) --
        
        /**
         * IMPORT FUNCTION: Converts an advanced state machine JSON into the UI's simple data format.
         
        function convertJsonToNodesAndConnections(jsonStateMachine) {
                            if (!jsonStateMachine.states) return { nodes: [], connections: [], initialNodeId: null, globalState: null, guardConnections: [] };

                            const nodes = [];
                            const connections = [];
                            const stateNameToIdMap = new Map();
                            let globalState = null;
                            const guardConnections = [];

                            // Step 1: Create Global State and all its input variables first.
                            // This is crucial so we have the variable IDs available for the next steps.
                           // Step 1: Create Global State and all its input variables first.
                                if (jsonStateMachine.inputs && jsonStateMachine.inputs.length > 0) {
                                    
                                    // --- START FIX: Filter for user-editable variables FIRST ---
                                    const userVariables = jsonStateMachine.inputs
                                        .filter(input => input.type === 'Numeric' || input.type === 'Boolean')
                                        .map(input => ({
                                            id: `input_${generateId()}`,
                                            name: input.name,
                                            type: input.type,
                                            initialValue: input.value
                                        }));
                                    // --- END FIX ---

                                    // --- START FIX: ONLY create the globalState object if user-editable variables exist ---
                                    if (userVariables.length > 0) {
                                        const globalStateFromStates = jsonStateMachine.states.find(s => s.type === 'GlobalState');
                                        const hasDesignerData = globalStateFromStates && globalStateFromStates.designer;

                                        globalState = {
                                            id: 'global_state_node',
                                            name: globalStateFromStates?.name || 'Global Variables',
                                            x: hasDesignerData ? globalStateFromStates.designer.x : 50,
                                            y: hasDesignerData ? globalStateFromStates.designer.y : 50,
                                            wasImported: true,
                                            inputs: userVariables // Assign the pre-filtered list
                                        };
                                    }
                                    // If no Numeric/Boolean variables exist, globalState remains null, and the node won't be created.
                                    // --- END FIX ---
                                }
                            // Step 2: Create all regular state nodes (PlaybackState)
                            jsonStateMachine.states.forEach((state, index) => {
                                if (state.type === 'GlobalState') return; // Skip GlobalState, we handled it above

                                const nodeId = `id_${Math.random().toString(36).substr(2, 9)}`;
                                stateNameToIdMap.set(state.name, nodeId);

                                const hasDesignerData = state.designer && typeof state.designer.x === 'number' && typeof state.designer.y === 'number';

                                nodes.push({
                                    id: nodeId,
                                    name: state.name,
                                    x: hasDesignerData ? state.designer.x : (50 + (index % 4) * 250),
                                    y: hasDesignerData ? state.designer.y : (50 + Math.floor(index / 4) * 150),
                                    animationId: state.animation,
                                    marker: state.segment || "",
                                    loop: (state.loopCount && state.loopCount > 0) ? state.loopCount : (state.loop || false),
                                    speed: state.speed || 1.0,
                                    autoplay: state.autoplay !== false,
                                    playInReverse: state.mode === "Reverse",
                                    isActive: state.name === jsonStateMachine.initial,
                                    isInitial: state.name === jsonStateMachine.initial,
                                    wasImported: true
                                });
                            });

                            // Step 3: Reverse-engineer connections (regular and guard)
                            jsonStateMachine.states.forEach(state => {
                                if (!state.transitions) return;

                                // ================================================================= //
                                // START OF REPLACEMENT LOGIC FOR IMPORTING CONNECTIONS              //
                                // ================================================================= //

                                // A) Handle Guard Connections (from the GlobalState object)
                                if (state.type === 'GlobalState' && globalState) {
                                    state.transitions.forEach(transition => {
                                        const toNodeId = stateNameToIdMap.get(transition.toState);
                                        if (!toNodeId || !transition.guards || transition.guards.length === 0) return;

                                        // Map the guards from the JSON to our new 'conditions' array structure.
                                        const conditions = transition.guards.map(guard => {
                                            // Find the variable in our UI model by its name to get its ID.
                                            const variable = globalState.inputs.find(v => v.name === guard.inputName);
                                            if (!variable) return null;

                                            return {
                                                variableId: variable.id,
                                                condition: guard.conditionType,
                                                value: guard.compareTo
                                            };
                                        }).filter(Boolean); // Filter out nulls if a variable wasn't found

                                        if (conditions.length > 0) {
                                            guardConnections.push({
                                                id: `guard_${generateId()}`,
                                                fromNodeId: 'global_state_node',
                                                toNodeId: toNodeId,
                                                conditions: conditions, // Use the new conditions array
                                                transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                                                duration: transition.duration,
                                                easing: transition.easing,
                                            });
                                        }
                                    });
                                }
                                // B) Handle Regular Connections (from PlaybackState objects)
                                else if (state.type !== 'GlobalState') {
                                    const fromNodeId = stateNameToIdMap.get(state.name);
                                    state.transitions.forEach(transition => {
                                        const toNodeId = stateNameToIdMap.get(transition.toState);
                                        const eventGuard = transition.guards?.find(g => g.type === 'Event');
                                        if (!eventGuard || !fromNodeId || !toNodeId) return;

                                        const triggeringInteraction = jsonStateMachine.interactions?.find(
                                            i => i.actions?.some(a => a.type === 'Fire' && a.inputName === eventGuard.inputName)
                                        );
                                        if (!triggeringInteraction) return;

                                        let interactionType;
                                            const schemaType = triggeringInteraction.type;

                                            // --- START FIX: Correctly detect 'onLoopComplete' from the event name ---
                                            if (schemaType === 'OnComplete' && eventGuard.inputName.startsWith('onLoopComplete_')) {
                                                // This is the specific trigger for a loop complete event.
                                                interactionType = 'onLoopComplete';
                                            }
                                            // --- END FIX ---
                                            else if (schemaType.startsWith('On')) {
                                                // This is the fallback for all other "On..." events (onComplete, onClick, etc.)
                                                interactionType = 'on' + schemaType.substring(2);
                                            } else {
                                                interactionType = 'on' + schemaType;
                                            }
                                        let actionForConnection = null;
                                        if (globalState) {
                                            const stateChangeAction = triggeringInteraction.actions?.find(
                                                a => globalState.inputs.some(v => v.name === a.inputName) && a.type !== 'Fire'
                                            );
                                            if (stateChangeAction) {
                                                actionForConnection = {
                                                    type: stateChangeAction.type,
                                                    value: stateChangeAction.value,
                                                };
                                            }
                                        }

                                        connections.push({
                                            id: `conn_${generateId()}`,
                                            fromNodeId: fromNodeId,
                                            toNodeId: toNodeId,
                                            fromPortType: 'right',
                                            toPortType: 'left',
                                            interactionType: interactionType,
                                            interactionDetails: { layerName: triggeringInteraction.layerName || '' },
                                            transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                                            duration: transition.duration,
                                            easing: transition.easing,
                                            forceCShape: false,
                                            action: actionForConnection,
                                        });
                                    });
                                }
                                // ================================================================= //
                                // END OF REPLACEMENT LOGIC                                          //
                                // ================================================================= //
                            });
                        // Step 4: Import Action Nodes from the dedicated array
                                    if (Array.isArray(jsonStateMachine.actionNodes)) {
                                        jsonStateMachine.actionNodes.forEach(actionNodeData => {
                                            const actionNodeId = generateId();

                                            // --- START FIX: Convert imported action format ---
                                            let convertedActions = [];
                                            // Ensure the action data is an array for consistent processing
                                            const actionsToProcess = (Array.isArray(actionNodeData.action) ? actionNodeData.action : [actionNodeData.action]).filter(Boolean);

                                            if (globalState && globalState.inputs) {
                                                actionsToProcess.forEach(importedAction => {
                                                    if (!importedAction || !importedAction.inputName) return;

                                                    // Find the variable in our UI model by its name to get its ID.
                                                    const variable = globalState.inputs.find(v => v.name === importedAction.inputName);
                                                    if (variable) {
                                                        // Create the new action object using the variableId
                                                        convertedActions.push({
                                                            variableId: variable.id,
                                                            type: importedAction.type,
                                                            value: importedAction.value
                                                        });
                                                    } else {
                                                        console.warn(`[Import] Action node "${actionNodeData.name}" refers to unknown variable "${importedAction.inputName}". Action skipped.`);
                                                    }
                                                });
                                            }
                                            // --- END FIX ---

                                            nodes.push({
                                                id: actionNodeId,
                                                name: actionNodeData.name,
                                                type: 'action',
                                                x: actionNodeData.designer?.x || 100,
                                                y: actionNodeData.designer?.y || 400,
                                                action: convertedActions,
                                                wasImported: true // <-- Use the new converted array
                                            });

                                            const fromNodeId = stateNameToIdMap.get(actionNodeData.trigger.fromState);
                                            if (fromNodeId) {
                                                connections.push({
                                                    id: `conn_${generateId()}`,
                                                    fromNodeId: fromNodeId,
                                                    toNodeId: actionNodeId,
                                                    fromPortType: 'right',
                                                    toPortType: 'left',
                                                    interactionType: actionNodeData.trigger.interactionType,
                                                    interactionDetails: actionNodeData.trigger.interactionDetails || {},
                                                    action: convertedActions, // <-- Also use the converted array here
                                                });
                                            }
                                        });
                                    }
                            const initialNode = nodes.find(n => n.name === jsonStateMachine.initial);

                            return {
                                nodes: nodes,
                                connections: connections,
                                initialNodeId: initialNode ? initialNode.id : null,
                                globalState: globalState,
                                guardConnections: guardConnections,
                            };
                        }
        
        */

        /**
 * IMPORT FUNCTION: Converts an advanced state machine JSON into the UI's simple data format.
 */
function convertJsonToNodesAndConnections(jsonStateMachine) {
    if (!jsonStateMachine.states) return { nodes: [], connections: [], initialNodeId: null, globalState: null, guardConnections: [] };

    const nodes = [];
    const connections = [];
    const stateNameToIdMap = new Map();
    let globalState = null;
    const guardConnections = [];

    // Step 1: Create Global State and all its input variables first.
    if (jsonStateMachine.inputs && jsonStateMachine.inputs.length > 0) {
        const userVariables = jsonStateMachine.inputs
            .filter(input => input.type === 'Numeric' || input.type === 'Boolean')
            .map(input => ({
                id: `input_${generateId()}`,
                name: input.name,
                type: input.type,
                initialValue: input.value
            }));

        if (userVariables.length > 0) {
            const globalStateFromStates = jsonStateMachine.states.find(s => s.type === 'GlobalState');
            const hasDesignerData = globalStateFromStates && globalStateFromStates.designer;

            globalState = {
                id: 'global_state_node',
                name: globalStateFromStates?.name || 'Global Variables',
                x: hasDesignerData ? globalStateFromStates.designer.x : 50,
                y: hasDesignerData ? globalStateFromStates.designer.y : 50,
                wasImported: true,
                inputs: userVariables
            };
        }
    }

    // Step 2: Create all regular state nodes (PlaybackState)
    jsonStateMachine.states.forEach((state, index) => {
        if (state.type === 'GlobalState') return; 

        const nodeId = `id_${Math.random().toString(36).substr(2, 9)}`;
        stateNameToIdMap.set(state.name, nodeId);

        const hasDesignerData = state.designer && typeof state.designer.x === 'number' && typeof state.designer.y === 'number';

        nodes.push({
            id: nodeId,
            name: state.name,
            x: hasDesignerData ? state.designer.x : (50 + (index % 4) * 250),
            y: hasDesignerData ? state.designer.y : (50 + Math.floor(index / 4) * 150),
            animationId: state.animation,
            marker: state.segment || "",
            loop: (state.loopCount && state.loopCount > 0) ? state.loopCount : (state.loop || false),
            speed: state.speed || 1.0,
            autoplay: state.autoplay !== false,
            playInReverse: state.mode === "Reverse",
            isActive: state.name === jsonStateMachine.initial,
            isInitial: state.name === jsonStateMachine.initial,
            wasImported: true
        });
    });

    // Step 3: Reverse-engineer connections (regular and guard)
    jsonStateMachine.states.forEach(state => {
        if (!state.transitions) return;

        // A) Handle Guard Connections (from the GlobalState object)
        if (state.type === 'GlobalState' && globalState) {
            state.transitions.forEach(transition => {
                const toNodeId = stateNameToIdMap.get(transition.toState);
                if (!toNodeId || !transition.guards || transition.guards.length === 0) return;

                const conditions = transition.guards.map(guard => {
                    const variable = globalState.inputs.find(v => v.name === guard.inputName);
                    if (!variable) return null;

                    return {
                        variableId: variable.id,
                        condition: guard.conditionType,
                        value: guard.compareTo
                    };
                }).filter(Boolean); 

                if (conditions.length > 0) {
                    guardConnections.push({
                        id: `guard_${generateId()}`,
                        fromNodeId: 'global_state_node',
                        toNodeId: toNodeId,
                        conditions: conditions,
                        transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                        duration: transition.duration,
                        easing: transition.easing,
                    });
                }
            });
        }
        // B) Handle Regular Connections (from PlaybackState objects)
        else if (state.type !== 'GlobalState') {
            const fromNodeId = stateNameToIdMap.get(state.name);
            state.transitions.forEach(transition => {
                const toNodeId = stateNameToIdMap.get(transition.toState);
                const eventGuard = transition.guards?.find(g => g.type === 'Event');
                if (!eventGuard || !fromNodeId || !toNodeId) return;

                const triggeringInteraction = jsonStateMachine.interactions?.find(
                    i => i.actions?.some(a => a.type === 'Fire' && a.inputName === eventGuard.inputName)
                );
                if (!triggeringInteraction) return;

                let interactionType;
                const schemaType = triggeringInteraction.type;

                if (schemaType === 'OnComplete' && eventGuard.inputName.startsWith('onLoopComplete_')) {
                    interactionType = 'onLoopComplete';
                }
                else if (schemaType.startsWith('On')) {
                    interactionType = 'on' + schemaType.substring(2);
                } else {
                    interactionType = 'on' + schemaType;
                }
                
                // --- START: MODIFIED BLOCK (FIX FOR PROBLEM 2) ---
                let actionsForConnection = []; // <-- This is now an array
                let openUrlActionForConnection = null;

                if (globalState && triggeringInteraction.actions) {
                    // Loop through ALL actions in the interaction
                    triggeringInteraction.actions.forEach(action => {
                        if (action.type === 'Fire') {
                            // This is the event trigger, ignore it
                        } else if (action.type === 'OpenUrl') {
                            // This is a URL action
                            openUrlActionForConnection = action;
                        } else {
                            // This is a variable-based action
                            const variable = globalState.inputs.find(v => v.name === action.inputName);
                            if (variable) {
                                // Convert it back to our internal format with variableId and value
                                actionsForConnection.push({
                                    variableId: variable.id,
                                    type: action.type,
                                    value: action.value 
                                });
                            }
                        }
                    });
                }
                // --- END: MODIFIED BLOCK ---

                connections.push({
                    id: `conn_${generateId()}`,
                    fromNodeId: fromNodeId,
                    toNodeId: toNodeId,
                    fromPortType: transition.designer?.fromPort || 'right',
                    toPortType: transition.designer?.toPort || 'left',
                    forceCShape: transition.designer?.forceCShape || false,
                    interactionType: interactionType,
                    interactionDetails: { layerName: triggeringInteraction.layerName || '' },
                    transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                    duration: transition.duration,
                    easing: transition.easing,
                    action: actionsForConnection, // <-- Save the full array
                    openUrlAction: openUrlActionForConnection
                });
            });
        }
    });

    // Step 4: Import Action Nodes from the dedicated array
    if (Array.isArray(jsonStateMachine.actionNodes)) {
        jsonStateMachine.actionNodes.forEach(actionNodeData => {
            const actionNodeId = generateId();

            let convertedVariableActions = []; // For Increment, Toggle, etc.
            let openUrlAction = null; // --- NEW: For OpenUrl ---

            const actionsToProcess = (Array.isArray(actionNodeData.action) ? actionNodeData.action : [actionNodeData.action]).filter(Boolean);

            actionsToProcess.forEach(importedAction => {
                if (!importedAction || !importedAction.type) return;

                // --- NEW: Check action type ---
                if (importedAction.type === 'OpenUrl') {
                    // This is a URL action, store it separately
                    openUrlAction = {
                        type: 'OpenUrl',
                        url: importedAction.url,
                        target: importedAction.target || '_blank'
                        // No _tempId needed here, it's not part of a list UI
                    };
                
                } else if (importedAction.inputName && globalState && globalState.inputs) {
                    // This is a variable-based action
                    const variable = globalState.inputs.find(v => v.name === importedAction.inputName);
                    if (variable) {
                        convertedVariableActions.push({
                            variableId: variable.id,
                            type: importedAction.type,
                            value: importedAction.value
                        });
                    } else {
                        console.warn(`[Import] Action node "${actionNodeData.name}" refers to unknown variable "${importedAction.inputName}". Action skipped.`);
                    }
                }
                // --- END NEW ---
            });


            nodes.push({
                id: actionNodeId,
                name: actionNodeData.name,
                type: 'action',
                x: actionNodeData.designer?.x || 100,
                y: actionNodeData.designer?.y || 400,
                action: convertedVariableActions, // This is now *only* variable actions
                openUrlAction: openUrlAction, // --- NEW: Store the URL action here ---
                wasImported: true
            });

            const fromNodeId = stateNameToIdMap.get(actionNodeData.trigger.fromState);
            if (fromNodeId) {
                connections.push({
                    id: `conn_${generateId()}`,
                    fromNodeId: fromNodeId,
                    toNodeId: actionNodeId,
                    fromPortType: 'right', 
                    toPortType: 'left',  
                    interactionType: actionNodeData.trigger.interactionType,
                    interactionDetails: actionNodeData.trigger.interactionDetails || {},
                    action: convertedVariableActions, // Pass variable actions
                    openUrlAction: openUrlAction // --- NEW: Pass URL action ---
                });
            }
        });
    }

    const initialNode = nodes.find(n => n.name === jsonStateMachine.initial);

    return {
        nodes: nodes,
        connections: connections,
        initialNodeId: initialNode ? initialNode.id : null,
        globalState: globalState,
        guardConnections: guardConnections,
    };
}
        // -- SECTION 3: HELPER FUNCTIONS --
        
        /**
         * Helper function for parsing "Frame A to B" strings.
         */
        function generateFrameRangeMarker(markerString, existingMarkers) {

            if (typeof markerString !== 'string') {
                return null; // Don't try to .match() on undefined or null
            }

            const frameRangeMatch = markerString.match(/^Frame (\d+) to (\d+)$/);
            if (frameRangeMatch) {
                const frameStart = parseInt(frameRangeMatch[1], 10);
                const frameEnd = parseInt(frameRangeMatch[2], 10);
                const exists = existingMarkers.some(m => m.name === markerString);
                if (!exists) {
                    return { name: markerString, start: frameStart, end: frameEnd };
                }
            }
            return null;
        }

        /**
         * IMPORT HELPER: Extracts "10-20" style segments from a state machine JSON
         * and structures them for the animation library.
         */
        function extractFrameRangeMarkersFromJson(jsonStateMachine) {
            const animationMarkersMap = new Map();

            if (!jsonStateMachine || !jsonStateMachine.states) {
                return [];
            }

            jsonStateMachine.states.forEach(state => {
                const animId = state.animation;
                const segmentName = state.segment;

                if (animId && segmentName && /^\d+-\d+$/.test(segmentName)) {
                    const parts = segmentName.split('-');
                    const startFrame = parseInt(parts[0], 10);
                    const endFrame = parseInt(parts[1], 10);

                    if (!isNaN(startFrame) && !isNaN(endFrame)) {
                        if (!animationMarkersMap.has(animId)) {
                            animationMarkersMap.set(animId, {
                                id: animId,
                                name: animId,
                                markers: []
                            });
                        }
                        const animData = animationMarkersMap.get(animId);
                        if (!animData.markers.some(m => m.name === segmentName)) {
                            animData.markers.push({
                                name: segmentName,
                                start: startFrame,
                                end: endFrame
                            });
                        }
                    }
                }
            });

            return Array.from(animationMarkersMap.values());
        }
    </script>
    <script type="module">
import { DotLottie } from "https://esm.sh/@lottiefiles/dotlottie-web";

        const NEW_VARIABLE_BLOCK_DELAY_MS = 100;

/**
 * Renders a single, fully interactive action editor row from the template.
 * It populates the row with data, appends it to a container, and attaches all necessary
 * event listeners for real-time updates to the source data array.
 * @param {object} actionObject - The action data to render { type, value, variableId, _tempId }.
 * @param {HTMLElement} container - The parent DOM element to append the new row to.
 * @param {Array} sourceActionsArray - The source array (e.g., tempConnectionData.action) that this row's data belongs to.
 */
function renderAndAttachActionRow(actionObject, container, sourceActionsArray) {
    if (!globalState || !actionObject || !container || !sourceActionsArray) {
        console.error("[Render Action Error] Missing required parameters.", { actionObject, container, sourceActionsArray });
        return;
    }

    const template = document.getElementById('action-row-template').content.cloneNode(true);
    const actionRow = template.querySelector('.action-editor-row');

    actionObject._tempId = actionObject._tempId || `action_${generateId()}`;
    actionRow.dataset.tempId = actionObject._tempId;

    const varDropdownGroup = actionRow.querySelector('.action-variable-dropdown-group');
    const varDropdownId = `action-var-select-${actionObject._tempId}`;
    varDropdownGroup.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
            <label for="${varDropdownId}" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">TARGET VARIABLE</label>
            <div class="custom-dropdown-container">
                <div class="custom-dropdown-display" data-target-select="${varDropdownId}"></div>
                <div class="custom-dropdown-options"></div>
                <select id="${varDropdownId}" class="action-variable-select" style="display: none;"></select>
            </div>
        </div>`;
    
    const varDisplay = varDropdownGroup.querySelector('.custom-dropdown-display');
    const varOptionsContainer = varDropdownGroup.querySelector('.custom-dropdown-options');
    const varNativeSelect = varDropdownGroup.querySelector('select');
    const variableOptions = globalState.inputs.map(v => ({ id: v.id, name: v.name }));
    populateDropdowns(varNativeSelect, varDisplay, varOptionsContainer, variableOptions, actionObject.variableId);

    const typeDropdownGroup = actionRow.querySelector('.action-type-dropdown-group');
    const typeDropdownId = `action-type-select-${actionObject._tempId}`;
    typeDropdownGroup.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
            <label for="${typeDropdownId}" class="action-type-label">ACTION TYPE</label>
            <div class="custom-dropdown-container">
                <div class="custom-dropdown-display" data-target-select="${typeDropdownId}"></div>
                <div class="custom-dropdown-options"></div>
                <select id="${typeDropdownId}" class="action-type-select" style="display: none;"></select>
            </div>
        </div>
        <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;

    const typeDisplay = typeDropdownGroup.querySelector('.custom-dropdown-display');
    const typeOptionsContainer = typeDropdownGroup.querySelector('.custom-dropdown-options');
    const typeNativeSelect = typeDropdownGroup.querySelector('select');
    const valueField = actionRow.querySelector('.action-value-field');
    const typeLabel = typeDropdownGroup.querySelector('.action-type-label');

    function populateAndSetActionTypes(variableId, selectedActionType, selectedValue) {
        const targetVar = globalState.inputs.find(v => v.id === variableId);
        // MODIFIED: Get the raw name, without quotes
        const varName = targetVar ? truncateText(targetVar.name, 20) : 'Variable';
        // MODIFIED: Use .innerHTML to add the pill
        typeLabel.innerHTML = `<span class="variable-pill">${varName}</span> will be`;
        if (!targetVar) return;

        let actionOptions = [{ id: '', name: 'No action' }];
        if (targetVar.type === 'Numeric') {
            actionOptions.push({ id: 'Increment', name: `increased by` }, { id: 'Decrement', name: `decreased by` }, { id: 'SetNumeric', name: `set to` });
        } else if (targetVar.type === 'Boolean') {
            actionOptions.push({ id: 'Toggle', name: `toggled` }, { id: 'SetBoolean', name: `set to` });
        }
        populateDropdowns(typeNativeSelect, typeDisplay, typeOptionsContainer, actionOptions, selectedActionType);
        updateActionValueField(selectedActionType, selectedValue, valueField);
    }
    
    populateAndSetActionTypes(actionObject.variableId, actionObject.type, actionObject.value);
    container.appendChild(actionRow);

    const renderedRow = container.querySelector(`[data-temp-id="${actionObject._tempId}"]`);
    const getActionObject = () => sourceActionsArray.find(a => a._tempId === actionObject._tempId);

    // --- FIX: Create a reusable function to trigger the canvas update ---
    const triggerCanvasUpdate = () => {
        // This check ensures we only update the canvas if we're editing an Action Node,
        // not a transition on a connection line.
        if (selectedNodeForEdit && selectedNodeForEdit.type === 'action') {
            const nodeWrapper = document.getElementById(selectedNodeForEdit.id);
            if (nodeWrapper) {
                const nodeElement = nodeWrapper.querySelector('.node');
                if (nodeElement) {
                    updateActionNodeVisual(nodeElement, selectedNodeForEdit);
                }
            }
        }
    };

    renderedRow.querySelector('.delete-action-button').addEventListener('click', () => {
        const index = sourceActionsArray.findIndex(a => a._tempId === actionObject._tempId);
        if (index > -1) {
            sourceActionsArray.splice(index, 1);
        }
        renderedRow.remove();
        triggerCanvasUpdate(); // Update canvas after deleting an action
    });

    renderedRow.querySelector('.action-variable-dropdown-group').addEventListener('click', (e) => {
        const option = e.target.closest('.custom-dropdown-option');
        if (option) {
            const actionToUpdate = getActionObject();
            if (actionToUpdate) {
                const newVarId = option.dataset.value;
                if (actionToUpdate.variableId !== newVarId) {
                    actionToUpdate.variableId = newVarId;
                    actionToUpdate.type = '';
                    actionToUpdate.value = '';
                    populateAndSetActionTypes(newVarId, '', '');
                    triggerCanvasUpdate(); // Update canvas when variable changes
                }
            }
        }
    });

    renderedRow.querySelector('.action-type-dropdown-group').addEventListener('click', (e) => {
        e.stopPropagation();
        const option = e.target.closest('.custom-dropdown-option');
        const optionsContainer = renderedRow.querySelector('.action-type-dropdown-group .custom-dropdown-options');

        if (option) {
            const actionToUpdate = getActionObject();
            if (actionToUpdate) {
                const newType = option.dataset.value;
                typeDisplay.textContent = option.textContent;
                actionToUpdate.type = newType;
                
                let defaultValue = '';
                if (newType === 'Increment' || newType === 'Decrement') {
                    defaultValue = '1';
                } else if (newType === 'SetBoolean') {
                    defaultValue = 'true';
                }
                actionToUpdate.value = defaultValue;
                
                updateActionValueField(newType, actionToUpdate.value, valueField);
                triggerCanvasUpdate(); // --- FIX: This is the crucial line that was missing ---
            }
            optionsContainer.classList.remove('open');
        } else {
            const wasOpen = optionsContainer.classList.contains('open');
            closeAllCustomDropdowns();
            if (!wasOpen) {
                optionsContainer.classList.add('open');
            }
        }
    });

    const valueInput = renderedRow.querySelector('.action-value-input');
    if (valueInput) {
        valueInput.addEventListener('input', (e) => {
            const actionToUpdate = getActionObject();
            if (actionToUpdate) {
                actionToUpdate.value = e.target.value;
                triggerCanvasUpdate(); // --- FIX: Update canvas on value change ---
            }
        });
    }
    
    renderedRow.querySelector('.decrement-action-value')?.addEventListener('click', () => {
        valueInput.stepDown();
        valueInput.dispatchEvent(new Event('input'));
        // The 'input' event will trigger the canvas update.
    });
    renderedRow.querySelector('.increment-action-value')?.addEventListener('click', () => {
        valueInput.stepUp();
        valueInput.dispatchEvent(new Event('input'));
        // The 'input' event will trigger the canvas update.
    });

    renderedRow.querySelector('.action-boolean-value-toggle')?.addEventListener('click', () => {
        const actionToUpdate = getActionObject();
        if (actionToUpdate) {
            actionToUpdate.value = !(actionToUpdate.value === 'true' || actionToUpdate.value === true);
            updateActionValueField(actionToUpdate.type, actionToUpdate.value, valueField);
            triggerCanvasUpdate(); // --- FIX: Update canvas on boolean toggle ---
        }
    });
}


// --- NEW: Global Animation Control Variables ---
const slideInEasingforIframes = 'cubic-bezier(0.1, 0.1, 0.1, 1)'; // Example: A fast-starting "easeOutQuart"
const slideOutEasingforIframes = 'cubic-bezier(0.7, 0, 0.2, 1)'; // A standard "ease-in-out" curve
const iframeContentAnimationDuration = 550; // in milliseconds
const iframeBackdropAnimationDuration = 200; // in milliseconds
const backdropEasing = 'ease-out';

// Apply these JS variables to the CSS variables on the root element
document.documentElement.style.setProperty('--iframe-content-duration', `${iframeContentAnimationDuration}ms`);
document.documentElement.style.setProperty('--iframe-backdrop-duration', `${iframeBackdropAnimationDuration}ms`);
document.documentElement.style.setProperty('--iframe-slide-in-easing', slideInEasingforIframes);
document.documentElement.style.setProperty('--iframe-slide-out-easing', slideOutEasingforIframes);
document.documentElement.style.setProperty('--iframe-backdrop-easing', backdropEasing);
// --- END NEW ---


// --- Logic for Crop Tool Iframe (Now inside the main script) ---

// Get DOM elements
const addSegmentsButton = document.getElementById('add-segments-button');
const cropToolModal = document.getElementById('crop-tool-modal');
const cropToolIframe = document.getElementById('crop-tool-iframe');
const saveCropChangesButton = document.getElementById('save-crop-changes-button');
const closeCropModalButton = document.getElementById('close-crop-modal-button');

// --- NEW: Logic for Click Area Editor Iframe ---
const clickAreaModal = document.getElementById('click-area-modal');
const clickAreaIframe = document.getElementById('click-area-iframe');
const closeClickAreaModalButton = document.getElementById('close-click-area-modal-button');

// Listener to open the modal

// --- NEW: Variable to store the interaction type before opening the click area editor ---
let previousInteractionType = null;

addSegmentsButton.addEventListener('click', () => {
   
    // Find the active node and its animation data
    // No "window." needed here as we are in the same script scope
     if (!globalAnimationId) {
        // This case happens if no animations have been loaded into the tool at all.
        alert("Please load an animation before trying to edit segments.");
        return;
    }

    const animationData = availableAnimations.find(anim => anim.id === globalAnimationId);
    if (!animationData || !animationData.jsonContent) {
        // This case is a safety net, in case globalAnimationId is set but the data is missing.
        alert("Could not find the JSON data for the currently selected animation.");
        return;
    }
    // --- NEW: Entrance Animation Logic ---
    // 1. Set initial animated-out state
    const header = cropToolModal.querySelector('.modal-header');
    const iframe = cropToolModal.querySelector('#crop-tool-iframe');
    cropToolModal.style.opacity = '0';
    if (header) { header.style.opacity = '0'; header.style.transform = 'translateY(-20px)'; }
    if (iframe) { iframe.style.opacity = '0'; iframe.style.transform = 'translateY(20px)'; }

    // Show the modal and set the iframe source
    cropToolModal.style.display = 'flex';
    cropToolIframe.src = 'overlay.html';

    // 2. In the next frame, transition to the final state to trigger animation
    setTimeout(() => {
        cropToolModal.style.opacity = '1';
        if (header) {
            header.style.opacity = '1';
            header.style.transform = 'translateY(0)';
        }
        if (iframe) {
            iframe.style.opacity = '1';
            iframe.style.transform = 'translateY(0)';
        }
    }, 10); // A small timeout is enough to ensure the initial state is rendered first

    // Wait for the iframe to load before sending data
    cropToolIframe.onload = () => {
        cropToolIframe.contentWindow.postMessage({
            type: 'lottieData',
            data: JSON.parse(animationData.jsonContent), // Ensure you're parsing the stringified JSON
            filename: `${animationData.id}.json`
        }, '*');
    };
});

// Listener for the remote "Save" button
saveCropChangesButton.addEventListener('click', () => {
    cropToolIframe.contentWindow.postMessage({
        type: 'triggerSaveAndCloseCrop'
    }, '*');
});

// Listener to receive data back from the iframe
window.addEventListener('message', (event) => {
    // --- MODIFIED: Save transition settings automatically after click area is saved ---
    if (event.data && event.data.type === 'clickAreaDataFromMarkerTool') {
        const { modifiedAnimationData, originalAnimationId } = event.data;
        
        // 1. Update the Lottie JSON with the new click area data from the iframe.
        handleUpdatedAnimationData(modifiedAnimationData, originalAnimationId);

        // 2. Reset the state for the 'cancel' button logic to prevent accidental reverts.
        previousInteractionType = null;

        // 3. Close the click area editor modal.
        closeClickAreaModalWithAnimation(); // Use the new animation function
        
        // 4. Save the transition settings without closing the modal.
        saveConnectionSettings();

        // --- NEW: Refresh the left panel to update the interaction count on the marker card ---
        populateLeftPanelMarkers(globalAnimationId);

        // --- NEW: Animate the button as a visual cue after the modal transition is complete ---
        // --- MODIFIED: Trigger the animation immediately as the modal scales up. ---
        animateClickAreaButtonOnSave();
    }
    // --- END MODIFICATION ---

    // --- NEW: Handle message from the Click Area tool's "Cancel" button ---
    if (event.data && event.data.type === 'closeClickAreaTool') {
        closeClickAreaModalWithAnimation(); // Use the new animation function
    }
    // --- END NEW ---

    if (event.data && (event.data.type === 'dataFromCropTool' || event.data.type === 'dataFromTrimTool')) {
        const receivedData = event.data;
        console.log('Received updated Lottie data:', receivedData);

        const animationToUpdate = availableAnimations.find(
            anim => `${anim.id}.json` === receivedData.originalFilename
        );
        handleUpdatedAnimationData(receivedData.lottieData, animationToUpdate.id, receivedData.deletedSegmentNames, receivedData.renamedSegments);

        closeCropModalWithAnimation(); // Call the new animation function
    }

    // --- NEW: Handle message from the overlay's close button ---
    if (event.data && event.data.type === 'closeTrimTool') {
        cropToolModal.style.display = 'none';
    }

  if (event.data && event.data.type === 'layoutJsonResponse') {
                const jsonString = JSON.stringify(event.data.payload); // Pretty-print
                try {
                    navigator.clipboard.writeText(jsonString);
                    
                    // --- MODIFICATION: Update Share Modal UI ---
                    const copyButton = document.getElementById('share-modal-copy-button');
                    if (copyButton) {
                        copyButton.innerHTML = `<i class="fas fa-check"></i> <span>Copied!</span>`;
                        copyButton.disabled = true;
                    }
                    // --- END MODIFICATION ---

                } catch (err) {
                    console.error('Failed to copy JSON to clipboard:', err);
                    showCustomAlert("Failed to copy to clipboard. See console for details.");
                }
            }
});

// --- NEW: Function to delete nodes associated with removed segments ---
function synchronizeDeletedNodes(deletedNames, animationId) {
    if (!deletedNames || deletedNames.length === 0) {
        return; // Nothing to do
    }

    console.log(`[SYNC] Checking for nodes to delete based on removed segments for animation ID: ${animationId}`);
    const nodesToDelete = [];

    // Find all nodes that are linked to one of the deleted marker names
    nodes.forEach(node => {
        if (node.animationId === animationId && deletedNames.includes(node.marker)) {
            nodesToDelete.push(node.id);
            console.log(`[SYNC] Queuing node '${node.name}' (ID: ${node.id}) for deletion as its marker '${node.marker}' was removed.`);
        }
    });

    // Delete the identified nodes
    if (nodesToDelete.length > 0) {
        nodesToDelete.forEach(nodeId => deleteNode(nodeId));
        showCustomAlert(`${nodesToDelete.length} state(s) were automatically deleted because their animation segments were removed.`);
    }
}

// --- NEW: Function to synchronize click layer durations with updated markers ---
function synchronizeClickLayers(lottieData, animationId) {
    console.log(`[SYNC] Running click layer synchronization for animation ID: ${animationId}`);
    const lottieJson = JSON.parse(JSON.stringify(lottieData)); // Work on a deep copy
    const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
    let changesMade = 0;

    connections.forEach(conn => {
        const fromNode = nodes.find(n => n.id === conn.fromNodeId);
        const toNode = nodes.find(n => n.id === conn.toNodeId);

        const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
        if (fromNode && toNode && fromNode.animationId === animationId && pointerEvents.includes(conn.interactionType)) {
            
            const fromStateName = fromNode.name;
            const toStateName = toNode.name;
            const interactionName = conn.interactionType.replace('on', '').toLowerCase();
            const layerName = `${fromStateName}_${interactionName}_to_${toStateName}`;

            const layerToUpdate = lottieJson.layers.find(l => l.nm === layerName);
            const sourceMarker = lottieJson.markers.find(m => m.cm === fromNode.marker);

            if (layerToUpdate && sourceMarker) {
                const newInPoint = sourceMarker.tm;
                const newOutPoint = sourceMarker.tm + sourceMarker.dr + 0.1; // Add 0.1 for consistency

                if (layerToUpdate.ip !== newInPoint || layerToUpdate.op !== newOutPoint) {
                    console.log(`[SYNC] Updating layer '${layerName}' duration from ${layerToUpdate.ip}-${layerToUpdate.op} to ${newInPoint}-${newOutPoint}`);
                    layerToUpdate.ip = newInPoint;
                    layerToUpdate.op = newOutPoint;
                    layerToUpdate.st = newInPoint; // Also update the layer's start time
                    changesMade++;
                }
            }
        }
    });
    if (changesMade > 0) console.log(`[SYNC] Finished. ${changesMade} click layer(s) were updated.`);
    return lottieJson;
}


function synchronizeRenamedNodes(renamedSegments, animationId) {
    if (!renamedSegments || renamedSegments.length === 0) {
        return; // Nothing to do
    }

    console.log(`[SYNC] Checking for nodes to update based on ${renamedSegments.length} renamed segment(s) for animation ID: ${animationId}`);
    let updatedNodesCount = 0;

    renamedSegments.forEach(({ oldName, newName }) => {
        // Find all nodes that are linked to the old marker name
        nodes.forEach(node => {
            if (node.animationId === animationId && node.marker === oldName) {
                // 1. Update the node's marker property to the new name
                node.marker = newName;
                console.log(`[SYNC] Updated node '${node.name}' (ID: ${node.id}) from marker '${oldName}' to '${newName}'.`);
                
                // 2. (Optional but recommended) If the node's name was the same as the old marker name, update it too.
                if (node.name === oldName) {
                    let potentialNewName = newName;
                    let counter = 1;
                    // Ensure the new node name is unique
                    while (nodes.some(n => n.name === potentialNewName && n.id !== node.id)) {
                        potentialNewName = `${newName}_${counter++}`;
                    }
                    node.name = potentialNewName;
                    console.log(`[SYNC] Renamed node from '${oldName}' to '${node.name}'.`);
                }

                // 3. Immediately update the visual representation of the node on the canvas
                updateNodeElement(node);
                updatedNodesCount++;
            }
        });
    });

    if (updatedNodesCount > 0) {
        showCustomAlert(`${updatedNodesCount} state(s) were automatically updated to use the new segment name(s).`);
    }
}


// --- NEW: Centralized function to handle updated animation data from any tool ---
function handleUpdatedAnimationData(lottieData, animationId, deletedSegmentNames = [], renamedSegments = []) {
    const animationToUpdate = availableAnimations.find(anim => anim.id === animationId);
    if (animationToUpdate) {
        // --- NEW: First, handle node deletions based on removed segments ---
        // This must happen BEFORE other updates that might rely on the old node structure.
          synchronizeRenamedNodes(renamedSegments, animationId);
        synchronizeDeletedNodes(deletedSegmentNames, animationId);

        // 2. Update the raw JSON content
        animationToUpdate.jsonContent = JSON.stringify(lottieData);

        // 2. Re-parse and update the markers array
        if (lottieData.markers && Array.isArray(lottieData.markers)) {
            // Convert Lottie marker format {cm, tm, dr} to our internal format {name, start, end}
            animationToUpdate.markers = lottieData.markers.map(marker => ({
                name: marker.cm,
                start: marker.tm,
                end: marker.tm + marker.dr
            }));
        } else {
            animationToUpdate.markers = []; // Clear markers if none exist
        }

        // 3. Refresh the UI if the node properties modal is open for the affected animation
        if (selectedNodeForEdit && selectedNodeForEdit.animationId === animationToUpdate.id) {
            populateAnimationAndMarkerDropdowns(selectedNodeForEdit.animationId, selectedNodeForEdit.marker);
            // Refresh the preview player using a callback to ensure actions happen after loading.
            modalDotLottiePlayer.load(
                { data: lottieData, loop: true },
                () => { // This is the onComplete callback
                    // After loading, play the correct segment for the node being edited.
                    const markerName = selectedNodeForEdit.marker;
                    const marker = animationToUpdate.markers.find(m => m.name === markerName);
    
                    if (marker) {
                        modalDotLottiePlayer.setSegment(marker.start, marker.end);
                    }
                    // Always call play, which will respect the segment if set.
                    modalDotLottiePlayer.setLoop(true);
                    modalDotLottiePlayer.play();
                    
                }
            );
            
        }

        // --- Synchronize click layers before refreshing the UI ---
        const syncedLottieData = synchronizeClickLayers(lottieData, animationId);
        animationToUpdate.jsonContent = JSON.stringify(syncedLottieData);

        // --- If the properties panel is open, refresh it to reflect the new data ---
        if (selectedNodeForEdit && selectedNodeForEdit.animationId === animationToUpdate.id) {
            console.log("[LOG] Re-opening node properties to refresh player with updated animation data.");
            openNodePropertiesModal(selectedNodeForEdit);
        }
        
        // --- MODIFIED: Do not show alert if nodes were already deleted (the other alert is more specific) ---
        if (deletedSegmentNames.length === 0) {
            showCustomAlert(`Animation segments for "${animationToUpdate.name}" have been updated.`);
        }

        // --- NEW: Refresh the left panel to show new/updated markers ---
        populateLeftPanelMarkers(animationId);

        // --- NEW: Refresh the left panel to update interaction counts ---
        populateLeftPanelMarkers(animationId);
    } else {
        console.error(`Could not find animation with ID "${animationId}" to update.`);
    }
}

// Listener to close the modal
closeCropModalButton.addEventListener('click', closeCropModalWithAnimation);

// --- NEW: Reusable function to close the crop modal with animation ---
function closeCropModalWithAnimation() {
    // 1. Animate header (buttons) up and out
    const header = cropToolModal.querySelector('.modal-header');
    if (header) {
        header.style.opacity = '0';
        header.style.transform = 'translateY(-20px)';
    }
    // 2. Animate iframe down and out
    const iframe = cropToolModal.querySelector('#crop-tool-iframe');
    if (iframe) {
        iframe.style.opacity = '0';
        iframe.style.transform = 'translateY(20px)';
    }

    // 3. After the content animation finishes, start fading the backdrop AND animate the underlying modal back in.
    setTimeout(() => {
        cropToolModal.style.opacity = '0';

        // Animate the underlying connection editor back into view
        const connEditorContent = connectionEditorModal.querySelector('.connection-editor-content');
        
     
            if (connEditorContent) {
            connEditorContent.style.transform = 'scale(1)';
        }
       
        
    }, 0);

    // 4. After ALL animations complete, hide the modal and reset styles for next time.
    setTimeout(() => {
        cropToolModal.style.display = 'none';
        // --- NEW: Reset styles for next open ---
        clickAreaModal.style.pointerEvents = 'auto';
        cropToolModal.style.opacity = '1';
        if (header) { header.style.opacity = '1'; header.style.transform = 'translateY(0)'; }
        if (iframe) { iframe.style.opacity = '1'; iframe.style.transform = 'translateY(0)'; }
        // --- END NEW ---
    }, 750); // This duration must match the total animation time
}

// --- NEW: Listener to close the click area modal ---
closeClickAreaModalButton.addEventListener('click', closeClickAreaModalWithAnimation);

// --- NEW: Reusable function to close the click area modal with animation ---
function closeClickAreaModalWithAnimation() {
    // --- NEW: Revert the interaction type if it was changed ---
    if (previousInteractionType && tempConnectionData) {
        // Revert the data model
        tempConnectionData.interactionType = previousInteractionType;
        // Re-populate the dropdown to show the reverted value
        populateDropdowns(interactionPresetNativeSelect, interactionPresetDisplay, interactionPresetOptionsContainer, INTERACTION_PRESETS, previousInteractionType);
        // Update the dynamic fields to match the reverted state
        updateDynamicInteractionFields(previousInteractionType, tempConnectionData.interactionDetails || {});
    }

    // 1. Animate header (buttons) up and out
    const header = clickAreaModal.querySelector('.modal-header');
    if (header) {
        header.style.opacity = '0';
        header.style.transform = 'translateY(-30px)';
    }
    // 2. Animate iframe down and out
    const iframe = clickAreaModal.querySelector('#click-area-iframe');
    if (iframe) {
        iframe.style.opacity = '0';
        iframe.style.transform = 'translateY(70px)';
    }

    // --- MODIFIED: Animate the underlying modal back into view at the same time ---
    const connEditorContent = connectionEditorModal.querySelector('.connection-editor-content');
   setTimeout(() => {
    if (connEditorContent) {
        connEditorContent.style.transform = 'scale(1)';
    }}, 450);
    // --- END MODIFICATION ---

    // 3. After the content animation finishes, start fading the backdrop AND animate the underlying modal back in.
    // --- FIX: Restore save button visibility on close ---
    document.getElementById('save-click-area-button').style.display = 'flex';
    // --- END FIX ---
    setTimeout(() => {
        clickAreaModal.style.opacity = '0';
        // --- FIX: Allow clicks to pass through the invisible modal ---
        clickAreaModal.style.pointerEvents = 'none';
        // Animate the underlying connection editor back into view
        const connEditorContent = connectionEditorModal.querySelector('.connection-editor-content');
        if (connEditorContent) {
            // This was moved up in the previous step
        }
    }, 450);

    // --- NEW: After ALL animations complete, hide the modal and reset styles for next time. ---
    setTimeout(() => {
        clickAreaModal.style.display = 'none';
        // Reset styles for next open
        clickAreaModal.style.opacity = '1';
        if (header) {
            header.style.opacity = '1';
            header.style.transform = 'translateY(0)';
        }
        if (iframe) {
            iframe.style.opacity = '1';
            iframe.style.transform = 'translateY(0)';
        }
    }, 750); // This duration should be longer than the content animation (450ms)
}


const modalLottieCanvas = document.getElementById('modal-lottie-canvas');
let modalDotLottiePlayer;

let currentLoadedLottieSrc = '';
const initialNodeCheckbox = document.getElementById('initial-node-checkbox');
const initialNodeToggleGroup = document.getElementById('initial-node-toggle-group');


const freezeOnFirstFrameCheckbox = document.getElementById('freeze-on-first-frame-checkbox'); // NEW
        const freezeOnFirstFrameToggleGroup = document.getElementById('freeze-on-first-frame-toggle-group'); // NEW
    // --- DOM Elements (add these with your other DOM variable declarations) ---
        const statePreviewWindow = document.getElementById('state-preview-window');
        const previewToggleButton = document.getElementById('preview-toggle-button');
        const previewToggleIcon = previewToggleButton.querySelector('i'); // Get the icon within the button

        // --- Event Listener (add this inside window.addEventListener('load', ...) ) ---
        previewToggleButton.addEventListener('click', () => {
            statePreviewWindow.classList.toggle('hidden');
            // The icon rotation is handled purely by CSS now based on the 'hidden' class
        });

        // Initially hide the window (optional, depends on desired default state)
        // statePreviewWindow.classList.add('hidden');



        // --- Constants ---
        const NODE_WIDTH = 180;
        const NODE_HEIGHT = 100;
        const MINIMAL_CANVAS_EDGE_PADDING = 260; // Increased padding
        const DEFAULT_MIN_CANVAS_WIDTH = 300;
        const DEFAULT_MIN_CANVAS_HEIGHT = 200;
        const PORT_SIZE = 16; /* Increased size */
        const PORT_OFFSET = 10; /* Adjusted offset based on new PORT_SIZE */
        const ROUTING_STUB = 45;
        const ARROW_Y_OFFSET = 0;
        const ConnectionPortOffset = 12;
        const ConnectionLineLengthPercentage = 99;
        const ConnectionCornerRadius = 40;
        const ConnectionTextPositionPercentage = 51;

        // --- NEW: Global variable to control the node hover area size ---
        let globalAnimationId = ''; // NEW: To store the ID of the single animation for the whole machine
        const NODE_HOVER_AREA_PERCENTAGE = 14; // The percentage to expand the hover area by
        const EXTRA_RIGHT_PANNING_SPACE = 500;
        // --- Data Models ---
        let nodes = [];
        let connections = [];
        // NEW: Data models for new features
        let globalState = null; // { id, name, type, initialValue, x, y }
        let guardConnections = []; // { id, fromNodeId, toNodeId, condition, value }
        let selectedGuardConnectionForEdit = null;

        let selectedNodeForEdit = null;
        let selectedConnectionForEdit = null;
        let tempConnectionData = null; // NEW: For editing in the modal without modifying the original
        let transitionEditorStateBackup = null; // NEW: For reverting changes on cancel
        let currentHoveredDestinationNode = null; // Track the node currently highlighted as a potential destination

        let availableAnimations = [
            { id: 'animation_1', name: 'Main App Flow', markers: [{ name: 'intro_segment', start: 0, end: 50 }, { name: 'idle_loop', start: 51, end: 150 }, { name: 'success_burst', start: 151, end: 200 }, { name: 'error_shake', start: 201, end: 250 }], jsonContent: null, clickLayers: new Set() },
            { id: 'animation_2', name: 'pigeon', markers: [{ name: 'spin_loop', start: 0, end: 60 }, { name: 'fade_out', start: 61, end: 80 }], jsonContent: null, clickLayers: new Set() },
            { id: 'toggle', name: 'toggle', markers: [{ name: 'default_state', start: 0, end: 1 }, { name: 'hover_in', start: 1, end: 15 }, { name: 'hover_out', start: 15, end: 1 }], jsonContent: null, clickLayers: new Set() }
        ];

        const TRANSITION_TYPES = [
            { id: 'Transition', name: 'Immediate' },
            { id: 'Tweened', name: 'Tweened' }
        ];

      const INTERACTION_PRESETS = [
    { id: 'onComplete', name: 'On Complete' },
    { id: 'onLoopComplete', name: 'On Loop Complete' },
    { id: 'onClick', name: 'Click' },
    { id: 'onPointerEnter', name: 'Hover On (Pointer Enter)', shortName: 'hover on' },
    { id: 'onPointerExit', name: 'Hover Off (Pointer Exit)', shortName: 'hover off' },
    { id: 'onPointerDown', name: 'Pointer Down' },
    { id: 'onPointerUp', name: 'Pointer Up' },
    { id: 'onPointerMove', name: 'Pointer Move' }
];;


        // --- DOM Elements ---

        const loadLottieButton = document.getElementById('load-lottie-button');
        const lottieFileInput = document.getElementById('lottie-file-input');



        const flowchartArea = document.getElementById('flowchart-area');
        const canvasContainer = document.getElementById('canvas-container');
        const addNodeButton = document.getElementById('add-node-button');
        const addActionNodeButton = document.getElementById('add-action-node-button'); // NEW
        const connectNodesButton = document.getElementById('connect-nodes-button');
        const loadJsonButton = document.getElementById('load-json-button'); // New
        // NEW: Button and input for single animation JSON upload
        const addAnimationJsonButton = document.getElementById('add-animation-json-button');
        const animationJsonFileInput = document.getElementById('animation-json-file-input');
        const exportJsonButton = document.getElementById('export-json-button'); // New
        const addGlobalStateButton = document.getElementById('add-global-state-button'); // NEW
        const addGuardButton = document.getElementById('add-guard-button'); // NEW
        const jsonFileInput = document.getElementById('json-file-input'); // New

        const connectModeIndicator = document.getElementById('connect-mode-indicator');
        const guardModeIndicator = document.getElementById('guard-mode-indicator'); // NEW
        const connectionExistsIndicator = document.getElementById('connection-exists-indicator'); // New element
        const connectionSvg = document.getElementById('connection-svg');
        const nodePropertiesModal = document.getElementById('node-properties-modal');
        

        const playInReverseCheckbox = document.getElementById('play-in-reverse-checkbox'); // NEW
        const nodeNameInput = document.getElementById('node-name');
        const loopCheckbox = document.getElementById('loop-checkbox');
        const speedSlider = document.getElementById('speed-slider');
        const speedValueSpan = document.getElementById('speed-value');
        const saveNodePropertiesButton = document.getElementById('save-node-properties');

        const deleteNodeButton = document.getElementById('delete-node-button');
        const closeNodeModalButtons = nodePropertiesModal.querySelectorAll('.close-button');

        // NEW: Action Node Properties Elements
        const connectionEditorModal = document.getElementById('connection-editor-modal');
        const connectionModalTitle = document.getElementById('connection-modal-title');
        const saveConnectionEditorButton = document.getElementById('save-connection-editor');
        const deleteConnectionButton = document.getElementById('delete-connection-button');
        const closeConnectionEditorButtons = connectionEditorModal.querySelectorAll('.close-button');
            // New DOM element for preview
        const lottiePreviewImage = document.getElementById('lottie-preview-image');
        const actionNodePropertiesContainer = document.getElementById('action-node-properties-container');
        const deleteActionNodeButton = document.getElementById('delete-action-node-button');
        const saveActionNodeProperties = document.getElementById('save-action-node-properties');

        // Connection Editor Modal Elements (New/Modified)

        // Custom Dropdown DOM elements (Node Properties Modal)
        // --- NEW: Global Animation Dropdown Elements ---
        const globalAnimationControls = document.getElementById('global-animation-controls');
        const globalAnimationDisplay = document.getElementById('global-animation-display');
        const globalAnimationOptionsContainer = document.getElementById('global-animation-options');
        const globalAnimationNativeSelect = document.getElementById('global-animation-select');

        const animationDropdownGroup = document.getElementById('animation-dropdown-group');
        const animationDisplay = animationDropdownGroup.querySelector('.custom-dropdown-display');
        const animationOptionsContainer = document.getElementById('animation-options');
        const animationNativeSelect = document.getElementById('animation-select'); // Reference to the hidden native select

        const markerDropdownGroup = document.getElementById('marker-dropdown-group');
        const markerDisplay = markerDropdownGroup.querySelector('.custom-dropdown-display');
        // FIX: Corrected typo in assignment
        const markerOptionsContainer = document.getElementById('marker-options');
        const markerNativeSelect = document.getElementById('marker-select'); // Reference to the hidden native select

        // Custom Dropdown DOM elements (Connection Editor Modal)
        // --- REMOVED: Obsolete transition type dropdown elements ---
        const transitionTypeToggle = document.getElementById('transition-type-toggle'); // NEW
        const interactionPresetDropdownGroup = document.getElementById('interaction-preset-dropdown-group');
        const interactionPresetDisplay = interactionPresetDropdownGroup.querySelector('.custom-dropdown-display');
        const interactionPresetOptionsContainer = document.getElementById('interaction-preset-options');
        const interactionPresetNativeSelect = document.getElementById('interaction-preset-select');

        // Dynamic Interaction Fields
        const dynamicInteractionFields = document.getElementById('dynamic-interaction-fields');
        const loopCountField = document.getElementById('loop-count-field');
        const loopCountInput = document.getElementById('loop-count-input');
        const layerNameField = document.getElementById('layer-name-field');
        const layerNameInput = document.getElementById('layer-name-input');
        const customEventNameField = document.getElementById('custom-event-name-field');
        const editClickAreaButton = document.getElementById('edit-click-area-button');
        const customEventNameInput = document.getElementById('custom-event-name-input');

        // NEW: Tweened Transition Fields
        const tweenedDurationField = document.getElementById('tweened-duration-field');
        const tweenedDurationInput = document.getElementById('tweened-duration-input');
        const tweenedEasingField = document.getElementById('tweened-easing-field');
        const tweenedEasingInput = document.getElementById('tweened-easing-input');

        // NEW: Action Editor Elements
        const actionsSection = document.getElementById('actions-section');
        const actionTypeDropdownGroup = document.getElementById('action-type-dropdown-group');
        //const actionTypeDisplay = actionTypeDropdownGroup.querySelector('.custom-dropdown-display');
        const actionTypeOptionsContainer = document.getElementById('action-type-options');
        const actionTypeNativeSelect = document.getElementById('action-type-select');
        const actionValueField = document.getElementById('action-value-field');
        const actionValueInput = document.getElementById('action-value-input');

        // NEW: Guard Condition Modal Elements
        const guardConditionModal = document.getElementById('guard-condition-modal');
        const guardConditionTypeDropdownGroup = document.getElementById('guard-condition-type-dropdown-group');
        //const guardConditionTypeDisplay = guardConditionTypeDropdownGroup.querySelector('.custom-dropdown-display');
        const guardConditionTypeOptionsContainer = document.getElementById('guard-condition-type-options');
        const guardConditionTypeNativeSelect = document.getElementById('guard-condition-type-select');
        const guardValueInput = document.getElementById('guard-value-input');
        const saveGuardConditionButton = document.getElementById('save-guard-condition');
        const deleteGuardConnectionButton = document.getElementById('delete-guard-connection-button');

        // NEW: Global State Modal Elements
        const globalStatePropertiesContainer = document.getElementById('global-state-properties-container');
        const globalStateNameInput = document.getElementById('global-state-name-input');
        const globalStateTypeDropdownGroup = document.getElementById('global-state-type-dropdown-group');
        const globalStateValueInput = document.getElementById('global-state-value-input');
        const saveGlobalStateButton = document.getElementById('save-global-state');
        const deleteGlobalStateButton = document.getElementById('delete-global-state-button'); // NEW
        const globalStateValueToggle = document.getElementById('global-state-value-toggle'); // NEW
        const globalStateValueToggleSwitch = document.getElementById('global-state-value-toggle-switch'); // NEW
        const globalStateValueInputContainer = document.getElementById('global-state-value-input'); // NEW


        // Ghost line elements
        const ghostConnectionLine = document.getElementById('ghost-connection-line');
        const ghostConnectionArrow = document.getElementById('ghost-connection-arrow');

        // Custom Alert Elements
        const customAlertOverlay = document.getElementById('custom-alert-overlay');
        const customAlertMessage = document.getElementById('custom-alert-message');
        const customAlertOkButton = document.getElementById('custom-alert-ok-button');
        const previewTargetToggle = document.getElementById('preview-target-toggle');

        // Easing Preset Dropdown Elements
        const easingPresetDropdownGroup = document.getElementById('easing-preset-dropdown-group');
        const easingPresetDisplay = document.getElementById('easing-preset-display');
        const easingPresetOptions = document.getElementById('easing-preset-options');

        // Easing Preset Dropdown Logic
        easingPresetDropdownGroup.addEventListener('click', (e) => {
            e.stopPropagation();
            const wasOpen = easingPresetOptions.classList.contains('open');
            closeAllCustomDropdowns();
            if (!wasOpen) {
                easingPresetOptions.classList.add('open');
            }
        });

        easingPresetOptions.addEventListener('click', (e) => {
            const option = e.target.closest('.custom-dropdown-option');
            if (option) {
                e.stopPropagation();
                easingPresetDisplay.textContent = option.textContent;
                const presetValue = option.dataset.value;

                if (presetValue === 'custom') {
                    // If 'custom' is selected, make the input editable.
                    tweenedEasingInput.disabled = false;
                    tweenedEasingInput.style.opacity = '1'; // Revert to full opacity
                } else {
                    // If a preset is selected, make the input read-only and fill it.
                    tweenedEasingInput.disabled = true;
                    tweenedEasingInput.style.opacity = '0.6'; // Make it semi-transparent to indicate disabled state
                    // Remove brackets and join with a comma and space for readability
                    const displayValue = JSON.parse(presetValue).join(', ');
                    tweenedEasingInput.value = displayValue;
                    // --- FIX: Update the temporary connection data when a preset is selected ---
                    if (tempConnectionData) {
                        // Parse the string value from the data attribute back into an array
                        tempConnectionData.easing = JSON.parse(presetValue);
                    }
                    // --- END FIX ---
                }

                easingPresetOptions.classList.remove('open');
            }
        });

        let isDraggingPill = false;
        let draggedConnectionId = null;
        let pillDragOriginNodeEl = null;
        let pillDragDestNodeEl = null;
        let activePillDragPorts = { left: null, right: null };


        let isConnecting = false;
        let isAddingGuard = false; // NEW
        let isRedrawQueued = false; // NEW: Flag to throttle redraws
        let firstNodeSelected = null;
        let firstPortType = null;
        let currentPreviewAnimationData = null; // NEW: To hold the live preview data
        let isCreatingGuardConnection = false; // NEW: Dedicated flag for the new segregated logic
        let panOffsetX = 0, panOffsetY = 0;
        let isPanningCanvas = false;
        let markerCardPlayers = []; // NEW: To hold instances of left-panel players
        let lastMouseX = 0, lastMouseY = 0;

        // NEW: Function to hide/show interactive layers in the preview
        /*function hideInteractionLayers(animationData, shouldHide, validLayerNames) {
            // This function will be implemented later to show/hide interactive layers in the preview.
            return animationData; // Return the (currently unmodified) data
        }*/

        function hideActivePillDragPorts() {
            if (activePillDragPorts.left) {
                // Reset style to let CSS :hover take over again
                activePillDragPorts.left.style.opacity = '';
                activePillDragPorts.left.style.transform = '';
                activePillDragPorts.left = null;
            }
            if (activePillDragPorts.right) {
                // Reset style to let CSS :hover take over again
                activePillDragPorts.right.style.opacity = '';
                activePillDragPorts.right.style.transform = '';
                activePillDragPorts.right = null;
            }
        }

        /**
         * Manually shows a specific port during a pill drag.
         * @param {HTMLElement} portElement - The port element (left or right) to show.
         */
      function showPillDragPort(portElement) {
            if (portElement) {
                // --- ADD THIS LINE ---
                // Override the 0.2s disappear delay for an instant appearance
                portElement.style.transitionDelay = '0s';
                // --- END ADD ---

                // Apply styles to make it visible and pop out
                portElement.style.opacity = '1';
                // Use the same transform as the CSS hover for consistency
                if (portElement.classList.contains('left-port')) {
                    portElement.style.transform = 'scale(1.1) translateX(-6px)';
                    activePillDragPorts.left = portElement;
                } else {
                    portElement.style.transform = 'scale(1.1) translateX(6px)';
                    activePillDragPorts.right = portElement;
                }
            }
        }


        function startPillDrag(e, connection) {
            e.stopPropagation();
            e.preventDefault();
            if (isConnecting || isCreatingGuardConnection || isDraggingPill) return;

            // Find the nodes associated with this connection
            const fromNode = nodes.find(n => n.id === connection.fromNodeId);
            const toNode = nodes.find(n => n.id === connection.toNodeId);

            // Disallow re-wiring if either end is an Action Node
            if (fromNode.type === 'action' || toNode.type === 'action') {
                return;
            }
            document.body.classList.add('body-is-pill-dragging');
            isDraggingPill = true;
            draggedConnectionId = connection.id;
            pillDragOriginNodeEl = document.getElementById(connection.fromNodeId);
            pillDragDestNodeEl = document.getElementById(connection.toNodeId);
            
            // Store the starting mouse position on the text pill element itself
            const textGroup = e.currentTarget;
            textGroup.dataset.didJustDrag = "false";
            textGroup.dataset.dragStartX = e.clientX;
            textGroup.dataset.dragStartY = e.clientY;

            // --- NEW: Show overlay and highlight nodes ---
            const rewireOverlay = document.getElementById('rewire-overlay');
            if (rewireOverlay) {
                rewireOverlay.style.opacity = '1';
            }
            // Set z-index to 51 (higher than the overlay's 50)
            pillDragOriginNodeEl.style.zIndex = '51';
            pillDragDestNodeEl.style.zIndex = '51';
            // --- END NEW ---

            document.body.style.cursor = 'grabbing';
            flowchartArea.style.cursor = 'grabbing';

            document.addEventListener('mousemove', onPillDrag);
            document.addEventListener('mouseup', onPillDrop, { once: true });
        }

        /**
         * Handles the mousemove event during a pill drag.
         */
     function onPillDrag(e) {
            if (!isDraggingPill) return;
            e.preventDefault();
            
            // Find which node (if any) we are hovering over.
            // We only care about the origin and destination nodes.
            let hoveredNodeEl = null;
            
            // We need to check the event target.
            const target = e.target;
            // Find the closest node-wrapper, which could be the node itself or its invisible hover area
            const hoveredWrapper = target.closest('.node-wrapper');

            if (hoveredWrapper === pillDragOriginNodeEl) {
                hoveredNodeEl = pillDragOriginNodeEl;
            } else if (hoveredWrapper === pillDragDestNodeEl) {
                hoveredNodeEl = pillDragDestNodeEl;
            }

            // If we are hovering over one of the valid nodes...
            if (hoveredNodeEl) {
                const nodeRect = hoveredNodeEl.getBoundingClientRect();
                const xRelativeToNode = e.clientX - nodeRect.left;
                const nodeWidth = hoveredNodeEl.offsetWidth;

                const leftPort = hoveredNodeEl.querySelector('.node-port.left-port');
                const rightPort = hoveredNodeEl.querySelector('.node-port.right-port');

                // Determine which port to show
                if (xRelativeToNode < nodeWidth / 2) {
                    // Mouse is on the Left half
                    if (activePillDragPorts.left !== leftPort) {
                        hideActivePillDragPorts(); // Hide previously active ports
                        showPillDragPort(leftPort);
                    }
                } else {
                    // Mouse is on the Right half
                    if (activePillDragPorts.right !== rightPort) {
                        hideActivePillDragPorts(); // Hide previously active ports
                        showPillDragPort(rightPort);
                    }
                }
            } else {
                // We are not hovering over either node, hide any active ports.
                hideActivePillDragPorts();
            }
        }
        /**
         * Handles the mouseup (drop) event to finalize the pill drag.
         */
        function onPillDrop(e) {
            if (!isDraggingPill) return;
            e.stopPropagation();
            e.preventDefault();

            const connectionA = connections.find(c => c.id === draggedConnectionId);
            const textGroup = document.querySelector(`.connection-text-group[data-connection-id="${draggedConnectionId}"]`);

            if (!connectionA || !textGroup) {
                stopPillDrag();
                return;
            }

            // Check if the mouse actually moved (distinguishing a drag from a click)
            const startX = parseFloat(textGroup.dataset.dragStartX || e.clientX);
            const startY = parseFloat(textGroup.dataset.dragStartY || e.clientY);
            const deltaX = Math.abs(e.clientX - startX);
            const deltaY = Math.abs(e.clientY - startY);
            if (deltaX > 5 || deltaY > 5) {
                textGroup.dataset.didJustDrag = "true";
            }

            const droppedOnNodeWrapper = e.target.closest('.node-wrapper');
            let modified = false;

            // Check if the drop target is valid (the origin or destination node)
            if (droppedOnNodeWrapper && (droppedOnNodeWrapper === pillDragOriginNodeEl || droppedOnNodeWrapper === pillDragDestNodeEl)) {
                const nodeRect = droppedOnNodeWrapper.getBoundingClientRect();
                const xRelativeToNode = e.clientX - nodeRect.left;
                const nodeWidth = droppedOnNodeWrapper.offsetWidth;

                // Determine target port based on drop location (left or right half)
                const modifiedPort = (xRelativeToNode < nodeWidth / 2) ? 'left' : 'right';

                let wasOriginModified = false;
                let wasDestinationModified = false;

                // Check if we are modifying the origin port
                if (droppedOnNodeWrapper.id === connectionA.fromNodeId && connectionA.fromPortType !== modifiedPort) {
                    connectionA.fromPortType = modifiedPort;
                    wasOriginModified = true;
                    modified = true;
                // Check if we are modifying the destination port
                } else if (droppedOnNodeWrapper.id === connectionA.toNodeId && connectionA.toPortType !== modifiedPort) {
                    connectionA.toPortType = modifiedPort;
                    wasDestinationModified = true;
                    modified = true;
                }

                if (modified) {
                    // A port was changed, check if this affects a loop
                    const connectionB = connections.find(c => c.fromNodeId === connectionA.toNodeId && c.toNodeId === connectionA.fromNodeId);
                    if (connectionB) {
                        // Yes, this is a loop. We must adapt the *other* connection.
                        if (wasOriginModified) {
                            connectionB.toPortType = getOppositePort(connectionA.fromPortType);
                        }
                        if (wasDestinationModified) {
                            connectionB.fromPortType = getOppositePort(connectionA.toPortType);
                        }

                        // Make the connection we just dragged (A) the "straight" one
                        connectionA.forceCShape = false;
                        // Make the other connection (B) the "curved" one
                        connectionB.forceCShape = true;

                        // Check for the R2R/L2L exception
                        const isR2R_L2L_Loop = (connectionA.fromPortType === 'right' && connectionA.toPortType === 'right' && connectionB.fromPortType === 'left' && connectionB.toPortType === 'left') || (connectionA.fromPortType === 'left' && connectionA.toPortType === 'left' && connectionB.fromPortType === 'right' && connectionB.toPortType === 'right');
                        if (isR2R_L2L_Loop) {
                            // If it's this specific case, *both* connections are straight
                            connectionB.forceCShape = false;
                        }
                    }
                }
            }

            if (modified) {
                redrawAll(); // Redraw the canvas with the new connection path
            }
            stopPillDrag(); // Clean up all drag-related state
        }

        /**
         * Cleans up all variables and listeners after a pill drag operation.
         */
    function stopPillDrag() {
        document.body.classList.remove('body-is-pill-dragging');
            hideActivePillDragPorts(); // Hide any manually shown ports


            isDraggingPill = false;
            draggedConnectionId = null;

            // --- NEW: Hide overlay and reset z-index ---
            const rewireOverlay = document.getElementById('rewire-overlay');
            if (rewireOverlay) {
                rewireOverlay.style.opacity = '0';
            }
            if (pillDragOriginNodeEl) {
                pillDragOriginNodeEl.style.zIndex = ''; // Reset to default
            }
            if (pillDragDestNodeEl) {
                pillDragDestNodeEl.style.zIndex = ''; // Reset to default
            }
            // --- END NEW ---

            pillDragOriginNodeEl = null;
            pillDragDestNodeEl = null;
            
            document.body.style.cursor = 'default';
            if (!isPanningCanvas) {
                flowchartArea.style.cursor = 'default';
            }

            document.removeEventListener('mousemove', onPillDrag);
            // mouseup listener is auto-removed via { once: true }
        }




        function hideInteractionLayers(animationData, layersToModifyNames, shouldHide = true) {
            // 1. Validate inputs to prevent errors.
            if (!animationData || typeof animationData !== 'object') {
                console.error("Invalid animationData provided. It must be a Lottie JSON object.");
                return null;
            }
            if (!Array.isArray(layersToModifyNames)) {
                console.error("Invalid layersToModifyNames provided. It must be an array of strings.");
                return animationData; // Return original data if layer names are invalid
            }

            // 2. Create a deep copy to ensure the original object is not modified.
            const modifiedData = JSON.parse(JSON.stringify(animationData));

            // 3. If there are no layer names to modify, return the pristine copy.
            if (layersToModifyNames.length === 0) {
                return modifiedData;
            }

            // 4. Create a Set for efficient lookup of layer names.
            const layersToModifySet = new Set(layersToModifyNames);

            // 5. Check if the 'layers' property exists and is an array.
            if (modifiedData.layers && Array.isArray(modifiedData.layers)) {
                // 6. Iterate through each layer in the animation.
                modifiedData.layers.forEach(layer => {
                    if (layersToModifySet.has(layer.nm)) {
                        layer.hd = shouldHide;
                    }
                });
            }
            
            // 7. Return the modified data.
            return modifiedData;
        }

        // --- MODIFIED: Moved updateModeUI to the top for proper scope ---
        function updateModeUI() {
            connectModeIndicator.style.display = isConnecting ? 'block' : 'none';
            guardModeIndicator.style.display = 'none'; // This mode is now implicit
            // Hide connection exists indicator when mode changes or connection is established
            connectionExistsIndicator.style.display = 'none';

            connectNodesButton.querySelector('i').className = isConnecting ? 'fas fa-times' : 'fas fa-link';
            connectNodesButton.style.backgroundColor = isConnecting ? '#dc3545' : '#4a90e2';
            connectNodesButton.title = isConnecting ? 'Cancel Connection Mode' : 'Connect Nodes';

            // Ghost line is now only for regular connections
            ghostConnectionLine.style.display = isConnecting ? 'block' : 'none';
            ghostConnectionArrow.style.display = isConnecting ? 'block' : 'none';
            ghostConnectionLine.style.strokeDasharray = '2, 6'; // Dotted for regular connection
            ghostConnectionLine.style.stroke = '#999'; // Default ghost line color

            nodes.forEach(node => {
                const el = document.getElementById(node.id);
                if (el) {
                    const ports = el.querySelectorAll('.node-port');
                    ports.forEach(port => {
                        if (isConnecting) {
                            // In connection mode, ports on all nodes (except the one being hovered for destination highlighting) should be hidden
                            port.style.opacity = '0';
                            port.style.transform = 'scale(0)'; // Reset transform to base scale
                            port.style.pointerEvents = 'none'; // Ensure clicks go to the node itself
                            port.classList.remove('highlighted-destination-port'); // Remove any lingering highlight
                        } else {
                            // Not in connection mode, clear inline styles to let CSS :hover take over
                            port.style.opacity = ''; // Clear inline opacity
                            port.style.transform = ''; // Clear inline transform
                            port.style.pointerEvents = 'all'; // Allow hover to show them
                            port.classList.remove('highlighted-destination-port'); // Ensure no highlight remains
                        }
                    });
                    if (isConnecting) {
                        if (el === firstNodeSelected) {
                            el.classList.add('selected-for-connection');
                        } else {
                            el.classList.remove('selected-for-connection');
                        }
                    } else {
                        el.classList.remove('selected-for-connection');
                    }
                }
            }); // Also handle global state node if it exists
            const globalNodeEl = document.getElementById('global_state_node');

            if (!isConnecting) {
                firstNodeSelected = null;
                firstPortType = null;
                // Ensure any leftover highlighted destination node is cleared
                if (currentHoveredDestinationNode) {
                    currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port');
                    currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port');
                    currentHoveredDestinationNode = null;
                }
            }
        }
        // --- END MODIFIED ---

        function getPortCoordinates(node, portType, offsetIndex = 0, totalConnectionsOnThisSide = 1) {
            let x, y;
            const portHalfSize = PORT_SIZE / 2;
            const edgeOffset = PORT_OFFSET + portHalfSize;
            let baseEdgeX, baseEdgeY;

            // --- NEW: Use node-specific dimensions ---
            const nodeWidth = (node.type === 'action') ? 100 : NODE_WIDTH; // Match new CSS width
            const nodeHeight = (node.type === 'action') ? 100 : NODE_HEIGHT; // Match new CSS height
            // Action nodes should not have the vertical offset.
            const verticalOffset = (node.type === 'action') ? 0 : ConnectionPortOffset;
            // --- END NEW ---

            switch (portType) {
                case 'top':
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y - edgeOffset;
                    break;
                case 'right':
                    baseEdgeX = node.x + nodeWidth + edgeOffset;
                    baseEdgeY = node.y + nodeHeight / 2;
                    break;
                case 'bottom':
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y + nodeHeight + edgeOffset;
                    break;
                case 'left':
                    baseEdgeX = node.x - edgeOffset;
                    baseEdgeY = node.y + nodeHeight / 2;
                    break;
                default:
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y + nodeHeight / 2;
            }

            if (totalConnectionsOnThisSide <= 1) return { x: baseEdgeX, y: baseEdgeY };

            const spacing = 20;
            const itemLength = PORT_SIZE;
            const totalGroupLength = (itemLength * totalConnectionsOnThisSide) + (spacing * (totalConnectionsOnThisSide - 1));
            let offsetFromCenter = -(totalGroupLength / 2) + (itemLength / 2) + (offsetIndex * (itemLength + spacing));

            if (portType === 'top' || portType === 'bottom') {
                x = baseEdgeX + offsetFromCenter;
                y = baseEdgeY;
            } else { // 'left' or 'right'
                x = baseEdgeX;
                y = baseEdgeY + offsetFromCenter; // This offset is for multiple connections, still apply ConnectionPortOffset above
            }
            return { x, y };
        }

        // Function to populate both native and custom dropdowns
        // Function to populate both native and custom dropdowns
        // Function to populate both native and custom dropdowns
        function populateDropdowns(nativeSelectElement, customDisplayElement, customOptionsContainer, optionsData, selectedValue, isDisabled = false) {
           // Clear existing options from native select
           nativeSelectElement.innerHTML = '';
           // Clear existing options from custom dropdown
           customOptionsContainer.innerHTML = '';

           nativeSelectElement.disabled = isDisabled;

           let displayValueFound = false; // Flag to track if the selected value was matched in options

           


           optionsData.forEach(option => {
              let optionValue = option.hasOwnProperty('id') ? option.id : option.name;

               const optionElement = document.createElement('option');
               optionElement.value = optionValue;
               optionElement.textContent = option.name;
               nativeSelectElement.appendChild(optionElement);

               const customOptionElement = document.createElement('div');
               customOptionElement.classList.add('custom-dropdown-option');
               customOptionElement.dataset.value = optionValue;
               customOptionElement.textContent = option.name;
               customOptionsContainer.appendChild(customOptionElement);

               if (optionValue === selectedValue) { // This condition covers both marker (by name) and other (by id)
                    if (customDisplayElement.id === 'global-animation-display') {
                        customDisplayElement.textContent = truncateText(option.name, 12);
                    } else {
                        customDisplayElement.textContent = option.name;
                    }
                   customOptionElement.classList.add('selected');
                   // *** ADDED FIX: Set the native select's value here as well ***
                   nativeSelectElement.value = selectedValue;
                   displayValueFound = true;
               }
           });

           // NEW: Add special "Add/Edit Segments" option to marker dropdown
           if (nativeSelectElement.id === 'marker-select') {
               // NEW: Style the option as a pill-shaped green button
               const addSegmentOption = document.createElement('div');
               // We don't add 'custom-dropdown-option' to avoid default hover effects
               addSegmentOption.dataset.value = 'add_segment_action'; // Special value
               addSegmentOption.innerHTML = '<i class="fas fa-plus" style="margin-right: 8px;"></i> Add Segments';
               Object.assign(addSegmentOption.style, {
                   backgroundColor: '#d4edda', // Pastel green background
                   color: '#155724', // Dark green text for contrast
                   fontWeight: 'bold',
                   fontSize: '14px', // Make text slightly smaller
                   textAlign: 'center',
                   borderRadius: '999px', // Pill shape
                   padding: '10px 14px',
                   margin: '8px 4px 4px 4px', // Add some margin inside the dropdown, more on top
                   cursor: 'pointer',
                   transition: 'background-color 0.2s ease',
                   border: '1px solid #c3e6cb' // Matching pastel green border
               });
               addSegmentOption.onmouseover = () => { addSegmentOption.style.backgroundColor = '#c3e6cb'; };
               addSegmentOption.onmouseout = () => { addSegmentOption.style.backgroundColor = '#d4edda'; };
               customOptionsContainer.appendChild(addSegmentOption);
           }

           // Fallback logic if no matching option was found AND it wasn't handled by the 'Full Animation' logic above
           if (!displayValueFound) {
               if (nativeSelectElement.id === 'marker-select' && optionsData.some(o => o.name === 'Full Animation')) {
                   // If it's the marker select and still no match, default to "Full Animation"
                   customDisplayElement.textContent = 'Full Animation';
                   nativeSelectElement.value = 'Full Animation';
                   customOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                   const fullAnimOption = customOptionsContainer.querySelector('[data-value="Full Animation"]');
                   if (fullAnimOption) {
                       fullAnimOption.classList.add('selected');
                   }
               } else if (nativeSelectElement.options.length > 0) {
                   // For other dropdowns (or marker dropdown without 'Full Animation'), select the first option if no match
                   const firstOptionValue = nativeSelectElement.options[0].value;
                   const firstOptionText = nativeSelectElement.options[0].textContent;
                   nativeSelectElement.value = firstOptionValue;
                    if (customDisplayElement.id === 'global-animation-display') {
                        customDisplayElement.textContent = truncateText(firstOptionText, 20);
                    } else {
                        customDisplayElement.textContent = firstOptionText;
                    }
                   const firstCustomOption = customOptionsContainer.querySelector(`[data-value="${firstOptionValue}"]`);
                   if (firstCustomOption) {
                       firstCustomOption.classList.add('selected');
                   }
               } else {
                   // If no options at all
                   customDisplayElement.textContent = 'No markers found';
                   nativeSelectElement.value = ''; // Ensure native select is also cleared or set to a default empty value
               }
           }
       }

function populateMarkerDropdown(selectedAnimationId, selectedMarkerName) {
    // Get the current animation object based on the selectedAnimationId.
    const currentAnimation = availableAnimations.find(anim => anim.id === selectedAnimationId);

    let markersForDropdown = currentAnimation ? [...currentAnimation.markers] : []; // Start with a copy of the correct animation's markers

    // Generate and add "Frame A to B" marker if selectedMarkerName matches the format
    const newFrameMarker = generateFrameRangeMarker(selectedMarkerName, markersForDropdown);
    if (newFrameMarker) {
        if (!markersForDropdown.some(m => m.name === newFrameMarker.name)) {
            markersForDropdown.push(newFrameMarker);
        }
    }

    markersForDropdown.sort((a, b) => {
        if (a.name === 'Full Animation') return -1;
        if (b.name === 'Full Animation') return 1;
        return a.name.localeCompare(b.name);
    });

    // 3. Populate the Marker Dropdown with the correct markers
    populateDropdowns(
        markerNativeSelect,
        markerDisplay,
        markerOptionsContainer,
        markersForDropdown,
        selectedMarkerName
    );
}

// --- NEW: Function to populate the global animation dropdown ---
function populateGlobalAnimationDropdown() {
    // Set the globalAnimationId to the first animation if it's not already set
    if (!globalAnimationId && availableAnimations.length > 0) {
        globalAnimationId = availableAnimations[0].id;
    }

    const animationOptions = availableAnimations.map(anim => ({ id: anim.id, name: anim.name }));

    populateDropdowns(
        globalAnimationNativeSelect,
        globalAnimationDisplay,
        globalAnimationOptionsContainer,
        animationOptions,
        globalAnimationId
    );

    // After populating, ensure all nodes are synced to the global animation ID
    setGlobalAnimation(globalAnimationId, false); // Don't show alert on initial load
}

    function populateAnimationAndMarkerDropdowns(selectedAnimationId, selectedMarkerName) {
           // 1. Populate Animation Dropdown first.
           // This will set the native select's value and the custom display.
           populateDropdowns(
               animationNativeSelect,
               animationDisplay,
               animationOptionsContainer,
               availableAnimations.map(anim => ({ id: anim.id, name: anim.name })),
               selectedAnimationId // Use the ID passed for the node
           );

           // 2. NOW, get the current animation object based on the selectedAnimationId.
           // This ensures we're looking up the markers for the correct animation of the node being edited.
           const currentAnimation = availableAnimations.find(anim => anim.id === selectedAnimationId);

           let markersForDropdown = currentAnimation ? [...currentAnimation.markers] : []; // Start with a copy of the correct animation's markers

           // Generate and add "Frame A to B" marker if selectedMarkerName matches the format
           const newFrameMarker = generateFrameRangeMarker(selectedMarkerName, markersForDropdown);
           if (newFrameMarker) {
               if (!markersForDropdown.some(m => m.name === newFrameMarker.name)) {
                   markersForDropdown.push(newFrameMarker);
               }
           }

           // 3. Populate the Marker Dropdown with the correct markers
           populateDropdowns(
               markerNativeSelect,
               markerDisplay,
               markerOptionsContainer,
               markersForDropdown,
               selectedMarkerName
           );
       }

        function getOppositePort(portType) {
            if (portType === 'left') return 'right';
            if (portType === 'right') return 'left';
            // Should not happen for current logic, but good to have a fallback
            console.warn("getOppositePort called with unexpected port type:", portType);
            return portType;
        }

        /**
         * Generates an SVG path data string ('d' attribute value) with rounded corners.
         * @param {Array<Object>} points - An array of {x, y} objects representing the path points.
         * @param {number} radius - The desired radius for the rounded corners.
         * @returns {string} The SVG path data string.
         */
        function getRoundedPathD(points, radius) {
            if (points.length < 2) {
                return `M ${points[0].x} ${points[0].y}`;
            }
            if (points.length === 2) {
                return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;
            }

            let d = `M ${points[0].x} ${points[0].y}`;

            for (let i = 1; i < points.length - 1; i++) {
                const p1 = points[i - 1]; // Previous point
                const p2 = points[i];     // Current point (corner)
                const p3 = points[i + 1]; // Next point

                // Calculate vectors from p2 to p1 and p2 to p3
                const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
                const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

                // Calculate lengths
                const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                // Normalize vectors
                const uv1 = { x: v1.x / len1, y: v1.y / len1 };
                const uv2 = { x: v2.x / len2, y: v2.y / len2 };

                // Determine the actual radius to use, limited by half the shortest segment length
                const currentRadius = Math.min(radius, len1 / 2, len2 / 2);

                // Points for the curve start and end
                const p1_curve_end = { x: p2.x + uv1.x * currentRadius, y: p2.y + uv1.y * currentRadius };
                const p3_curve_start = { x: p2.x + uv2.x * currentRadius, y: p2.y + uv2.y * currentRadius };

                // Add line to the start of the curve
                d += ` L ${p1_curve_end.x} ${p1_curve_end.y}`;
                // Add quadratic Bezier curve
                d += ` Q ${p2.x} ${p2.y} ${p3_curve_start.x} ${p3_curve_start.y}`;
            }

            // Add line to the very last point
            d += ` L ${points[points.length - 1].x} ${points[points.length - 1].y}`;

            return d;
        }

        function calculateOrthogonalPathPoints(conn, fromNode, toNode, nodePortConnectionsMap, forceCShape = false) {
            const fromPortData = nodePortConnectionsMap[conn.fromNodeId]?.[conn.fromPortType];
            let allConnectionsOnFromPortSide = fromPortData ? [...(fromPortData.outgoing || []), ...(fromPortData.incoming || [])] : [];
            // OPTIMIZATION: Sort connections by the Y-coordinate of the 'other' node for better visual spreading
            allConnectionsOnFromPortSide.sort((a, b) => {
                const otherNodeA = (a.fromNodeId === fromNode.id) ? nodes.find(n => n.id === a.toNodeId) : nodes.find(n => n.id === a.fromNodeId);
                const otherNodeB = (b.fromNodeId === fromNode.id) ? nodes.find(n => n.id === b.toNodeId) : nodes.find(n => n.id === b.fromNodeId);

                if (!otherNodeA || !otherNodeB) return 0; // Should not happen if data is consistent

                if (a.fromPortType === 'left' || a.fromPortType === 'right') {
                    return otherNodeA.y - otherNodeB.y; // Sort by Y-coordinate for horizontal ports
                } else { // 'top' or 'bottom' ports
                    return otherNodeA.x - otherNodeB.x; // Sort by X-coordinate for vertical ports
                }
            });
            const totalConnectionsForFromPort = allConnectionsOnFromPortSide.length;
            const fromIndex = allConnectionsOnFromPortSide.findIndex(c => c.id === conn.id);
            const p1_coord = getPortCoordinates(fromNode, conn.fromPortType, fromIndex, totalConnectionsForFromPort);

            const toPortData = nodePortConnectionsMap[conn.toNodeId]?.[conn.toPortType];
            let allConnectionsOnToPortSide = toPortData ? [...(toPortData.outgoing || []), ...(toPortData.incoming || [])] : [];
            // OPTIMIZATION: Sort connections by the Y-coordinate of the 'other' node for better visual spreading
            allConnectionsOnToPortSide.sort((a, b) => {
                const otherNodeA = (a.toNodeId === toNode.id) ? nodes.find(n => n.id === a.fromNodeId) : nodes.find(n => n.id === a.toNodeId);
                const otherNodeB = (b.toNodeId === toNode.id) ? nodes.find(n => n.id === b.fromNodeId) : nodes.find(n => n.id === b.toNodeId);

                if (!otherNodeA || !otherNodeB) return 0; // Should not happen if data is consistent

                if (a.toPortType === 'left' || a.toPortType === 'right') {
                    return otherNodeA.y - otherNodeB.y; // Sort by Y-coordinate for horizontal ports
                } else { // 'top' or 'bottom' ports
                    return otherNodeA.x - otherNodeB.x; // Sort by X-coordinate for vertical ports
                }
            });
            const totalConnectionsForToPort = allConnectionsOnToPortSide.length;
            const toIndex = allConnectionsOnToPortSide.findIndex(c => c.id === conn.id);
            const p4_coord = getPortCoordinates(toNode, conn.toPortType, toIndex, totalConnectionsForToPort);

            const pathPoints = [p1_coord]; // Path always starts at the source port coordinate
            const fromPortType = conn.fromPortType;
            const toPortType = conn.toPortType;
            const MIN_ALIGN_DIFF = NODE_WIDTH / 3;
            let pathFound = false;

            //C type for right to right and left to left connections
            
          if (!forceCShape && ((fromPortType === 'right' && toPortType === 'right') || (fromPortType === 'left' && toPortType === 'left'))) {
                // Calculate the vertical distance between the centers of the two nodes.
                const verticalDistance = Math.abs((fromNode.y + NODE_HEIGHT / 2) - (toNode.y + NODE_HEIGHT / 2));
                // Set a threshold. Here, we use 25% of a node's height.
                const verticalThreshold = NODE_HEIGHT * 0.25;

                // ONLY use the C-shape if the nodes are sufficiently far apart vertically.
                // If they are too close, it's better to use the S-bend path to avoid clutter.
                if (verticalDistance > verticalThreshold) {
                    let intermediateX;
                    // Determine the X coordinate for the vertical segment of the "C".
                    if (fromPortType === 'right') {
                        // For right-to-right, the path goes to the right of both nodes.
                        intermediateX = Math.max(fromNode.x + NODE_WIDTH, toNode.x + NODE_WIDTH) + ROUTING_STUB;
                    } else { // fromPortType is 'left'
                        // For left-to-left, the path goes to the left of both nodes.
                        intermediateX = Math.min(fromNode.x, toNode.x) - ROUTING_STUB;
                    }
                    
                    // Define the two corner points of the "C" shape.
                    const p2_corner1 = { x: intermediateX, y: p1_coord.y };
                    const p3_corner2 = { x: intermediateX, y: p4_coord.y };

                    pathPoints.push(p2_corner1, p3_corner2, p4_coord);
                    pathFound = true;
                }
            }
                

            // --- MODIFICATION: Force C-Shape for specific loop-back scenarios (Opposite-facing ports) ---
            if (forceCShape &&
                ( (fromPortType === 'right' && toPortType === 'left') || (fromPortType === 'left' && toPortType === 'right') )
            ) {
                let detourY;
                const marginAboveBelow = NODE_HEIGHT / 2 + ROUTING_STUB;
                // New logic: wrap upwards if fromNode.y < toNode.y, else downwards
                if (fromNode.y < toNode.y) { // Origin is above destination, wrap upwards
                    detourY = Math.min(fromNode.y, toNode.y) - marginAboveBelow;
                } else { // Origin is below or at same level as destination, wrap downwards
                    detourY = Math.max(fromNode.y + NODE_HEIGHT, toNode.y + NODE_HEIGHT) + marginAboveBelow;
                }

                let p2_from_stub_end = { x: p1_coord.x, y: p1_coord.y };
                if (fromPortType === 'left') p2_from_stub_end.x -= ROUTING_STUB;
                else p2_from_stub_end.x += ROUTING_STUB;

                let p4_to_stub_start = { x: p4_coord.x, y: p4_coord.y };
                if (toPortType === 'left') p4_to_stub_start.x -= ROUTING_STUB;
                else p4_to_stub_start.x += ROUTING_STUB;


                pathPoints.length = 0;
                pathPoints.push(p1_coord);
                pathPoints.push(p2_from_stub_end);
                pathPoints.push({ x: p2_from_stub_end.x, y: detourY });
                pathPoints.push({ x: p4_to_stub_start.x, y: detourY });
                pathPoints.push(p4_to_stub_start);
                pathPoints.push(p4_coord);
                pathFound = true;
            }
            // --- END MODIFICATION ---


            if (!pathFound) {
                if ((fromPortType === 'right' && toPortType === 'left' && p4_coord.x > p1_coord.x) ||
                    (fromPortType === 'left' && toPortType === 'right' && p4_coord.x < p1_coord.x)) {
                    const midX = (p1_coord.x + p4_coord.x) / 2;
                    pathPoints.push({ x: midX, y: p1_coord.y });
                    pathPoints.push({ x: midX, y: p4_coord.y });
                    pathPoints.push(p4_coord);
                    pathFound = true;
                } else if ((fromPortType === 'bottom' && toPortType === 'top' && p4_coord.y < p1_coord.y) ||
                           (fromPortType === 'top' && toPortType === 'bottom' && p4_coord.y > p1_coord.y)) {
                    const midY = (p1_coord.y + p4_coord.y) / 2;
                    pathPoints.push({ x: p1_coord.x, y: midY });
                    pathPoints.push({ x: p4_coord.x, y: midY });
                    pathPoints.push(p4_coord);
                    pathFound = true;
                }
            }

            if (!pathFound) {
                let p_bend = null;
                if ((fromPortType === 'left' || fromPortType === 'right') && (toPortType === 'top' || toPortType === 'bottom')) {
                     p_bend = {x: p4_coord.x, y: p1_coord.y};
                } else if ((fromPortType === 'top' || fromPortType === 'bottom') && (toPortType === 'left' || toPortType === 'right')) {
                     p_bend = {x: p1_coord.x, y: p4_coord.y};
                }
                if (p_bend) {
                    pathPoints.push(p_bend);
                    pathPoints.push(p4_coord);
                    pathFound = true;
                }
            }

            if (!pathFound) {
                let p2 = { x: p1_coord.x, y: p1_coord.y };
                if (fromPortType === 'left') p2.x -= ROUTING_STUB;
                else if (fromPortType === 'right') p2.x += ROUTING_STUB;
                else if (fromPortType === 'top') p2.y -= ROUTING_STUB;
                else if (fromPortType === 'bottom') p2.y += ROUTING_STUB;
                pathPoints.push(p2);

                let p3_target_stub = { x: p4_coord.x, y: p4_coord.y };
                if (toPortType === 'left') p3_target_stub.x -= ROUTING_STUB;
                else if (toPortType === 'right') p3_target_stub.x += ROUTING_STUB;
                else if (toPortType === 'top') p3_target_stub.y -= ROUTING_STUB;
                else if (toPortType === 'bottom') p3_target_stub.y += ROUTING_STUB;

                const S_C_THRESHOLD = NODE_WIDTH;
                const C_DETOUR_OFFSET = ROUTING_STUB * 3 + NODE_HEIGHT / 2; // Increased multiplier for more space

                // New logic for detourDirection based on fromNode.y vs toNode.y
                let detourDirection = (fromNode.y < toNode.y) ? -1 : 1; // -1 for upwards, 1 for downwards

                if (fromPortType === 'left' || fromPortType === 'right') {
                    let midY;
                    const H_effective = Math.abs(p1_coord.y - p4_coord.y);
                    if (H_effective > S_C_THRESHOLD &&
                        !((fromPortType === 'left' && p2.x > p3_target_stub.x) || (fromPortType === 'right' && p2.x < p3_target_stub.x))
                       ) {
                        midY = (p2.y + p3_target_stub.y) / 2;
                    } else {
                        midY = (p2.y + p3_target_stub.y) / 2 + detourDirection * C_DETOUR_OFFSET;
                        if (fromPortType === 'left' && toPortType === 'right' && H_effective <= S_C_THRESHOLD) {
                             midY = p1_coord.y - (H_effective/2 + ROUTING_STUB * 2);
                        }
                    }
                    pathPoints.push({ x: p2.x, y: midY });
                    pathPoints.push({ x: p3_target_stub.x, y: midY });
                } else {
                    let midX;
                    const X_effective = Math.abs(p1_coord.x - p4_coord.x);
                    if (X_effective > S_C_THRESHOLD &&
                        !((fromPortType === 'top' && p2.y > p3_target_stub.y) || (fromPortType === 'bottom' && p2.y < p3_target_stub.y))
                        ) {
                        midX = (p2.x + p3_target_stub.x) / 2;
                    } else {
                        midX = (p2.x + p3_target_stub.x) / 2 + detourDirection * C_DETOUR_OFFSET;
                    }
                    pathPoints.push({ x: midX, y: p2.y });
                    pathPoints.push({ x: midX, y: p3_target_stub.y });
                }
                pathPoints.push(p3_target_stub);
                pathPoints.push(p4_coord);
            }

            // Filter out consecutive duplicate points, which can cause issues with path rendering
            return pathPoints.filter((point, i, arr) => {
                if (i === 0) return true;
                const prev = arr[i-1];
                if (point.x === prev.x && point.y === prev.y) return false;
                // Also filter out redundant intermediate points that are collinear
                if (i > 1) {
                    const prevPrev = arr[i-2];
                    // Check if prev is directly between prevPrev and current point (collinear)
                    // This is a simplified check for orthogonal lines
                    const isCollinearX = (point.x === prev.x && prev.x === prevPrev.x);
                    const isCollinearY = (point.y === prev.y && prev.y === prevPrev.y);
                    if (isCollinearX || isCollinearY) {
                        // Keep the point if it's the last one, to ensure the path reaches its destination
                        if (i === arr.length -1) return true;
                        return false;
                    }
                }
                return true;
            });
        }


        function fitCanvasToNodesMinimally() {
            let minOverallX = Infinity, minOverallY = Infinity;
            let maxOverallX = -Infinity, maxOverallY = -Infinity;

            if (nodes.length === 0 && connections.length === 0) {
                minOverallX = 0; minOverallY = 0;
                maxOverallX = DEFAULT_MIN_CANVAS_WIDTH; maxOverallY = DEFAULT_MIN_CANVAS_HEIGHT;
            } else {
                 if (nodes.length > 0) {
                    nodes.forEach(node => {
                        minOverallX = Math.min(minOverallX, node.x);
                        minOverallY = Math.min(minOverallY, node.y);
                        maxOverallX = Math.max(maxOverallX, node.x + NODE_WIDTH);
                        maxOverallY = Math.max(maxOverallY, node.y + NODE_HEIGHT);
                    });
                } else { // Only connections exist
                    minOverallX = 0; minOverallY = 0;
                    maxOverallX = 0; maxOverallY = 0; // Will be expanded by connection paths
                }

                // NEW: Include the global state node in the bounds calculation
                if (globalState) {
                    const GLOBAL_NODE_SIZE = 120; // As defined in CSS
                    minOverallX = Math.min(minOverallX, globalState.x);
                    minOverallY = Math.min(minOverallY, globalState.y);
                    maxOverallX = Math.max(maxOverallX, globalState.x + GLOBAL_NODE_SIZE);
                    maxOverallY = Math.max(maxOverallY, globalState.y + GLOBAL_NODE_SIZE);
                }


                const tempNodePortConnections = {};
                 connections.forEach(conn => {
                    if (!tempNodePortConnections[conn.fromNodeId]) tempNodePortConnections[conn.fromNodeId] = {};
                    if (!tempNodePortConnections[conn.fromNodeId][conn.fromPortType]) tempNodePortConnections[conn.fromNodeId][conn.fromPortType] = { outgoing: [], incoming: [] };
                    tempNodePortConnections[conn.fromNodeId][conn.fromPortType].outgoing.push(conn);

                    if (!tempNodePortConnections[conn.toNodeId]) tempNodePortConnections[conn.toNodeId] = {};
                    if (!tempNodePortConnections[conn.toNodeId][conn.toPortType]) tempNodePortConnections[conn.toNodeId][conn.toPortType] = { outgoing: [], incoming: [] };
                    tempNodePortConnections[conn.toNodeId][conn.toPortType].incoming.push(conn);
                });


                connections.forEach(conn => {
                    const fromNode = nodes.find(n => n.id === conn.fromNodeId);
                    const toNode = nodes.find(n => n.id === conn.toNodeId);
                    if (fromNode && toNode) {
                        // Determine actual forceCShape for bounding box calculation
                        let actualForceCShapeForBounds = conn.forceCShape;
                        const pairedConnection = connections.find(pConn =>
                            pConn.fromNodeId === conn.toNodeId && pConn.toNodeId === conn.fromNodeId
                        );
                        if (pairedConnection) {
                            if (conn.forceCShape === true) {
                                const pairedPathPointsForBounds = calculateOrthogonalPathPoints(
                                    pairedConnection, toNode, fromNode, tempNodePortConnections, false
                                );
                                if (isPathNaturallyCShape(pairedPathPointsForBounds, pairedConnection, toNode, fromNode)) {
                                    actualForceCShapeForBounds = false;
                                } else {
                                    actualForceCShapeForBounds = true;
                                }
                            } else {
                                actualForceCShapeForBounds = false;
                            }
                        }

                        const path = calculateOrthogonalPathPoints(conn, fromNode, toNode, tempNodePortConnections, actualForceCShapeForBounds);
                        path.forEach(point => {
                            minOverallX = Math.min(minOverallX, point.x);
                            minOverallY = Math.min(minOverallY, point.y);
                            maxOverallX = Math.max(maxOverallX, point.x);
                            maxOverallY = Math.max(maxOverallY, point.y);
                        });
                    }
                });
                if (nodes.length === 0 && connections.length > 0 && minOverallX === Infinity) { // No valid connections to draw, use defaults
                    minOverallX = 0; minOverallY = 0; maxOverallX = DEFAULT_MIN_CANVAS_WIDTH; maxOverallY = DEFAULT_MIN_CANVAS_HEIGHT;
                }
            }

            let shiftX = -minOverallX + MINIMAL_CANVAS_EDGE_PADDING;
            let shiftY = -minOverallY + MINIMAL_CANVAS_EDGE_PADDING;

            let targetPanX = panOffsetX - shiftX;
            let targetPanY = panOffsetY - shiftY;

            let contentWidth = (maxOverallX - minOverallX) + MINIMAL_CANVAS_EDGE_PADDING * 2;
            let contentHeight = (maxOverallY - minOverallY) + MINIMAL_CANVAS_EDGE_PADDING * 2;

            let targetCanvasWidth = Math.max(DEFAULT_MIN_CANVAS_WIDTH, contentWidth)+ EXTRA_RIGHT_PANNING_SPACE;
            let targetCanvasHeight = Math.max(DEFAULT_MIN_CANVAS_HEIGHT, contentHeight);

            const faWidth = flowchartArea.offsetWidth;
            const faHeight = flowchartArea.offsetHeight;

            if (targetCanvasWidth <= faWidth) targetPanX = Math.max(0, Math.min(targetPanX, faWidth - targetCanvasWidth));
            else targetPanX = Math.max(faWidth - targetCanvasWidth, Math.min(targetPanX, 0));
            if (targetCanvasHeight <= faHeight) targetPanY = Math.max(0, Math.min(targetPanY, faHeight - targetCanvasHeight));
            else targetPanY = Math.max(faHeight - targetCanvasHeight, Math.min(targetPanY, 0));

            canvasContainer.style.transition = 'none';
            canvasContainer.style.left = `${targetPanX}px`; canvasContainer.style.top = `${targetPanY}px`;
            canvasContainer.style.width = `${targetCanvasWidth}px`; canvasContainer.style.height = `${targetCanvasHeight}px`;

            panOffsetX = targetPanX; panOffsetY = targetPanY;

            if (nodes.length > 0) {
                nodes.forEach(node => {
                    node.x += shiftX; node.y += shiftY;
                    const el = document.getElementById(node.id);
                    if (el) { el.style.transition = 'none'; el.style.left = `${node.x}px`; el.style.top = `${node.y}px`; }
                });
            }
            // --- FIX START: Apply the same shift to the global state node ---
            if (globalState) {
                globalState.x += shiftX;
                globalState.y += shiftY;
                const el = document.getElementById(globalState.id);
                if (el) {
                    el.style.transition = 'none';
                    el.style.left = `${globalState.x}px`;
                    el.style.top = `${globalState.y}px`;
                }
            }
            // --- FIX END ---
            redrawAll();
        }

        function updateNodeStyles() {
            nodes.forEach(node => {
                const nodeElement = document.getElementById(node.id)?.querySelector('.node');
                if (nodeElement) {
                    // Remove both active and initial classes first
                    nodeElement.classList.remove('active', 'initial-node');

                    // Apply 'active' class if node.isActive is true
                    if (node.isActive) {
                        nodeElement.classList.add('active');
                    }
                    // Apply 'initial-node' class if node.isInitial is true
                    if (node.isInitial) {
                        nodeElement.classList.add('initial-node');
                    }
                }
            });
        }


        function createNodeElement(nodeData) {
            // --- NEW: Create a wrapper for the node and its hover area ---
            const nodeWrapper = document.createElement('div');
            nodeWrapper.id = nodeData.id; // The ID now goes on the wrapper
            nodeWrapper.classList.add('node-wrapper'); // A class for potential future styling
            nodeWrapper.style.position = 'absolute';

            const nodeElement = document.createElement('div');
            // --- NEW: Handle Action Node type ---
            if (nodeData.type === 'action') {
                // Add a display div for the action text/icon
                const actionDisplay = document.createElement('div');
                actionDisplay.classList.add('action-node-display');
                nodeElement.appendChild(actionDisplay);
                // Call a function to update its content
                updateActionNodeVisual(nodeElement, nodeData);

                nodeElement.classList.add('action-node');
            }
            // --- END NEW ---
            nodeElement.classList.add('node');
            // --- NEW: Add entrance animation ---
            if (!nodeData.wasImported) { // Only animate newly created nodes
                nodeElement.classList.add('entering');
                // Remove the class after the animation completes to prevent re-triggering
                setTimeout(() => nodeElement.classList.remove('entering'), 350);
            }

            // Apply initial-node class if it's the initial node
                        if (nodeData.isInitial) {
                            nodeElement.classList.add('initial-node');
                        }

            if (nodeData.isActive) {
                nodeElement.classList.add('active');
            }
            // --- MODIFIED: Positioning is now on the wrapper ---
            nodeWrapper.style.left = `${nodeData.x}px`;
            nodeWrapper.style.top = `${nodeData.y}px`;
            nodeWrapper.style.transition = 'none';
            // The node itself is positioned relative to the wrapper
            nodeElement.style.position = 'relative';

            const titleSpan = document.createElement('div'); titleSpan.classList.add('node-title'); titleSpan.textContent = nodeData.name; nodeElement.appendChild(titleSpan);
            const detailsSpan = document.createElement('div'); detailsSpan.classList.add('node-details'); nodeElement.appendChild(detailsSpan);
            updateNodeDetailsChips(nodeElement, nodeData);
            const editIcon = document.createElement('div'); editIcon.classList.add('edit-node-icon'); editIcon.innerHTML = '<i class="fas fa-cog"></i>'; nodeElement.appendChild(editIcon);
            const portTypes = ['top', 'right', 'bottom', 'left'];
            portTypes.forEach(type => {
                const port = document.createElement('div');
                port.classList.add('node-port', `${type}-port`); port.dataset.nodeId = nodeWrapper.id; port.dataset.portType = type;
                nodeElement.appendChild(port);                

                // --- NEW: Drag-to-connect logic ---
                if (nodeData.type !== 'action' && (type === 'left' || type === 'right')) {
                    port.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        // Start connection mode
                        isConnecting = true;
                        firstNodeSelected = nodeWrapper;
                        firstPortType = type;
                        updateModeUI();
                        connectModeIndicator.textContent = `Drag to a target node to connect.`;

                        // Immediately draw the ghost line to the current cursor position
                        const canvasRect = canvasContainer.getBoundingClientRect();
                        const initialSvgMouseX = e.clientX - canvasRect.left; 
                        const initialSvgMouseY = e.clientY - canvasRect.top; 
                        drawGhostLine(firstNodeSelected.id, firstPortType, initialSvgMouseX, initialSvgMouseY); 

                        const onDragEnd = (upEvent) => {
                            // Check if the mouse is released over a valid target node
                            const targetNodeWrapper = upEvent.target.closest('.node-wrapper');
                            if (targetNodeWrapper && targetNodeWrapper !== firstNodeSelected) {
                                const clickXRelativeToNode = upEvent.clientX - targetNodeWrapper.getBoundingClientRect().left;
                                const toPortType = (clickXRelativeToNode < NODE_WIDTH / 2) ? 'left' : 'right';
                                addConnection(firstNodeSelected.id, firstPortType, targetNodeWrapper.id, toPortType);
                            }

                            // Cleanup: End connection mode and remove listeners
                            isConnecting = false;
                            updateModeUI();
                            document.removeEventListener('mouseup', onDragEnd);
                        }

                        // Add a one-time mouseup listener to the document to handle release
                        document.addEventListener('mouseup', onDragEnd, { once: true });
                    });
                }
            });
            let isDraggingNode = false, offsetX, offsetY;
            nodeWrapper.addEventListener('mousedown', (e) => {
                // Prevent dragging if clicking edit icon, port, or detail chip
                if (e.target.closest('.edit-node-icon, .node-port, .node-detail-chip')) return;
                if (isConnecting) return;

                isDraggingNode = true; canvasContainer.style.transition = 'none'; nodeWrapper.style.transition = 'none';
                offsetX = e.clientX - nodeWrapper.getBoundingClientRect().left; offsetY = e.clientY - nodeWrapper.getBoundingClientRect().top;
                nodeWrapper.style.cursor = 'grabbing'; e.preventDefault(); e.stopPropagation();
            });
            document.addEventListener('mousemove', (e) => {
                if (!isDraggingNode || !nodeWrapper.parentNode) return;
                let newX = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX;
                let newY = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY;
                nodeWrapper.style.left = `${newX}px`;
                nodeWrapper.style.top = `${newY}px`;
                nodeData.x = newX;
                nodeData.y = newY;
                // Throttled redraw using requestAnimationFrame
                if (!isRedrawQueued) {
                    isRedrawQueued = true;
                    requestAnimationFrame(() => {
                        redrawAll();
                        isRedrawQueued = false;
                    });
                }
            });
            document.addEventListener('mouseup', () => {
                if (isDraggingNode) { isDraggingNode = false; nodeWrapper.style.cursor = 'grab'; fitCanvasToNodesMinimally(); }
            });
            nodeWrapper.addEventListener('click', (e) => {
                e.stopPropagation();
                if (nodeData.type !== 'action' && !isCreatingGuardConnection) {
          openNodePropertiesModal(nodeData);
      } else if (nodeData.type === 'action' && !isCreatingGuardConnection) {
          openActionNodePropertiesModal(nodeData);
      }
            });
nodeWrapper.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                
                // --- NEW: Check node type ---
                if (nodeData.type === 'action') {
                    openActionNodePropertiesModal(nodeData); // Call the correct modal
                } else {
                    openNodePropertiesModal(nodeData); // Call the state node modal
                }
                // --- END NEW ---

                isConnecting = false;
                updateModeUI();

                // ADDED LOGIC: Check if state preview window is hidden and simulate click
                if (statePreviewWindow.classList.contains('hidden')) {
                    previewToggleButton.click(); // Simulate a click on the toggle button
                }
            });
            editIcon.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (nodeData.type === 'action') {
                    openActionNodePropertiesModal(nodeData);
                } else {
                    openNodePropertiesModal(nodeData);
                }
                isConnecting = false; updateModeUI(); 
            });
            nodeWrapper.appendChild(nodeElement);
           

            // --- FIX: Only auto-click to open properties for newly created nodes ---
            if (!nodeData.wasImported) {
                nodeWrapper.click();
            }

            return nodeWrapper;


        }

        function addNode(nodeData = null) {
            let newNodeName = nodeData ? nodeData.name : (nodes.length === 0 ? 'Idle' : 'New State');
            let counter = 1;
            const baseName = newNodeName;
            // Ensure initial name is unique if it's a default one
            if (!nodeData || (nodeData && nodeData.name === 'New State')) { // Only check for default "New State" or if no data
                 while (nodes.some(n => n.name === newNodeName)) {
                    newNodeName = `${baseName} ${counter++}`;
                }
            }


            const initialX = -panOffsetX + MINIMAL_CANVAS_EDGE_PADDING + 50 + (nodes.length * 10);
            const initialY = -panOffsetY + MINIMAL_CANVAS_EDGE_PADDING + 50 + (nodes.length * 10);

            // --- REVISED LOGIC ---
            // Define all default properties for a new node.
            const defaultNodeProperties = {
                id: generateId(),
                x: initialX,
                y: initialY,
                animationId: globalAnimationId || availableAnimations[0]?.id || '',
                marker: '',
                playInReverse: false,
                action: null,
                loop: false, 
                speed: 1.0,
                isActive: true,
                autoplay: true,
                wasImported: !!nodeData, // Flag for animation if data is passed
                broadcastOnEntry: false,
                broadcastOnExit: false,
                isInitial: false,
            };

            // If nodeData is provided (e.g., from drag-drop or import),
            // merge it with the defaults. Provided data takes precedence.
            // The unique name is already calculated, so we add it here.
            const newNode = { ...defaultNodeProperties, ...nodeData, name: newNodeName };
        
            // Deactivate all other nodes because this new one will be active.
            nodes.forEach(n => {
                n.isActive = false;
                // If the new node is being set as initial, unset others.
                if (newNode.isInitial) {
                    n.isInitial = false;
                }
            });

            // If no node is initial after that process (e.g., first node added), make this one initial.
            if (!nodes.some(n => n.isInitial) && !newNode.isInitial) {
                newNode.isInitial = true;
            }
            // --- END REVISED LOGIC ---

            nodes.push(newNode);
            canvasContainer.appendChild(createNodeElement(newNode));
            fitCanvasToNodesMinimally();
            updateModeUI();
            updateNodeStyles();

            // --- NEW: Simulate re-selecting the global animation ---
            // This ensures the new node (and all others) are correctly synced
            // to the global animation, especially regarding markers.
            const currentlySelectedAnimationId = globalAnimationNativeSelect.value;
            if (currentlySelectedAnimationId) setGlobalAnimation(currentlySelectedAnimationId, false);
        }

       function addActionNode() {
            // Deactivate any other active nodes first
            nodes.forEach(n => n.isActive = false);
            updateNodeStyles();

            // --- Generate a unique name for the action node ---
            let newNodeName = 'Action';
            let counter = 1;
            // Check against all existing nodes (states and actions) for a unique name
            while (nodes.some(n => n.name === newNodeName)) {
                newNodeName = `Action ${counter++}`;
            }

            // --- Smart positioning for the action node ---
            let initialX, initialY;
            if (nodes.length > 0) {
                let maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    maxX = Math.max(maxX, node.x + NODE_WIDTH);
                    minY = Math.min(minY, node.y);
                    maxY = Math.max(maxY, node.y + NODE_HEIGHT);
                });

                const ACTION_NODE_HEIGHT = 100;
                const OFFSET_FROM_NODES = 60;

                initialX = maxX + OFFSET_FROM_NODES;
                initialY = (minY + maxY) / 2 - (ACTION_NODE_HEIGHT / 2);
            } else {
                // Fallback to default position if no nodes exist
                initialX = -panOffsetX + 200;
                initialY = -panOffsetY + 200;
            }

            // --- START FIX: Create a valid default action array ---
            let defaultActionArray = [];
            if (globalState && globalState.inputs && globalState.inputs.length > 0) {
                // Get the first global variable
                const firstVariable = globalState.inputs[0];
                let defaultActionType = '';

                // Assign a default action based on its type
                if (firstVariable.type === 'Numeric') {
                    defaultActionType = 'Increment';
                } else if (firstVariable.type === 'Boolean') {
                    defaultActionType = 'Toggle';
                }

                // Create the action object with the variableId
                if (defaultActionType) {
                    defaultActionArray.push({
                        variableId: firstVariable.id,
                        type: defaultActionType,
                        value: (defaultActionType === 'Increment') ? '1' : ''
                    });
                }
            }
            // --- END FIX ---

            const newNode = { 
                id: generateId(), 
                name: newNodeName, // Add the unique name
                type: 'action', 
                x: initialX, y: initialY,
                action: defaultActionArray, // <-- Use the new array
                isActive: true // Set the new node to be active
            };
            nodes.push(newNode);
            // The createNodeElement function will automatically trigger a click, which opens the properties panel.
            canvasContainer.appendChild(createNodeElement(newNode));
        }

        function updateNodeDetailsChips(nodeElement, nodeData) {
          const detailsSpan = nodeElement.querySelector('.node-details'); detailsSpan.innerHTML = '';
          // --- MODIFIED: Show segment name instead of animation name ---
          const segmentChip = document.createElement('span');
          segmentChip.classList.add('node-detail-chip', 'chip-animation'); // Keep class for styling
          const segmentName = nodeData.marker ? nodeData.marker : 'Full Animation';
          segmentChip.innerHTML = `<i class="fas fa-play-circle"></i> ${segmentName}`;
          detailsSpan.appendChild(segmentChip);

          // Use node.marker for the marker chip
          if (nodeData.marker) {
              const markerChip = document.createElement('span');
              markerChip.classList.add('node-detail-chip', 'chip-marker'); // New class for marker chip
              markerChip.innerHTML = `<i class="fas fa-bookmark"></i> ${nodeData.marker}`;
              detailsSpan.appendChild(markerChip);
          }

            // --- NEW LOGIC: Check for freeze frame first ---
            // nodeData.autoplay is false when the freeze toggle is on.
            if (nodeData.autoplay === false) {
                const freezeChip = document.createElement('span');
                freezeChip.classList.add('node-detail-chip', 'chip-freeze'); // New class for styling
                freezeChip.innerHTML = `<i class="fas fa-snowflake"></i> Frozen at first frame`;
                detailsSpan.appendChild(freezeChip);
            } else {
                // --- Original Loop Logic ---
                const loopChip = document.createElement('span');
                loopChip.classList.add('node-detail-chip', 'chip-loop');
                let loopText = 'Plays Once'; 
                if (typeof nodeData.loop === 'number' && nodeData.loop > 0) {
                    loopText = `Loops ${nodeData.loop} times`;
                } else if (nodeData.loop === true) {
                    loopText = 'Loops Indefinitely';
                }
                loopChip.innerHTML = `<i class="fas fa-sync-alt"></i> ${loopText}`;
                detailsSpan.appendChild(loopChip);
            }
      }

        function updateNodeElement(nodeData) {
            const nodeElement = document.getElementById(nodeData.id)?.querySelector('.node');
            if (nodeElement) {
                nodeElement.querySelector('.node-title').textContent = nodeData.name;
                updateNodeDetailsChips(nodeElement, nodeData);
                fitCanvasToNodesMinimally();
                updateNodeStyles();
            }
        }

        // NEW: Function to update the visual display of an action node
      function updateActionNodeVisual(nodeElement, nodeData) {
            const displayElement = nodeElement.querySelector('.action-node-display');
            if (!displayElement) return;

            // 1. Clear previous content and reset state
            displayElement.innerHTML = '';
            nodeElement.classList.remove('no-action');
            displayElement.classList.remove('single-action-layout');
            removeUrlIndicatorIcon(nodeElement); // Remove corner icon

            // 2. Get all active variable actions
            const activeVariableActions = [];
            if (globalState && Array.isArray(nodeData.action)) {
                nodeData.action
                    .filter(a => a.type && a.type !== '')
                    .forEach(action => {
                        const variable = globalState.inputs.find(v => v.id === action.variableId);
                        if (variable) {
                            activeVariableActions.push({
                                variableName: variable.name,
                                type: action.type,
                                value: action.value
                            });
                        }
                    });
            }

            // 3. Check for URL action
            const hasUrlAction = nodeData.openUrlAction && nodeData.openUrlAction.url;

            // 4. Get total action count
            const totalActionCount = activeVariableActions.length + (hasUrlAction ? 1 : 0);

            // 5. Render based on logic
            if (totalActionCount === 0) {
                // --- CASE 4: No actions ---
                displayElement.textContent = 'No Action Set';
                nodeElement.classList.add('no-action');
                return;
            }

            if (totalActionCount === 1 && hasUrlAction) {
                // --- CASE 1: URL Action ONLY ---
                displayElement.classList.add('single-action-layout');
                
                const symbolEl = document.createElement('div');
                symbolEl.className = 'action-node-symbol-large';
                // Use a globe icon
                symbolEl.innerHTML = `<i class="fas fa-globe" style="font-size: 18px;"></i>`;
                
                const variablePillEl = document.createElement('div');
                variablePillEl.className = 'action-node-variable-pill-large';
                // The pill contains the truncated URL
                const truncatedUrl = truncateText(nodeData.openUrlAction.url.replace(/^https?:\/\//, ''), 20);
                variablePillEl.textContent = truncatedUrl;
                variablePillEl.title = nodeData.openUrlAction.url;
                // Style the URL pill differently
                variablePillEl.style.backgroundColor = '#e0f2f1'; // A light teal
                variablePillEl.style.color = '#00796b';
                variablePillEl.style.borderColor = '#b2dfdb';

                displayElement.appendChild(symbolEl);
                displayElement.appendChild(variablePillEl);
                return;
            }

            // --- CASE 2 & 3: Variable Action(s) are present ---
            // The display will be based on variable actions.
            // We just need to check if we also need to add the corner icon.
            
            if (hasUrlAction) {
                // --- This is Case 3 ---
                addUrlIndicatorIcon(nodeElement);
            }

            // --- This is Case 2 (and 3's main display) ---
            if (activeVariableActions.length === 1) {
                // --- A. SINGLE Variable Action Layout ---
                displayElement.classList.add('single-action-layout');
                const action = activeVariableActions[0];

                // Get the action text (symbol + number)
                let actionText = '';
                switch (action.type) {
                    case 'Increment': actionText = ` +${action.value || 1}`; break;
                    case 'Decrement': actionText = ` -${action.value || 1}`; break;
                    case 'SetNumeric': actionText = ` ${action.value}`; break;
                    case 'SetBoolean': actionText = (action.value === 'true' || action.value === true) ? ' true' : ' false'; break;
                    case 'Toggle': actionText = ' Toggle'; break;
                    default: actionText = '...';
                }

                // Create the large symbol element (using the original style)
                const symbolEl = document.createElement('div');
                symbolEl.className = 'action-node-symbol-large';
                symbolEl.textContent = actionText;

                // Create the variable pill element
                const variablePillEl = document.createElement('div');
                variablePillEl.className = 'action-node-variable-pill-large';
                variablePillEl.textContent = action.variableName;
                variablePillEl.title = action.variableName;

                displayElement.appendChild(symbolEl);
                displayElement.appendChild(variablePillEl);

            } else {
                // --- B. MULTI-Variable Action Layout ---
                const pillsToShow = Math.min(activeVariableActions.length, 2);

                for (let i = 0; i < pillsToShow; i++) {
                    const action = activeVariableActions[i];
                    
                    let actionText = '';
                    switch (action.type) {
                        case 'Increment': actionText = ` +${action.value || 1}`; break;
                        case 'Decrement': actionText = ` -${action.value || 1}`; break;
                        case 'SetNumeric': actionText = ` ${action.value}`; break;
                        case 'SetBoolean': actionText = (action.value === 'true' || action.value === true) ? ' true' : ' false'; break;
                        case 'Toggle': actionText = ' Toggle'; break;
                        default: actionText = '...';
                    }
                    
                    const pill = document.createElement('div');
                    pill.className = 'action-node-pill';
                    
                    pill.innerHTML = `<span class="variable-pill">${truncateText(action.variableName, 12)}</span> ${actionText}`; 
                    pill.title = `[${action.variableName}] ${actionText}`; 

                    displayElement.appendChild(pill);
                }

                // Handle overflow text
                if (activeVariableActions.length > 2) {
                    const moreCount = activeVariableActions.length - 2;
                    const overflowEl = document.createElement('div');
                    overflowEl.className = 'action-node-overflow-text';
                    overflowEl.textContent = `+${moreCount} more`;
                    displayElement.appendChild(overflowEl);
                }
            }
        }

        function addUrlIndicatorIcon(nodeElement) {
            // Check if an icon already exists
            if (nodeElement.querySelector('.action-node-url-indicator')) {
                return; // Already present
            }
            const icon = document.createElement('i');
            icon.className = 'fas fa-globe action-node-url-indicator';
            nodeElement.appendChild(icon);
        }

        function removeUrlIndicatorIcon(nodeElement) {
            const icon = nodeElement.querySelector('.action-node-url-indicator');
            if (icon) {
                icon.remove();
            }
        }


        function deleteNode(nodeId) {
            const nodeWrapper = document.getElementById(nodeId); if (nodeWrapper) nodeWrapper.remove();
             const deletedNode = nodes.find(node => node.id === nodeId);
            nodes = nodes.filter(node => node.id !== nodeId);
            connections = connections.filter(conn => conn.fromNodeId !== nodeId && conn.toNodeId !== nodeId);


            // --- NEW: Logic to find and display the next active node ---
            let nextActiveNode = null;

            if (deletedNode && deletedNode.isInitial) {
                // If the deleted node was the initial node, find a new one (must be a state node)
                const firstStateNode = nodes.find(n => n.type !== 'action');
                if (firstStateNode) {
                    firstStateNode.isInitial = true;
                }
            }

            // If the deleted node was the active one, or if no node is active, find a new active node.
            if ((deletedNode && deletedNode.isActive) || !nodes.some(n => n.isActive)) {
                if (nodes.length > 0) {
                    // Prefer selecting a state node over an action node as the next active one.
                    nextActiveNode = nodes.find(n => n.type !== 'action') || nodes[0];
                }
            } else {
                // An active node already exists, find it.
                nextActiveNode = nodes.find(n => n.isActive);
            }

            fitCanvasToNodesMinimally();

            if (nextActiveNode) {
                // Open the properties panel for the next active node instead of closing it.
                nextActiveNode.isActive = true; // Ensure it's marked as active
                nextActiveNode.type === 'action' ? openActionNodePropertiesModal(nextActiveNode) : openNodePropertiesModal(nextActiveNode);
            } else {
                // If no nodes are left, hide the panel.
                closeNodePropertiesModal();
            }

            updateModeUI();
            updateNodeStyles();
        }

        // NEW: Function to adjust the preview container's aspect ratio
        function adjustPreviewAspectRatio(animationId) {
            const animForAspectRatio = availableAnimations.find(a => a.id === animationId);

            if (animForAspectRatio && animForAspectRatio.jsonContent) {
                // Defer with requestAnimationFrame to run after browser layout/paint.
                requestAnimationFrame(() => {
                    const canvasWrapper = document.getElementById('canvas-wrapper');
                    if (!canvasWrapper) return;

                    // Reset height before recalculating to prevent cumulative growth.
                    canvasWrapper.style.height = '';

                    try {
                        const animJson = JSON.parse(animForAspectRatio.jsonContent);
                        if (animJson.w && animJson.h && animJson.w > 0) {
                            const aspectRatio = animJson.h / animJson.w; // height / width
                            const animationHeight = canvasWrapper.offsetWidth * aspectRatio;
                            if (canvasWrapper.offsetWidth > 0) { // Only set height if width is calculated
                                canvasWrapper.style.height = `${animationHeight}px`;

                                // Explicitly tell the player to resize
                                if (modalDotLottiePlayer) {
                                    modalDotLottiePlayer.resize();
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Could not parse animation JSON for aspect ratio.", e);
                    }
                });
            }
        }

       /**
         * A helper function to find the currently visible panel and its animatable children.
         */
        function findCurrentVisiblePanel() {
            const panels = [
                document.getElementById('node-properties-modal'),
                document.getElementById('action-node-properties-container'),
                document.getElementById('global-state-properties-container')
            ];
            
            const visiblePanel = panels.find(p => p.style.display === 'flex');
            
            if (!visiblePanel) {
                return { panel: null, children: [] };
            }

            let animatableChildren;
            if (visiblePanel.id === 'node-properties-modal') {
                 animatableChildren = [
                    visiblePanel.querySelector('.preview-container'),
                    visiblePanel.querySelector('.modal-main-content')
                 ].filter(Boolean);
            } else {
                // For Action and Global panels, the direct children are animatable
                animatableChildren = Array.from(visiblePanel.children);
            }
            return { panel: visiblePanel, children: animatableChildren };
        }

        async function openNodePropertiesModal(nodeData) {
            const panelToShow = document.getElementById('node-properties-modal');
            const animatableChildren = [
                panelToShow.querySelector('.preview-container'),
                panelToShow.querySelector('.modal-main-content')
            ].filter(Boolean);

            // Check if we're just switching between two state nodes
            const isSwitchingStates = selectedNodeForEdit && 
                                      selectedNodeForEdit.id !== nodeData.id && 
                                      panelToShow.style.display === 'flex';
            
            const { panel: currentVisiblePanel, children: oldAnimatables } = findCurrentVisiblePanel();
            
            if (currentVisiblePanel && currentVisiblePanel !== panelToShow) {
                // --- Switching PANEL TYPE (e.g., Global -> State) ---
                // 1. Animate out old panel
                oldAnimatables.forEach(child => child.classList.add('panel-content-exit'));
                await new Promise(resolve => setTimeout(resolve, 150)); // Short wait
                currentVisiblePanel.style.display = 'none';
                oldAnimatables.forEach(child => child.classList.remove('panel-content-exit'));

                // 2. Animate in new panel (content updated below)
                animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
                panelToShow.style.display = 'flex';
                await updatePanelContent(nodeData); // Load content *before* animating in
                await new Promise(resolve => setTimeout(resolve, 10));
                animatableChildren.forEach(child => child.classList.remove('panel-content-exit'));

            } else if (isSwitchingStates) {
                // --- Switching between two STATE NODES ---
                // 1. Animate out old content
                animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
                await new Promise(resolve => setTimeout(resolve, 150));

                // 2. Update content
                await updatePanelContent(nodeData);

                // 3. Animate in new content
                animatableChildren.forEach(child => child.classList.remove('panel-content-exit'));
            
            } else if (!currentVisiblePanel) {
                // --- Opening from a closed state ---
                // 1. Set start state
                animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
                panelToShow.style.display = 'flex';
                await updatePanelContent(nodeData);

                // 2. Animate in
                await new Promise(resolve => setTimeout(resolve, 10));
                animatableChildren.forEach(child => child.classList.remove('panel-content-exit'));
            } else {
                // --- Re-clicking the same node ---
                await updatePanelContent(nodeData);
            }
        }

        async function updatePanelContent(nodeData) {

                    // --- NEW: Update Panel Indicator with Animation Name ---
                    const panelIndicator = document.querySelector('#node-properties-modal .panel-type-indicator');
                    if (panelIndicator) {
                        const animation = availableAnimations.find(anim => anim.id === nodeData.animationId);
                        panelIndicator.textContent = animation ? truncateText(animation.name, 20) : 'State Node'; // Fallback to 'State Node'
                    }
                    // --- END NEW ---

                    // --- NEW: Handle active state ---
                    // 1. Deactivate the global state node if it's active
                    const globalNodeEl = document.getElementById('global_state_node');
                    if (globalNodeEl) {
                        globalNodeEl.classList.remove('active');
                    }
                    // 2. Set the current node as active and update styles for all regular nodes
                    // NEW: Also deactivate action nodes
                    document.querySelectorAll('.action-node.active').forEach(el => el.classList.remove('active'));


                    nodes.forEach(n => n.isActive = (n.id === nodeData.id));
                    updateNodeStyles();
                    // --- END NEW ---

                    // Append the global state properties to the preview window if not already there
                    if (!statePreviewWindow.contains(globalStatePropertiesContainer)) {
                        statePreviewWindow.appendChild(globalStatePropertiesContainer);
                    }
                    // NEW: Ensure the correct panel is visible
                    globalStatePropertiesContainer.style.display = 'none';
                    actionNodePropertiesContainer.style.display = 'none';
                    nodePropertiesModal.style.display = 'flex';
                    if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

                    selectedNodeForEdit = nodeData;

                    nodeNameInput.value = nodeData.name; //

                    // Populate Animation and Marker Dropdowns
                    populateMarkerDropdown(nodeData.animationId, nodeData.marker); //

                    // Determine initial state of loopCheckbox based on outgoing connections
                    // --- START FIX: Correctly disable toggles on imported nodes ---
                    
                    // 1. Get DOM elements for the toggles
                    const loopCheckboxContainer = document.getElementById('loop-checkbox').closest('.toggle-group');
                    const loopLabel = loopCheckboxContainer.querySelector('label');
                    const freezeToggleLabel = freezeOnFirstFrameToggleGroup.querySelector('label');

                    // 2. Check for outgoing connections using the correct lowercase names
                    const outgoingConnections = connections.filter(conn => conn.fromNodeId === nodeData.id);
                    const hasOnLoopComplete = outgoingConnections.some(conn => conn.interactionType === 'onLoopComplete');
                    const hasOnComplete = outgoingConnections.some(conn => conn.interactionType === 'onComplete');

                    let shouldDisableToggles = hasOnLoopComplete || hasOnComplete;
                    let loopCheckboxValue = false; // Default for 'onComplete'

                    if (hasOnLoopComplete) {
                        loopCheckboxValue = true; // 'onLoopComplete' forces the loop checkbox ON
                    }

                    // 3. Apply the logic to the LOOP checkbox
                    if (shouldDisableToggles) {
                        loopCheckboxContainer.style.pointerEvents = 'none';
                        loopCheckboxContainer.style.opacity = '0.4';
                        loopLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                        loopCheckbox.checked = loopCheckboxValue; // Set to true for 'onLoopComplete', false for 'onComplete'
                    } else {
                        // Enable interaction and reset appearance
                        loopCheckboxContainer.style.pointerEvents = 'auto';
                        loopCheckboxContainer.style.opacity = '1.0';
                        loopLabel.title = ''; // Clear tooltip
                        // Set based on the node's actual data
                        const effectivelyLoops = (typeof nodeData.loop === 'boolean' && nodeData.loop === true) ||
                                               (typeof nodeData.loop === 'number' && nodeData.loop > 0);
                        loopCheckbox.checked = effectivelyLoops;
                    }

                    // 4. Apply the logic to the FREEZE FRAME checkbox
                    if (shouldDisableToggles) {
                        freezeOnFirstFrameToggleGroup.style.pointerEvents = 'none';
                        freezeOnFirstFrameToggleGroup.style.opacity = '0.4';
                        freezeToggleLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                        freezeOnFirstFrameCheckbox.checked = false; // Freeze is disabled when an 'onComplete' trigger is used
                    } else {
                        // Enable interaction and reset appearance
                        freezeOnFirstFrameToggleGroup.style.pointerEvents = 'auto';
                        freezeOnFirstFrameToggleGroup.style.opacity = '1.0';
                        freezeToggleLabel.title = '';
                        // Set checkbox based on nodeData.autoplay property
                        freezeOnFirstFrameCheckbox.checked = !nodeData.autoplay; // checked = true means FREEZE, so autoplay = false
                        console.log(`[Freeze Check] Node '${nodeData.name}': Freeze toggle is ${freezeOnFirstFrameCheckbox.checked ? 'ON' : 'OFF'}. (autoplay: ${nodeData.autoplay})`);
                    }
                    // --- END FIX ---

                    // Lottie Player and checkbox setup
                    if (modalDotLottiePlayer) {

                        modalDotLottiePlayer.setSpeed(nodeData.speed);
                        speedSlider.value = nodeData.speed;
                        speedValueSpan.textContent = nodeData.speed.toFixed(1) + 'x';

                        // Load the animation and play the correct marker
                        const animation = availableAnimations.find(anim => anim.id === nodeData.animationId);
                        if (animation && animation.jsonContent) {
                            modalDotLottiePlayer.load({
                                // Use a deep copy for the preview to prevent modifying the original data.
                                data: (currentPreviewAnimationData = JSON.parse(JSON.stringify(JSON.parse(animation.jsonContent)))),
                                loop: true,
                                speed: nodeData.speed
                            });

                            // Set the player mode immediately after loading, before any other playback logic.
                            if (nodeData.playInReverse) {
                                modalDotLottiePlayer.setMode('reverse');
                            }
                            // The player defaults to 'normal' mode on load, so no 'else' is needed.
 
                            // Determine which marker to play
                            let markerToPlay = animation.markers.find(m => m.name === nodeData.marker);
                            // If the node's marker is not set or not found, default to "Full Animation"
                            if (!markerToPlay) {
                                markerToPlay = animation.markers.find(m => m.name === 'Full Animation');
                            }
 
                            // --- NEW LOGIC: Control player state based on the freeze toggle ---
                            if (freezeOnFirstFrameCheckbox.checked) {
                                let frameToFreezeAt = 0;
                                if (markerToPlay) {
                                    // If playing in reverse, freeze at the end frame. Otherwise, freeze at the start frame.
                                   if (playInReverseCheckbox.checked) {
                                       //frameToFreezeAt = Math.round(markerToPlay.end);
                                       frameToFreezeAt = Math.round(markerToPlay.start);
                                   } else {
                                       frameToFreezeAt = Math.round(markerToPlay.start);
                                   }
                                    modalDotLottiePlayer.setSegment(markerToPlay.start, markerToPlay.end);
                                }
                                //if(frameToFreezeAt>0) { frameToFreezeAt = frameToFreezeAt - 1; }
                                modalDotLottiePlayer.setFrame(frameToFreezeAt);
                                modalDotLottiePlayer.freeze();
                                console.log(`[Player Control] Freeze is ON. Player frozen at frame ${frameToFreezeAt}.`);
                            } else {
                                // If FREEZE is OFF: unfreeze and play the segment.
                                modalDotLottiePlayer.unfreeze();
                                if (markerToPlay) {
                                    modalDotLottiePlayer.setSegment(markerToPlay.start, markerToPlay.end);
                                }
                                modalDotLottiePlayer.play();
                                console.log(`[Player Control] Freeze is OFF. Player is playing.`);
                            }
                        }
                    } else {
                        // Fallback if player not ready (though it should be)
                         const effectivelyLoops = (typeof nodeData.loop === 'boolean' && nodeData.loop === true) ||
                                           (typeof nodeData.loop === 'number' && nodeData.loop > 0); //
                        loopCheckbox.checked = shouldForceLoopCheckboxFalse ? false : effectivelyLoops;
                        speedSlider.value = nodeData.speed;
                        speedValueSpan.textContent = nodeData.speed.toFixed(1) + 'x';
                    }

                    adjustPreviewAspectRatio(nodeData.animationId);

                    nodePropertiesModal.style.display = 'flex'; //

                    const broadcastEntryCheckbox = document.getElementById('broadcast-entry-checkbox'); //
                    const broadcastExitCheckbox = document.getElementById('broadcast-exit-checkbox'); //
                    const broadcastEntryNodeNameSpan = document.getElementById('broadcast-entry-node-name'); //
                    const broadcastExitNodeNameSpan = document.getElementById('broadcast-exit-node-name'); //

                    broadcastEntryCheckbox.checked = nodeData.broadcastOnEntry; //
                    broadcastExitCheckbox.checked = nodeData.broadcastOnExit; //
                    broadcastEntryNodeNameSpan.textContent = `${nodeData.name}_entry`; //
                    broadcastExitNodeNameSpan.textContent = `${nodeData.name}_exit`; //

                    playInReverseCheckbox.checked = nodeData.playInReverse || false; // NEW
                    initialNodeCheckbox.checked = nodeData.isInitial;
                }

        function closeNodePropertiesModal() {
            // This function is now effectively "close the right panel"
            if (!statePreviewWindow.classList.contains('hidden')) {
                previewToggleButton.click();
            }
            // We don't hide the modal itself, just the parent panel
            nodePropertiesModal.style.display = 'none';
            actionNodePropertiesContainer.style.display = 'none';
            selectedNodeForEdit = null;
        }

        function updateDynamicInteractionFields(selectedPresetId, details = {}) {
            // Hide all dynamic fields first
            loopCountField.style.display = 'none';
            customEventNameField.style.display = 'none';

            // --- NEW: Also hide tweened fields by default ---
            tweenedDurationField.style.display = 'none';
            tweenedEasingField.style.display = 'none';

            const selectedTransitionType = tempConnectionData.transitionType; // Use data from the model
            const toNode = nodes.find(n => n.id === tempConnectionData?.toNodeId);
            if (selectedTransitionType === 'Tweened' && toNode?.type !== 'action') {
                tweenedDurationField.style.display = 'flex';
                tweenedEasingField.style.display = 'flex';
                tweenedDurationInput.value = tempConnectionData.duration || 0.5;
                const currentEasing = tempConnectionData.easing || [0, 0, 1, 1];
                tweenedEasingInput.value = currentEasing.join(', ');

                // --- MODIFICATION START: Robust preset matching logic ---
                let presetName = 'custom'; // Default to custom
                const presetOptions = easingPresetOptions.querySelectorAll('.custom-dropdown-option');

                // Find the matching preset name by comparing array values robustly
                for (const option of presetOptions) {
                    try {
                        if (option.dataset.value !== 'custom') {
                            // Normalize both the data-value and the currentEasing array for comparison
                            // by parsing and then converting to a consistent string format. This handles whitespace differences.
                            const presetArrayString = JSON.parse(option.dataset.value).toString();
                            const currentEasingString = currentEasing.toString();
                            
                            if (presetArrayString === currentEasingString) {
                                presetName = option.textContent;
                                break; // Exit loop once a match is found
                            }
                        }
                    } catch (e) { /* Ignore options with invalid data-value, like "custom" */ }
                }

                easingPresetDisplay.textContent = presetName; // Set the dropdown display text

                // Disable/enable the input and adjust opacity based on whether a preset is matched
                if (presetName !== 'custom') {
                    tweenedEasingInput.disabled = true;
                    tweenedEasingInput.style.opacity = '0.6';
                } else {
                    tweenedEasingInput.disabled = false;
                    tweenedEasingInput.style.opacity = '1';
                }
                // --- MODIFICATION END ---
            }

            // Show and populate fields based on selectedPresetId
            if (selectedPresetId === 'onLoopComplete') {
                loopCountField.style.display = 'flex';
                // Prioritize 'details.loopCount' (from imported connections)
                // then fall back to selectedNodeForEdit.loop (if it's a number),
                // then default to 1.
                loopCountInput.value = details.loopCount || (typeof selectedNodeForEdit.loop === 'number' ? selectedNodeForEdit.loop : 1);
            } else if (selectedPresetId === 'CustomEvent') {
                customEventNameField.style.display = 'block';
                customEventNameInput.value = details.customEventName || '';
            }

            // --- MODIFIED: Show/hide the 'Edit Click Area' button based on the preset ---
            const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp'];
            if (pointerEvents.includes(selectedPresetId)) {
                editClickAreaButton.style.display = 'flex';
            } else {
                editClickAreaButton.style.display = 'none';
            }

            // --- NEW: Hide the parent container if no fields are visible ---
            const anyFieldVisible = loopCountField.style.display !== 'none' ||
                                  customEventNameField.style.display !== 'none' ||
                                  tweenedDurationField.style.display !== 'none' || // This is now part of the check
                                  tweenedEasingField.style.display !== 'none';   // This is now part of the check

            dynamicInteractionFields.style.display = anyFieldVisible ? 'flex' : 'none';
        }


        function openConnectionEditorModal(connectionData) {
                // --- 1. Set up the Modal and Data ---

                // Set the origin node of the connection as the active one in the main UI
                const originNodeElement = document.getElementById(connectionData.fromNodeId);
                if (originNodeElement) {
                    originNodeElement.click(); // This also opens the main properties panel
                }

                // Work on a temporary deep copy to avoid modifying the original until saved
                selectedConnectionForEdit = connectionData;
                tempConnectionData = JSON.parse(JSON.stringify(connectionData));

                // --- BACKWARD COMPATIBILITY & DATA NORMALIZATION ---
                // If 'action' is a single object from an old save file, convert it to an array.
                if (tempConnectionData.action && !Array.isArray(tempConnectionData.action)) {
                    tempConnectionData.action = [tempConnectionData.action];
                } else if (!tempConnectionData.action) {
                    // If 'action' is null or undefined, initialize it as an empty array.
                    tempConnectionData.action = [];
                }
                // --- NEW: Normalize openUrlAction ---
                if (!tempConnectionData.openUrlAction) {
                    tempConnectionData.openUrlAction = null;
                }
                // --- END NEW ---

                // --- 2. Populate Static Parts of the Modal (Title, Interaction, Tweening) ---

                connectionModalTitle.textContent = "Transition Settings";

                // Populate Transition Type Toggle
                const transitionOptions = transitionTypeToggle.querySelectorAll('.boolean-toggle-option');
                transitionOptions.forEach(option => {
                    option.classList.toggle('active', option.dataset.value === (tempConnectionData.transitionType || 'Transition'));
                });

                // Populate Interaction Presets dropdown
                populateDropdowns(
                    interactionPresetNativeSelect,
                    interactionPresetDisplay,
                    interactionPresetOptionsContainer,
                    INTERACTION_PRESETS,
                    tempConnectionData.interactionType || 'onComplete'
                );

                // Update dynamic fields (loop count, tweening, etc.)
                updateDynamicInteractionFields(tempConnectionData.interactionType, tempConnectionData.interactionDetails || {});
                
                // --- FIX: Attach event listeners for the modal's interactive elements ---
                attachTransitionEditorListeners();

                // Find destination node to determine UI visibility
                const toNode = nodes.find(n => n.id === tempConnectionData.toNodeId);
                const isActionNodeDest = toNode?.type === 'action';

                // Hide transition type dropdown if destination is an action node
                transitionTypeToggle.parentElement.style.display = isActionNodeDest ? 'none' : 'flex';

               // --- 3. Render Variable Actions (if available) ---
                const actionsListContainer = document.getElementById('transition-actions-list');
                const actionsSection = document.getElementById('actions-section');
                const addActionButton = document.getElementById('add-transition-action-button');
                actionsListContainer.innerHTML = ''; // Clear any previous action rows

                // --- 4. Render URL Action ---
                const transitionUrlSection = document.getElementById('transition-url-section');
                const transitionUrlInput = document.getElementById('transition-url-input');
                
                if (isActionNodeDest) {
                    // --- DESTINATION IS AN ACTION NODE ---
                    // Hide both action sections completely
                    actionsSection.style.display = 'none';
                    transitionUrlSection.style.display = 'none';
                    transitionUrlInput.value = ''; // Clear value
                
                } else {
                    // --- DESTINATION IS A STATE NODE ---
                    // Always show both sections
                    actionsSection.style.display = 'block';
                    transitionUrlSection.style.display = 'block';

                    // --- A) Populate Variable Actions Section ---
                    if (globalState && globalState.inputs.length > 0) {
                        // We have variables, so show the list
                        actionsListContainer.style.display = 'block';
                        addActionButton.style.display = 'none'; // Hide the "Add Action" button

                        // Loop through every GLOBAL VARIABLE to create a dedicated row for it.
                        globalState.inputs.forEach(variable => {
                            let actionForThisVariable = tempConnectionData.action.find(a => a.variableId === variable.id);
                            if (!actionForThisVariable) {
                                actionForThisVariable = {
                                    _tempId: `action_${generateId()}`,
                                    type: '', // "No action"
                                    value: '',
                                    variableId: variable.id
                                };
                                tempConnectionData.action.push(actionForThisVariable);
                            }
                            renderAndAttachActionRow(actionForThisVariable, actionsListContainer, tempConnectionData.action);
                        });
                    } else {
                        // No global variables exist. Show a prompt instead of the list.
                        actionsListContainer.style.display = 'block';
                        addActionButton.style.display = 'none';
                        actionsListContainer.innerHTML = `
                            <div class="action-node-prompt" style=" display:none; padding: 15px; gap: 10px; max-width: none;">
                                <p style="font-size: 14px;">Create a Global Variable to add actions.</p>
                                <button id="create-global-from-transition-panel" class="share-modal-button secondary" style="margin-left: 0; padding: 8px 16px; font-size: 14px;">
                                    <i class="fas fa-plus" style="margin-right: 6px;"></i>Create Variable
                                </button>
                            </div>`;
                        
                        // Attach listener for the new button
                        const createVarBtn = document.getElementById('create-global-from-transition-panel');
                        if (createVarBtn) {
                            createVarBtn.onclick = () => {
                                // Close this modal and open the global state one
                                closeConnectionEditorModal();
                                addOrShowGlobalStateNode();
                            };
                        }
                    }

                    // --- B) Populate URL Action Section ---
                    if (tempConnectionData.openUrlAction && tempConnectionData.openUrlAction.url) {
                        transitionUrlInput.value = tempConnectionData.openUrlAction.url;
                    } else {
                        transitionUrlInput.value = '';
                    }
                    transitionUrlInput.oninput = () => {
                        const urlValue = transitionUrlInput.value.trim();
                        if (urlValue) {
                            tempConnectionData.openUrlAction = { type: 'OpenUrl', url: urlValue, target: '_blank' };
                        } else {
                            tempConnectionData.openUrlAction = null;
                        }
                    };
                }
                // --- END NEW ---

                // --- 5. Show the Modal ---
                connectionEditorModal.classList.add('open');
                document.querySelectorAll('.connection-line').forEach(path => {
                    path.classList.toggle('selected-connection', path.dataset.connectionId === connectionData.id);
                });
            }

        function closeConnectionEditorModal() {
            // --- NEW: Revert changes on close ---
            if (selectedConnectionForEdit && transitionEditorStateBackup) {
                console.log('[LOG] Reverting changes from transition editor.');

                // 1. Revert the connection object in the main `connections` array
                const originalConnectionIndex = connections.findIndex(c => c.id === selectedConnectionForEdit.id);
                if (originalConnectionIndex > -1) {
                    connections[originalConnectionIndex] = transitionEditorStateBackup.connection;
                }

                // 2. Revert the animation JSON content if it was backed up
                if (transitionEditorStateBackup.animationId && transitionEditorStateBackup.animationJson) {
                    const animationToRevert = availableAnimations.find(anim => anim.id === transitionEditorStateBackup.animationId);
                    if (animationToRevert) {
                        animationToRevert.jsonContent = transitionEditorStateBackup.animationJson;
                        console.log(`[LOG] Reverted JSON content for animation: ${animationToRevert.name}`);

                        // 3. Refresh the preview player if the node is still selected
                        if (selectedNodeForEdit && selectedNodeForEdit.animationId === animationToRevert.id) {
                            openNodePropertiesModal(selectedNodeForEdit);
                        }
                    }
                }

                // 4. Redraw the canvas to reflect reverted connection text/style
                redrawAll();
            }
            // --- END NEW ---
            // --- FIX: Use classList.remove to trigger the closing animation ---
            connectionEditorModal.classList.remove('open');

            // After the animation duration, reset the state
            setTimeout(() => {
                selectedConnectionForEdit = null;
                tempConnectionData = null; // Clear the temporary data
                transitionEditorStateBackup = null; // Clear the backup
                document.querySelectorAll('.connection-line').forEach(path => {
                    path.classList.remove('selected-connection');
                });
            }, 400); // This duration should match the CSS transition duration
        }

        function showCustomConfirm(message, onConfirm) {
            const existingConfirmModal = document.getElementById('custom-confirm-modal');
            if (existingConfirmModal) existingConfirmModal.remove();

            const confirmModal = document.createElement('div');
            confirmModal.id = 'custom-confirm-modal';
            confirmModal.classList.add('modal');
            confirmModal.style.zIndex = '1003';
            // --- NEW: Modernized confirmation dialog with icon and pill buttons ---
            confirmModal.innerHTML = `
                <div class="modal-content" style="max-width: 360px; padding: 24px; text-align: center; border-radius: 24px; display: flex; flex-direction: column; gap: 4px;">
                    <div style="font-size: 28px; color: #e57373; margin-bottom: 12px;">
                        <i class="fas fa-trash-alt"></i>
                    </div>
                    <div class="modal-body" style="padding: 0;">
                        <p style="font-size: 16px; color: #333; line-height: 1.5; margin-bottom: 24px;">${message}</p>
                    </div>
                    <div class="modal-footer" style="flex-direction: column; gap: 10px; padding: 0; border: none; margin: 0;">
                        <button class="confirm-delete-btn" style="width: 100%; padding: 12px; border-radius: 999px; border: none; background-color: #ef5350; color: white; font-weight: bold; font-size: 16px; cursor: pointer;">Confirm</button>
                        <button class="cancel-delete-btn" style="width: 100%; padding: 12px; border-radius: 999px; border: none; background-color: #f0f2f5; color: #555; font-weight: 500; font-size: 16px; cursor: pointer;">Cancel</button>
                    </div>
                </div>`;
            // --- END NEW ---
            document.body.appendChild(confirmModal);
            confirmModal.style.display = 'flex';
            const confirmButton = confirmModal.querySelector('.confirm-delete-btn');
            const cancelButton = confirmModal.querySelector('.cancel-delete-btn');
            // The close button in the header is removed, so we don't need to select it.
            // const closeButton = confirmModal.querySelector('.close-button');

            const closeConfirm = (callback) => {
                confirmModal.style.display = 'none';
                if (callback && typeof callback === 'function') {
                    callback();
                }
                confirmModal.remove();
            };

            confirmButton.onclick = () => { onConfirm(); closeConfirm(); };
            cancelButton.onclick = () => closeConfirm(arguments[2]); // Pass the onCancel callback if provided
            // closeButton.onclick = () => closeConfirm(arguments[2]); // No longer exists
            confirmModal.addEventListener('click', (e) => { if (e.target === confirmModal) closeConfirm(arguments[2]); });
        }
        // --- End Modal Functions ---

        // --- NEW: Text Truncation Helper ---
        function truncateText(text, maxLength) {
            if (text.length > maxLength) {
                return text.substring(0, maxLength) + '...';
            }
            return text;
        }

        // --- Custom Alert Function ---
        // --- MODIFIED: Replaced modal alert with a toast notification ---
        function showCustomAlert(message) {
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.textContent = message;
            document.body.appendChild(toast);

            // Animate in
            setTimeout(() => {
                toast.style.top = '20px';
                toast.style.opacity = '1';
            }, 100); // Short delay to allow CSS transition to apply

            // Animate out and remove after 3 seconds
            setTimeout(() => {
                toast.style.top = '-100px';
                toast.style.opacity = '0';
                setTimeout(() => {
                    toast.remove();
                }, 500); // Wait for fade-out transition to finish before removing
            }, 3000);
        }
        // --- End Custom Alert Function ---


        // --- NEW: Functions for Global State, Guards, and Actions ---

        // --- NEW: Function to update the disabled state of the action button ---
       function updateActionNodeButtonState() {
          const button = document.getElementById('add-action-node-button');
          if (!button) return;

          // --- MODIFIED: Always enable the button ---
          button.disabled = false;
          button.title = "Add Action Node";
          // --- END MODIFICATION ---
      }


           function addOrShowGlobalStateNode() {
            if (globalState) {
                openGlobalStateModal();
                return;
            }

            // --- MODIFIED: Smart positioning for the global node ---
            let initialX, initialY;
            const GLOBAL_NODE_SIZE = 120; // As defined in CSS
            const SPACING_ABOVE_NODES = 80; // The desired vertical padding from the top of the nodes

            if (nodes.length > 0) {
                // Find the bounding box of existing state and action nodes
                let minX = Infinity, maxX = -Infinity;
                const topMostNodeY = Math.min(...nodes.map(n => n.y));

                nodes.forEach(node => {
                    const nodeWidth = node.type === 'action' ? 140 : NODE_WIDTH; // Use correct width for action nodes
                    minX = Math.min(minX, node.x);
                    maxX = Math.max(maxX, node.x + nodeWidth);
                });

                // Center the global node horizontally above the existing nodes
                initialX = (minX + maxX) / 2 - (GLOBAL_NODE_SIZE / 2);
                // Place it vertically above the topmost node
                initialY = topMostNodeY - GLOBAL_NODE_SIZE - SPACING_ABOVE_NODES;

            } else {
                // Fallback to default position if no nodes exist (top-center of the visible area)
                const visibleCanvasWidth = flowchartArea.offsetWidth;
                initialX = -panOffsetX + (visibleCanvasWidth / 2) - (GLOBAL_NODE_SIZE / 2);
                initialY = -panOffsetY + 50;
            }
            // --- END MODIFIED ---
 
            globalState = {
                
                // --- Properties for the container node itself ---
                id: 'global_state_node',
                name: 'God Guard', // The name for the yellow container node on the canvas
                x: initialX,
                y: initialY,
               
                wasImported: false,

                // --- The new array holding the input variable ---
                inputs: [
                    {
                        id: `input_${generateId()}`, // A unique ID for this specific input
                        name: 'myVariable',         // The name for the actual state machine input
                        type: 'Numeric',
                        initialValue: 0
                    }
                ]
            };
            console.log('[Global State Updated] Initialized:', JSON.parse(JSON.stringify(globalState)));
            const el = createGlobalStateElement(globalState);
            canvasContainer.appendChild(el);

            // --- FIX: Set default actions for any existing action nodes ---
            setDefaultActionsForExistingNodes();
            fitCanvasToNodesMinimally();
            updateActionNodeButtonState(); // Update button state
            openGlobalStateModal();
        }

        // --- NEW: Function to set default actions on unconfigured action nodes ---
        function setDefaultActionsForExistingNodes() {
            if (!globalState) return;

            nodes.forEach(node => {
                if (node.type === 'action' && !node.action) {
                    if (globalState.inputs[0].type === 'Numeric') {
                        node.action = { type: 'Increment', value: '1' };
                    } else if (globalState.inputs[0].type === 'Boolean') {
                        node.action = { type: 'Toggle' };
                    }
                    const actionNodeElement = document.getElementById(node.id);
                    if (actionNodeElement) {
                        updateActionNodeVisual(actionNodeElement.querySelector('.node'), node);
                    }
                }
            });
        }
        

        // NEW HELPER FUNCTION
function createVariableEditorHTML(variable) {
    const varId = variable.id; //
    const isNumeric = variable.type === 'Numeric'; //
    const isBoolean = variable.type === 'Boolean'; //
    const boolValue = (variable.initialValue === true || variable.initialValue === 'true'); //
    return ` <div class="variable-editor-block" data-variable-id="${varId}">
            <div style="display: flex; align-items: flex-start; gap: 8px;">
                <input type="text" id="var-name-${varId}" data-variable-id="${varId}" class="variable-name-input" value="${variable.name}" placeholder="Variable Name" style="flex-grow: 1; border-radius: 0; font-size: 18px; padding-bottom: 3px; ">
                <button class="delete-variable-button" data-variable-id="${varId}" title="Delete Variable"><i class="fas fa-times"></i></button>
            </div>

            <div class="dropdown-group variable-type-dropdown" data-variable-id="${varId}" style="margin-top: 4px;">
                <!-- Dropdown structure will be generated by openGlobalStateModal -->
            </div>

            <div class="toggle-group variable-value-container" data-variable-id="${varId}" style="margin-top: 15px; padding: 15px; padding-right: 0px;">
                <label style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; flex-grow: 1;">Starting Value</label>
                
                <!-- Numeric Input -->
                <div class="variable-numeric-input" style="display: ${isNumeric ? 'flex' : 'none'}; align-items: center; gap: 8px; margin: auto;">
                    <button class="decrement-var-value modal-stepper-button" data-variable-id="${varId}" style="width: 30px; height: 30px; border-radius: 50%;"><i class="fas fa-minus" style="font-size: 12px;"></i></button>
                    <input type="number" class="variable-value-input" data-variable-id="${varId}" 
                            value="${variable.initialValue}" style="width: 46px; text-align: center; border: 1px solid #ddd; border-radius: 8px; padding: 8px; font-weight: 600;">
                    <button class="increment-var-value modal-stepper-button" data-variable-id="${varId}" style="width: 30px; height: 30px; border-radius: 50%;"><i class="fas fa-plus" style="font-size: 12px;"></i></button>
                </div>

                <!-- Boolean Toggle -->
                <div class="switch variable-boolean-input" style="display: ${isBoolean ? 'inline-block' : 'none'}; margin: auto; margin-right: 10px;">
                    <input type="checkbox" id="var-bool-${varId}" class="variable-value-toggle" 
                           data-variable-id="${varId}" ${boolValue ? 'checked' : ''}>
                    <span class="slider round"></span>
                </div>
            </div>
        </div>
    `;
}

       


       async function openGlobalStateModal() {
            // --- (Handle active state block) ---
            const globalNodeEl = document.getElementById('global_state_node');
            if (globalNodeEl) {
                globalNodeEl.classList.add('active');
            }
            nodes.forEach(n => n.isActive = false);
            updateNodeStyles();
            document.querySelectorAll('.action-node.active').forEach(el => el.classList.remove('active'));
            // --- (End of block) ---

            if (!statePreviewWindow.contains(globalStatePropertiesContainer)) {
                statePreviewWindow.appendChild(globalStatePropertiesContainer);
            }
            
            // --- START: MODIFIED ANIMATION LOGIC ---
            const panelToShow = globalStatePropertiesContainer;
            const animatableChildren = Array.from(panelToShow.children);
            const { panel: currentVisiblePanel, children: oldAnimatables } = findCurrentVisiblePanel();

            if (currentVisiblePanel && currentVisiblePanel !== panelToShow) {
                // Animate out old panel
                oldAnimatables.forEach(child => child.classList.add('panel-content-exit'));
                await new Promise(resolve => setTimeout(resolve, 150));
                currentVisiblePanel.style.display = 'none';
                oldAnimatables.forEach(child => child.classList.remove('panel-content-exit'));

                // Set "in" start state
                animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
                
            } else if (currentVisiblePanel === panelToShow) {
                // Already showing, just update content (no animation)
            } else {
                // Opening from closed, set start state
                animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
            }
            // --- END: MODIFIED ANIMATION LOGIC ---

            panelToShow.style.display = 'flex';
            if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

            if (!globalState || !globalState.inputs) return;

            // 1. Populate container name
            document.getElementById('global-state-container-name-input').value = globalState.name;

            // 2. Find the list container and clear it
            const variableListContainer = document.getElementById('global-variable-list');
            variableListContainer.innerHTML = ''; // Clear old content

            // 3. Loop through variables and create an editor for each
            globalState.inputs
                .filter(variable => variable.type === 'Numeric' || variable.type === 'Boolean')
                .forEach((variable, index) => {
                const editorHtml = createVariableEditorHTML(variable);
                variableListContainer.insertAdjacentHTML('beforeend', editorHtml);

                // 4. Find the elements we just created to populate them
                const block = variableListContainer.querySelector(`.variable-editor-block[data-variable-id="${variable.id}"]`);
                const typeDropdownGroup = block.querySelector('.variable-type-dropdown');
                
                // 5. Populate the type dropdown for this specific variable
                const typeOptions = [{ id: 'Numeric', name: 'Numeric' }, { id: 'Boolean', name: 'Boolean' }];
                typeDropdownGroup.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                        <label for="var-type-${variable.id}">VARIABLE TYPE</label>
                        <div class="custom-dropdown-container">
                            <div class="custom-dropdown-display" data-target-select="var-type-${variable.id}">${variable.type}</div>
                            <div class="custom-dropdown-options"></div>
                            <select id="var-type-${variable.id}" class="variable-type-select" data-variable-id="${variable.id}" style="display: none;"></select>
                        </div>
                    </div>
                    <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;
                
                populateDropdowns(
                    block.querySelector('select'),
                    block.querySelector('.custom-dropdown-display'),
                    block.querySelector('.custom-dropdown-options'),
                    typeOptions,
                    variable.type
                );
                
                // 6. Hide delete button for the first variable (it's required)
                if (index === 0) {
                    block.querySelector('.delete-variable-button').style.display = 'none';
                }
            });

            // 7. Re-attach event listeners for the whole list
            attachGlobalStatePanelListeners(); 
            
            updateGlobalStateElementVisuals(); // Sync the canvas node with the new state

            // --- 8. Animate IN ---
            // This now runs when opening from closed OR switching from another panel
            if (!currentVisiblePanel || currentVisiblePanel !== panelToShow) {
                await new Promise(resolve => setTimeout(resolve, 10));
                animatableChildren.forEach(child => child.classList.remove('panel-content-exit'));
            }
        }
// ADD THIS NEW FUNCTION
function resetActionNodes(newType) {
    nodes.forEach(node => {
        if (node.type === 'action') {
            // Assign a new default action based on the NEW type
            if (newType === 'Numeric') {
                node.action = { type: 'Increment', value: '1' };
            } else if (newType === 'Boolean') {
                node.action = { type: 'Toggle' };
            } else {
                node.action = null; // No default for other types
            }
            // Update the visual display for the node
            const actionNodeElement = document.getElementById(node.id);
            if (actionNodeElement && actionNodeElement.querySelector('.node')) {
                updateActionNodeVisual(actionNodeElement.querySelector('.node'), node);
            }
        }
    });
}



function attachGlobalStatePanelListeners() {
            const panel = document.getElementById('global-state-properties-container');
            const variableList = document.getElementById('global-variable-list');

            // --- Container Name (Find and replace existing listener) ---
            const containerNameInput = document.getElementById('global-state-container-name-input');
            // Remove old listener to prevent duplicates
            containerNameInput.oninput = null; 
            containerNameInput.oninput = (e) => {
                if (globalState && e.target.value.trim()) { // Only update if not empty
                    globalState.name = e.target.value;
                    updateGlobalStateElementVisuals(); // New function (see below)
                }
            };

            // --- NEW: Add a blur event listener to handle empty input ---
            containerNameInput.onblur = null;
            containerNameInput.onblur = (e) => {
                if (globalState && !e.target.value.trim()) {
                    e.target.value = 'God Guard'; // Set UI value
                    globalState.name = 'God Guard'; // Update data model
                    updateGlobalStateElementVisuals(); // Update the node on the canvas
                }
            };

            // --- "Add Variable" Button (Find and replace existing listener) ---
            const addVarButton = document.getElementById('add-variable-button');
            
            // --- START: MODIFIED ONCLICK LOGIC FOR ANIMATION ---
            addVarButton.onclick = null;
            addVarButton.onclick = () => {
                if (globalState) {
                    
                    // 1. Get "First" position of the button
                    const firstButtonRect = addVarButton.getBoundingClientRect();

                    // 2. Create the new variable data
                    const newVariable = {
                        id: 'input_' + generateId(),
                        name: `newVariable${globalState.inputs.length}`,
                        type: 'Numeric',
                        initialValue: 0
                    };
                    globalState.inputs.push(newVariable);
                    updateGlobalStateElementVisuals(); // Update canvas node (e.g., "1 Variable" -> "2 Variables")


                    // 3. Update guard connections (data only)
                    guardConnections.forEach(conn => {
                        conn.conditions.push({
                            variableId: newVariable.id,
                            condition: 'Equal',
                            value: newVariable.type === 'Boolean' ? 'false' : '0'
                        });
                    });

                    // --- [NEWLY ADDED] ---
                    // Add a placeholder action for this new variable to all state-to-state connections
                    connections.forEach(conn => {
                        // Check if the connection has an 'action' array (i.e., it's not going to an Action Node)
                        if (conn.action && Array.isArray(conn.action)) {
                            conn.action.push({
                                _tempId: `action_${generateId()}`,
                                type: '', // Represents 'No action'
                                value: '',
                                variableId: newVariable.id
                            });
                        }
                    });
                    // --- [END NEWLY ADDED] ---

                    // 4. Create the new element from HTML
                    const editorHtml = createVariableEditorHTML(newVariable);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = editorHtml;
                    const newBlock = tempDiv.firstElementChild;

                    // 5. Set its "before" animation state
                    newBlock.classList.add('slide-in-start');

                    // 6. Append the new block (this causes the layout shift)
                    const variableListContainer = document.getElementById('global-variable-list');
                    variableListContainer.appendChild(newBlock);

                    // 7. Populate the dropdowns for the new block (which is now in the DOM)
                    const typeDropdownGroup = newBlock.querySelector('.variable-type-dropdown');
                    const typeOptions = [{ id: 'Numeric', name: 'Numeric' }, { id: 'Boolean', name: 'Boolean' }, { id: 'Event', name: 'Event' }];
                    typeDropdownGroup.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <label for="var-type-${newVariable.id}">VARIABLE TYPE</label>
                            <div class="custom-dropdown-container">
                                <div class="custom-dropdown-display" data-target-select="var-type-${newVariable.id}">${newVariable.type}</div>
                                <div class="custom-dropdown-options"></div>
                                <select id="var-type-${newVariable.id}" class="variable-type-select" data-variable-id="${newVariable.id}" style="display: none;"></select>
                            </div>
                        </div>
                        <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;
                    populateDropdowns(
                        newBlock.querySelector('select'),
                        newBlock.querySelector('.custom-dropdown-display'),
                        newBlock.querySelector('.custom-dropdown-options'),
                        typeOptions,
                        newVariable.type
                    );

                    // 8. Get "Last" position
                    const lastButtonRect = addVarButton.getBoundingClientRect();

                    // 9. Calculate "Invert"
                    const deltaY = firstButtonRect.top - lastButtonRect.top;

                    // 10. Apply "Invert" (instantly, no transition)
                    addVarButton.style.transition = 'none';
                    addVarButton.style.transform = `translateY(${deltaY}px)`;

                    // 11. "Play" (in the next frame)
                    requestAnimationFrame(() => {
                        // Animate the button immediately
                        addVarButton.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                        addVarButton.style.transform = 'translateY(0)';
                        
                        // Animate the new block after a delay
                        setTimeout(() => {
                            // We add the transition property here so it doesn't animate on page load
                            newBlock.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out';
                            newBlock.classList.remove('slide-in-start'); // This triggers the animation
                        }, NEW_VARIABLE_BLOCK_DELAY_MS); // Use the new delay variable
                    });
                    
                    // 12. Cleanup transitions after they finish to prevent future glitches
                    addVarButton.addEventListener('transitionend', () => {
                        addVarButton.style.transition = 'none';
                    }, { once: true });

                    newBlock.addEventListener('transitionend', () => {
                        newBlock.style.transition = ''; // Revert to CSS-defined transition
                    }, { once: true });


                    // 13. Redraw canvas (to update guard connection text)
                    redrawAll();
                }
            };
            // --- END: MODIFIED ONCLICK LOGIC ---
            

            // --- Event Delegation for all dynamic variable controls ---
            variableList.onclick = (e) => {
                const target = e.target;
                const variableBlock = target.closest('.variable-editor-block');
                if (!variableBlock) return;
                
                const variableId = variableBlock.dataset.variableId;
                const variable = globalState.inputs.find(v => v.id === variableId);
                if (!variable) return;

                // Handle Delete Button
                if (target.closest('.delete-variable-button')) {
                    if (globalState.inputs.length <= 1) return; // Safety check

                    showCustomConfirm(
                        "Deleting this variable will reset all actions that use it. Are you sure you want to continue?",
                        () => {
                            // --- START: REFACTORED DELETION LOGIC ---
                            
                            // 1. --- IMMEDIATE DATA DELETION ---

                            // --- [NEWLY ADDED] ---
                            // Remove this variable's action from all state-to-state connections
                            connections.forEach(conn => {
                                if (conn.action && Array.isArray(conn.action)) {
                                    conn.action = conn.action.filter(act => act.variableId !== variableId);
                                }
                            });
                            // --- [END NEWLY ADDED] ---

                            // Reset affected Action Nodes
                            nodes.forEach(node => {
                                if (node.type === 'action' && Array.isArray(node.action)) {
                                    node.action = node.action.filter(act => act.variableId !== variableId);
                                    const nodeElement = document.getElementById(node.id);
                                    if (nodeElement) {
                                        updateActionNodeVisual(nodeElement.querySelector('.node'), node);
                                    }
                                }
                            });
                            // Remove conditions from guards
                            removeConditionFromAllGuards(variableId);
                            // Remove variable from data
                            globalState.inputs = globalState.inputs.filter(v => v.id !== variableId);
                            
                            // 2. --- IMMEDIATE VISUAL UPDATE ---
                            // Update the canvas node visuals
                            updateGlobalStateElementVisuals();

                            // 3. --- START FLIP ANIMATION ---
                            // Get "First" position of the button
                            const addVarButton = document.getElementById('add-variable-button');
                            const firstButtonRect = addVarButton.getBoundingClientRect();
                            
                            // Set explicit height on the block to animate *from*
                            const blockHeight = variableBlock.scrollHeight;
                            variableBlock.style.height = `${blockHeight}px`;

                            // Trigger the "out" animation (in the next frame, to apply the height)
                            requestAnimationFrame(() => {
                                // Animate the block collapsing and sliding out
                                variableBlock.style.opacity = '0';
                                variableBlock.style.transform = 'translateX(50px)';
                                variableBlock.style.height = '0';
                                variableBlock.style.paddingTop = '0';
                                variableBlock.style.paddingBottom = '0';
                                variableBlock.style.marginBottom = '0';

                                // Force the browser to reflow
                                const originalDisplay = variableBlock.style.display;
                                variableBlock.style.display = 'none';
                                
                                // Get "Last" position (NOW it's accurate)
                                const lastButtonRect = addVarButton.getBoundingClientRect();
                                
                                // Un-hide the block so its animation is visible
                                variableBlock.style.display = originalDisplay;

                                // Calculate "Invert"
                                const deltaY = firstButtonRect.top - lastButtonRect.top;

                                // Apply "Invert" (instantly, no transition)
                                addVarButton.style.transition = 'none';
                                addVarButton.style.transform = `translateY(${deltaY}px)`;

                                // "Play" (in the *next* frame)
                                requestAnimationFrame(() => {
                                    addVarButton.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                                    addVarButton.style.transform = 'translateY(0)';
                                });

                                // Cleanup button transition
                                addVarButton.addEventListener('transitionend', () => {
                                    addVarButton.style.transition = 'none';
                                }, { once: true });
                            });

                            // 4. After animation, *only* remove the block from the DOM
                            variableBlock.addEventListener('transitionend', () => {
                                variableBlock.remove();
                            }, { once: true });
                            // --- END: REFACTORED DELETION LOGIC ---
                        }
                    );
                }
                
                // Handle Type Dropdown
               if (target.closest('.variable-type-dropdown')) {
                e.stopPropagation();
                
                const optionsContainer = variableBlock.querySelector('.custom-dropdown-options');
                const option = target.closest('.custom-dropdown-option');

                if (option) {
                    // --- This is the new logic for handling a selection ---
                    const newType = option.dataset.value;
                    
                    if (variable.type !== newType) {
                        // The type has changed.
                        const oldType = variable.type;
                        const isFirstVariable = (globalState.inputs.findIndex(v => v.id === variableId) === 0);
                        const hasActionNodes = nodes.some(node => node.type === 'action');

                        const performChange = () => {
                            // 1. Update the model
                            variable.type = newType;
                            variable.initialValue = (newType === 'Boolean') ? 'false' : '0';

                            // 2. Reset associated guard conditions
                            resetGuardConditionsForVariable(variableId, newType);

                            // --- [NEWLY ADDED] ---
                            // Reset this variable's action on all state-to-state connections
                            connections.forEach(conn => {
                                if (conn.action && Array.isArray(conn.action)) {
                                    const actionToReset = conn.action.find(act => act.variableId === variableId);
                                    if (actionToReset) {
                                        actionToReset.type = ''; // Reset to 'No action'
                                        actionToReset.value = '';
                                    }
                                }
                            });
                            // --- [END NEWLY ADDED] ---

                            // 3. Reset action nodes if it was the first variable
                            if (isFirstVariable) {
                                resetActionNodes(newType);
                            }

                            // 4. Refresh the UI
                            openGlobalStateModal(); // Re-renders the panel
                            redrawAll(); // Re-draws the canvas
                        };

                        if (isFirstVariable && hasActionNodes && (oldType === 'Numeric' || oldType === 'Boolean')) {
                            // If it's the first variable, has action nodes, and type is changing, confirm first.
                            showCustomConfirm(
                                "Changing this variable's type will reset all Action Nodes. Continue?",
                                () => {
                                    // User confirmed
                                    performChange();
                                },
                                () => {
                                    // User canceled
                                    // Just re-render the modal to snap the dropdown back to the old value.
                                    openGlobalStateModal();
                                }
                            );
                        } else {
                            // No confirmation needed, just perform the change.
                            performChange();
                        }

                    } else {
                        // Type is the same, just close the dropdown
                        closeAllCustomDropdowns();
                    }
                    // --- End of new logic ---

                } else if (!target.closest('.custom-dropdown-option')) {
                    // This is a click on the dropdown group itself, not an option.
                    // This logic handles opening/closing the dropdown.
                    const wasOpen = optionsContainer.classList.contains('open');
                    closeAllCustomDropdowns(); // This will close all others
                    if (!wasOpen) {
                        optionsContainer.classList.add('open');
                        variableBlock.classList.add('dropdown-open');
                    }
                }
            }

                // Handle Value Steppers
                const valueInput = variableBlock.querySelector('.variable-value-input');
                if (target.closest('.decrement-var-value')) {
                    valueInput.stepDown();
                    variable.initialValue = Number(valueInput.value);
                    if (globalState.inputs[0].id === variableId) updateGlobalStateElementVisuals();
                }
                if (target.closest('.increment-var-value')) {
                    valueInput.stepUp();
                    variable.initialValue = Number(valueInput.value);
                    if (globalState.inputs[0].id === variableId) updateGlobalStateElementVisuals();
                }
                
                // Handle Boolean Toggle
                if (target.closest('.slider.round')) {
                    e.stopPropagation(); // Prevent other click events from firing
                    const toggle = variableBlock.querySelector('.variable-value-toggle');
                    // Programmatically click the hidden checkbox to change its state
                    toggle.click(); 
                    // The 'change' event listener below will handle updating the data model.
                }
            };
            
            variableList.oninput = (e) => {
                const target = e.target;
                const variableId = target.closest('[data-variable-id]')?.dataset.variableId;
                if (!variableId) return;

                const variable = globalState.inputs.find(v => v.id === variableId);
                if (!variable) return;

                // Handle Name Input
                if (target.classList.contains('variable-name-input')) {
                    variable.name = target.value;
                    
                    // --- START: MODIFICATION ---
                    // 1. Update the main global state node visual (if it's the first var)
                    if (globalState.inputs[0].id === variableId) {
                        updateGlobalStateElementVisuals();
                    }

                    // 2. Find and update all Action Nodes that use this variable
                    nodes.forEach(node => {
                        if (node.type === 'action' && Array.isArray(node.action)) {
                            // Check if any action on this node uses the variable that just changed
                            const usesThisVariable = node.action.some(act => act.variableId === variableId);
                            
                            if (usesThisVariable) {
                                const nodeElement = document.getElementById(node.id)?.querySelector('.node');
                                if (nodeElement) {
                                    updateActionNodeVisual(nodeElement, node);
                                }
                            }
                        }
                    });
                    // --- END: MODIFICATION ---
                }

                // Handle Numeric Value Input
                if (target.classList.contains('variable-value-input')) {
                    variable.initialValue = Number(target.value);
                    if (globalState.inputs[0].id === variableId) updateGlobalStateElementVisuals();
                }
            };

            // --- NEW: Add a 'change' listener for the boolean toggle ---
            variableList.onchange = (e) => {
                const target = e.target;
                if (target.classList.contains('variable-value-toggle')) {
                    const variableId = target.dataset.variableId;
                    const variable = globalState.inputs.find(v => v.id === variableId);
                    if (variable) {
                        variable.initialValue = target.checked;
                        // If this is the first variable, update the main display
                        if (globalState.inputs[0].id === variableId) {
                            updateGlobalStateElementVisuals();
                        }
                    }
                }
            };

             variableList.addEventListener('focusin', (e) => {
                const target = e.target;
                if (target.classList.contains('variable-name-input')) {
                    // Store the current valid name when focusing
                    target.dataset.originalName = target.value;
                }
            }, true); // Use capture phase to ensure this runs first

            // --- MODIFIED: 'focusout' listener to use the original name ---
            variableList.addEventListener('focusout', (e) => {
                const target = e.target;
                if (!target.classList.contains('variable-name-input')) return;
                
                const variableId = target.closest('[data-variable-id]')?.dataset.variableId;
                if (!variableId) return;
                
                const variable = globalState.inputs.find(v => v.id === variableId);
                if (!variable) return;

                // Get the original name stored on focus
                const originalName = target.dataset.originalName || variable.name; // Fallback to model name
                const currentName = target.value.trim();

                // Check 1: Is it empty?
                if (!currentName) {
                    showCustomAlert("Variable name cannot be empty. Reverting.");
                    target.value = originalName; // Revert to original name
                    target.classList.remove('error');
                    variable.name = originalName; // Make sure model is also in sync
                    // We need to redraw in case the model name was different
                    if (globalState.inputs[0].id === variableId) updateGlobalStateElementVisuals();
                    redrawAll();
                    return;
                }

                // Check 2: Is it a duplicate?
                const isDuplicate = globalState.inputs.some(v => v.name.toLowerCase() === currentName.toLowerCase() && v.id !== variableId);
                if (isDuplicate) {
                    showCustomAlert("Please use a unique variable name. Reverting."); // Updated message
                    target.classList.add('error'); // Add error class
                    target.value = originalName; // Revert to original name
                    target.classList.remove('error'); // Remove error class as it's valid again
                    variable.name = originalName; // Make sure model is also in sync
                    // We need to redraw in case the model name was different
                    if (globalState.inputs[0].id === variableId) updateGlobalStateElementVisuals();
                    redrawAll();
                } else {
                    // It's not empty and not a duplicate. This is a valid save.
                    target.classList.remove('error');
                    // Ensure the model and the input value match (in case of trimming)
                    target.value = currentName;
                    variable.name = currentName;
                    
                    // Trigger visual updates just in case
                    if (globalState.inputs[0].id === variableId) {
                        updateGlobalStateElementVisuals();
                    }
                    // Update guard/action node visuals
                    redrawAll();
                    nodes.forEach(node => {
                        if (node.type === 'action' && Array.isArray(node.action) && node.action.some(act => act.variableId === variableId)) {
                            const nodeElement = document.getElementById(node.id)?.querySelector('.node');
                            if (nodeElement) updateActionNodeVisual(nodeElement, node);
                        }
                    });
                }
                // Clear the stored original name
                if (target.dataset.originalName) {
                    delete target.dataset.originalName;
                }
            });

            
        }
        



function removeConditionFromAllGuards(variableId) {
    if (!variableId) return;

    guardConnections.forEach(gc => {
        gc.conditions = gc.conditions.filter(cond => cond.variableId !== variableId);
    });

    console.log(`[Cascade Delete] Removed all guard conditions associated with variable ID: ${variableId}`);
    redrawAll(); // Redraw connections to reflect the changes.
}



// ADD THIS NEW FUNCTION
function updateGlobalStateElementVisuals() {
            if (!globalState) return;
            const el = document.getElementById('global_state_node');
            if (el) {
                
                // --- START: NEW SMART DISPLAY LOGIC ---
                let displayName = truncateText(globalState.name, 25);
                let displayValue = '0 Variables';

                if (globalState.inputs && globalState.inputs.length === 1) {
                    // If there is exactly one variable, show its details.
                    const variable = globalState.inputs[0];
                    displayName = truncateText(variable.name, 25); // Use variable name
                    
                    if (variable.type === 'Numeric') {
                        displayValue = `Starts as ${variable.initialValue}`;
                    } else if (variable.type === 'Boolean') {
                        const boolValue = (variable.initialValue === true || variable.initialValue === 'true');
                        displayValue = `Starts as ${boolValue}`;
                    } else {
                        displayValue = `Type: ${variable.type}`;
                    }
                } else if (globalState.inputs && globalState.inputs.length > 1) {
                    // If there are 2 or more variables, show the count.
                    const numVariables = globalState.inputs.length;
                    displayName = truncateText(globalState.name, 25); // Use container name
                    displayValue = `${numVariables} Variables`;
                }
                // If 0 variables, the defaults will be used.
                // --- END: NEW SMART DISPLAY LOGIC ---

                // Update the DOM elements
                el.querySelector('.global-state-name-display').textContent = displayName;
                el.querySelector('.global-state-value-display').innerHTML = displayValue;
            }
        }

function resetGuardConditionsForVariable(variableId, newType) {
            if (!guardConnections || !variableId) return;

            // Set a default value and condition for the *new* type
            const defaultValue = (newType === 'Boolean') ? 'false' : '0';
            const defaultCondition = 'None'; // Set to 'None' to force the user to re-select a valid condition

            guardConnections.forEach(gc => {
                // Find the specific condition associated with the variable that changed
                const conditionToReset = gc.conditions.find(c => c.variableId === variableId);
                
                if (conditionToReset) {
                    console.log(`[LOG] Resetting guard condition for variable ${variableId} on connection ${gc.id}.`);
                    // Reset the condition and value to the new defaults
                    conditionToReset.condition = defaultCondition;
                    conditionToReset.value = defaultValue;
                }
            });
        }
        // NEW: Central function for live updates from the UI
       function updateGlobalStateFromUI() {
            // This function is now deprecated.
            // The new logic is handled by 'attachGlobalStatePanelListeners'.
            // We call this here to ensure listeners are attached if 'open' was called before 'attach' was defined.
            console.warn("Legacy updateGlobalStateFromUI called. Re-attaching listeners.");
            attachGlobalStatePanelListeners();
        }

        // NEW: Function to delete the global state
        function deleteGlobalState() {
            if (!globalState) return;

            // Remove the visual element
            const el = document.getElementById('global_state_node');
            if (el) el.remove();

            // Clear the data
            globalState = null;
            console.log('[Global State Updated] Deleted. State is now:', globalState);
            guardConnections = [];

            // --- NEW: Reset all Action Nodes ---
            // Find all action nodes and reset their action property and visual state.
            nodes.forEach(node => {
                if (node.type === 'action') {
                    node.action = null; // Reset the action data
                    const actionNodeElement = document.getElementById(node.id);
                    if (actionNodeElement) {
                        updateActionNodeVisual(actionNodeElement, node); // Update the visual display
                    }
                }
            });

            // Close the panel and redraw
            closeNodePropertiesModal(); // This closes the side panel
            updateActionNodeButtonState(); // Update button state
            redrawAll();
            showCustomAlert("Global variable has been deleted.");
        }

        function addGuardConnection(fromId, toId) {
                    if (fromId !== 'global_state_node' || !nodes.some(n => n.id === toId)) return;
                    if (guardConnections.some(gc => gc.toNodeId === toId)) {
                        showCustomAlert("This state already has a guard condition.");
                        return;
                    }

                    // Create a default condition for EACH existing global variable.
                    const initialConditions = globalState.inputs.map((variable, index) => {
                        let defaultCondition = 'Equal';
                        let defaultValue;

                        if (variable.type === 'Numeric') {
                            // Smart default only for the first variable to avoid conflicts.
                            if (index === 0) {
                                const existingEqualValues = guardConnections
                                    .flatMap(gc => gc.conditions) // Look through all conditions
                                    .filter(c => c.variableId === variable.id && c.condition === 'Equal')
                                    .map(c => parseFloat(c.value))
                                    .filter(v => !isNaN(v));
                                const maxValue = existingEqualValues.length > 0 ? Math.max(...existingEqualValues) : -1;
                                defaultValue = (maxValue + 1).toString();
                            } else {
                                defaultValue = '0'; // Simple default for other variables
                            }
                        } else if (variable.type === 'Boolean') {
                            if (index === 0) {
                                const hasTrue = guardConnections.flatMap(gc => gc.conditions).some(c => c.variableId === variable.id && c.condition === 'Equal' && (c.value === 'true' || c.value === true));
                                defaultValue = hasTrue ? 'false' : 'true';
                            } else {
                                defaultValue = 'false';
                            }
                        } else {
                            defaultValue = '';
                        }

                        return {
                            variableId: variable.id,
                            condition: defaultCondition,
                            value: defaultValue,
                        };
                    });

                    const newGuardConn = {
                        id: `guard_${generateId()}`,
                        fromNodeId: fromId,
                        toNodeId: toId,
                        transitionType: 'Transition',
                        conditions: initialConditions, // Assign the array of conditions
                    };

                    guardConnections.push(newGuardConn);
                    redrawAll();
                    //openGuardConditionModal(newGuardConn); // Open modal immediately to configure
                }
        function deleteGuardConnection(id) {
            guardConnections = guardConnections.filter(gc => gc.id !== id);
            guardConditionModal.classList.remove('open');
            redrawAll();
        }

        function getConditionOptionsForType(type) {
            const noneOption = { id: 'None', name: 'None' };
            if (type === 'Numeric') return [noneOption, {id: 'Equal', name: 'is equal to'}, {id: 'NotEqual', name: 'is not equal to'}, {id: 'GreaterThan', name: 'is greater than'}, {id: 'LessThan', name: 'is smaller than'}];
            if (type === 'Boolean') return [noneOption, {id: 'Equal', name: 'is'}, {id: 'NotEqual', name: 'is not'}];
            if (type === 'String') return [noneOption, {id: 'Equal', name: 'is'}, {id: 'NotEqual', name: 'is not'}];
            return [noneOption];
        }

        function createGlobalStateElement(stateData) {
            const el = document.createElement('div');
            el.id = stateData.id;
            el.classList.add('global-state-node');
            el.style.left = `${stateData.x}px`;
            el.style.top = `${stateData.y}px`;

            if (!stateData.wasImported) {
                el.classList.add('entering');
                setTimeout(() => el.classList.remove('entering'), 350);
            }

            // --- START: NEW SMART DISPLAY LOGIC ---
            let displayName = truncateText(stateData.name, 25);
            let displayValue = '0 Variables';

            if (stateData.inputs && stateData.inputs.length === 1) {
                // If there is exactly one variable, show its details.
                const variable = stateData.inputs[0];
                displayName = truncateText(variable.name, 25); // Use variable name
                
                if (variable.type === 'Numeric') {
                    displayValue = `Starts as ${variable.initialValue}`;
                } else if (variable.type === 'Boolean') {
                    const boolValue = (variable.initialValue === true || variable.initialValue === 'true');
                    displayValue = `Starts as ${boolValue}`;
                } else {
                    // Fallback for other types if they ever exist
                    displayValue = `Type: ${variable.type}`;
                }
            } else if (stateData.inputs && stateData.inputs.length > 1) {
                // If there are 2 or more variables, show the count.
                const numVariables = stateData.inputs.length;
                displayName = truncateText(stateData.name, 25); // Use container name
                displayValue = `${numVariables} Variables`;
            }
            // If 0 variables, the defaults 'truncateText(stateData.name, 25)' and '0 Variables' will be used.
            // --- END: NEW SMART DISPLAY LOGIC ---

            el.innerHTML = `<div style="margin-bottom: 20px;">
                    <div class="global-state-name-display" style="font-weight: bold; margin-bottom: 2px; color: #89562b;">${displayName}</div>
                    <div class="global-state-value-display" style="font-size: 12px; color: #555; margin-top: 2px;">${displayValue}</div>
                </div>`;

            let hasDragged = false; // NEW: Flag to distinguish drag from click

            el.addEventListener('click', (e) => {
                // If the click is on the port, do nothing here. The port has its own listener.
                if (e.target.classList.contains('node-port')) return;
                // NEW: If a drag just happened, don't open the modal.
                if (hasDragged) return;

                e.stopPropagation();
                openGlobalStateModal();
            });

            // Add the connection port
            const port = document.createElement('div');
            port.classList.add('node-port');
            port.style.left = '36.5%'; // Center based on parent, transform will adjust
            port.style.top = 'calc(50% + 14px)'; // Moved down
            port.style.width = '26px';
            port.style.height = '26px';
            port.style.borderRadius = '20px';
           port.style.backgroundColor = '#d2691e';
            port.dataset.nodeId = stateData.id;
            port.dataset.portType = 'bottom'; // Logical type
            port.innerHTML = '<i class="fas fa-link" style="font-size: 8px; color: white;"></i>'; // Add icon
            el.appendChild(port);

            // --- NEW: Drag-to-connect for Guard Connections ---
            port.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (isConnecting || isCreatingGuardConnection) return; // Prevent starting a new connection while another is in progress

                isCreatingGuardConnection = true;
                el.classList.add('selected-for-connection');

                // Define the fixed start coordinates for the ghost line from the global node's center
                const startCoords = {
                    x: globalState.x + 60, 
                    y: globalState.y + 93  // 50% (60px) + 25px offset + 8px half-port-size
                };

                // Immediately draw the ghost line to the current cursor position
                const canvasRect = canvasContainer.getBoundingClientRect();
                const initialEndCoords = {
                    x: e.clientX - canvasRect.left,
                    y: e.clientY - canvasRect.top
                };
                drawGuardGhostLine(startCoords, initialEndCoords);

                const onDragEnd = (upEvent) => {
                    // Check if the mouse is released over a valid target node
                    const targetNodeWrapper = upEvent.target.closest('.node-wrapper');
                    if (targetNodeWrapper) {
                        const targetNodeData = nodes.find(n => n.id === targetNodeWrapper.id);
                        if (targetNodeData && targetNodeData.type === 'action') {
                            // It's an action node, so we should not allow the connection.
                            showCustomAlert("Cannot create a conditional transition to an Action Node.");
                        } else {
                            // It's a regular state node, allow the connection.
                            addGuardConnection('global_state_node', targetNodeWrapper.id);
                        }
                    }

                    // Cleanup: End guard connection mode and remove listeners
                    isCreatingGuardConnection = false;
                    el.classList.remove('selected-for-connection');
                    drawGuardGhostLine(null, null); // Hide ghost line
                    document.removeEventListener('mouseup', onDragEnd);
                };

                // Add a one-time mouseup listener to the document to handle release
                document.addEventListener('mouseup', onDragEnd, { once: true });
            });
            // --- END OF NEW SEGREGATED LOGIC ---

            // Dragging logic
            let isDragging = false, offsetX, offsetY, startX, startY;
            el.addEventListener('mousedown', e => {
                // Only start drag if not clicking the port
                if (e.target.closest('.global-state-node') && !e.target.classList.contains('node-port')) {
                    isDragging = true;
                    el.style.cursor = 'grabbing';
                    offsetX = e.clientX - el.getBoundingClientRect().left;
                    offsetY = e.clientY - el.getBoundingClientRect().top;
                    startX = e.clientX; // Store initial mouse position
                    startY = e.clientY;
                    hasDragged = false; // Reset drag flag on new mousedown
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', e => { 
                if(isDragging) { 
                    // NEW: If mouse moves more than a few pixels, consider it a drag
                    if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
                        hasDragged = true;
                    }
                    globalState.x = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX; globalState.y = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY; el.style.left = `${globalState.x}px`; el.style.top = `${globalState.y}px`; 
                    // Throttled redraw using requestAnimationFrame
                    if (!isRedrawQueued) {
                        isRedrawQueued = true;
                        requestAnimationFrame(() => {
                            redrawAll();
                            isRedrawQueued = false;
                        });
                    }
                }
            });
            document.addEventListener('mouseup', () => { if(isDragging) { isDragging = false; el.style.cursor = 'grab'; fitCanvasToNodesMinimally(); setTimeout(() => { hasDragged = false; }, 0); }});

            return el;
        }

        // --- Helper function to determine if a path is "naturally" C-shaped ---
        // This heuristic checks for the 6-point C-shape pattern generated by the
        // default router when a detour (C_DETOUR_OFFSET) is involved.
        function isPathNaturallyCShape(pathPoints, connection, fromNode, toNode) {
            if (pathPoints.length !== 6) {
                // console.log(`isPathNaturallyCShape for ${connection.id}: Path length is not 6, returning false.`);
                return false;
            }

            const p1_coord = pathPoints[0];
            const p2_stub_from_p1 = pathPoints[1];
            const mid1 = pathPoints[2];
            const mid2 = pathPoints[3];
            const p3_stub_to_p_end = pathPoints[4]; // This is the stub leading to the target port
            // const p_end_coord = pathPoints[5]; // Not directly used in this heuristic for now

            const fromPortType = connection.fromPortType;

            // Validate p2_stub_from_p1 based on ROUTING_STUB
            let expected_p2_x = p1_coord.x, expected_p2_y = p1_coord.y;
            if (fromPortType === 'left') expected_p2_x -= ROUTING_STUB;
            else if (fromPortType === 'right') expected_p2_x += ROUTING_STUB;
            else if (fromPortType === 'top') expected_p2_y -= ROUTING_STUB;
            else if (fromPortType === 'bottom') expected_p2_y += ROUTING_STUB;

            const isP2StubApproximatelyCorrect = (Math.abs(p2_stub_from_p1.x - expected_p2_x) < 1 && Math.abs(p2_stub_from_p1.y - expected_p2_y) < 1);

            if (!isP2StubApproximatelyCorrect) {
                // console.log(`isPathNaturallyCShape for ${connection.id}: p2_stub not as expected, returning false.`);
                return false;
            }

            // Check the C-shape detour pattern
            let cDetourPatternMatched = false;
            if (fromPortType === 'left' || fromPortType === 'right') {
                // For horizontal ports, the detour is vertical:
                // mid1.x should align with p2_stub_from_p1.x
                // mid2.x should align with p3_stub_to_p_end.x
                // mid1.y should be equal to mid2.y (this is the detour level)
                if (Math.abs(mid1.x - p2_stub_from_p1.x) < 1 &&
                    Math.abs(mid2.x - p3_stub_to_p_end.x) < 1 &&
                    Math.abs(mid1.y - mid2.y) < 1) {
                    // Check if the Y detour is significant, implying C_DETOUR_OFFSET was used
                    const yMidPointOfStubs = (p2_stub_from_p1.y + p3_stub_to_p_end.y) / 2;
                    if (Math.abs(mid1.y - yMidPointOfStubs) > ROUTING_STUB * 1.5) { // Heuristic: detour is larger than 1.5x stub
                        cDetourPatternMatched = true;
                    }
                }
            } else { // 'top' or 'bottom'
                // For vertical ports, the detour is horizontal:
                // mid1.y should align with p2_stub_from_p1.y
                // mid2.y should align with p3_stub_to_p_end.y
                // mid1.x should be equal to mid2.x (this is the detour level)
                if (Math.abs(mid1.y - p2_stub_from_p1.y) < 1 &&
                    Math.abs(mid2.y - p3_stub_to_p_end.y) < 1 &&
                    Math.abs(mid1.x - mid2.x) < 1) {
                    const xMidPointOfStubs = (p2_stub_from_p1.x + p3_stub_to_p_end.x) / 2;
                    if (Math.abs(mid1.x - xMidPointOfStubs) > ROUTING_STUB * 1.5) { // Heuristic
                        cDetourPatternMatched = true;
                    }
                }
            }
            // if (cDetourPatternMatched) {
            //     console.log(`%cDEBUG: isPathNaturallyCShape for ${connection.id} detected NATURAL C-SHAPE. Points:`, JSON.parse(JSON.stringify(pathPoints)), "FromNode:", fromNode.name, "ToNode:", toNode.name);
            // } else {
            //     console.log(`DEBUG: isPathNaturallyCShape for ${connection.id} did NOT detect natural C-shape. Points:`, JSON.parse(JSON.stringify(pathPoints)), "FromNode:", fromNode.name, "ToNode:", toNode.name);
            // }
            return cDetourPatternMatched;
        }

        // --- NEW: Master drawing function ---
        function redrawAll() {
            connectionSvg.innerHTML = '';
            // Re-add ghost elements first to ensure they are at the bottom of the SVG z-index
            connectionSvg.appendChild(ghostConnectionLine);
            connectionSvg.appendChild(ghostConnectionArrow);

            drawConnections();
            drawGuardConnections();
        }


       async function drawConnections() {
            // This function now ONLY draws regular state-to-state connections.

            const nodePortConnectionsMap = {};
            connections.forEach(conn => {
                if ((conn.fromPortType === 'top' || conn.fromPortType === 'bottom') ||
                    (conn.toPortType === 'top' || conn.toPortType === 'bottom')) {
                    // console.warn(`Skipping drawing connection ${conn.id} as it uses a disabled port type.`);
                    return;
                }

                if (!nodePortConnectionsMap[conn.fromNodeId]) nodePortConnectionsMap[conn.fromNodeId] = {};
                if (!nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType]) nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType] = { outgoing: [], incoming: [] };
                nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType].outgoing.push(conn);

                if (!nodePortConnectionsMap[conn.toNodeId]) nodePortConnectionsMap[conn.toNodeId] = {};
                if (!nodePortConnectionsMap[conn.toNodeId][conn.toPortType]) nodePortConnectionsMap[conn.toNodeId][conn.toPortType] = { outgoing: [], incoming: [] };
                nodePortConnectionsMap[conn.toNodeId][conn.toPortType].incoming.push(conn);
            });

            const activeNode = nodes.find(n => n.isActive);

            connections.forEach(conn => {
                 if ((conn.fromPortType === 'top' || conn.fromPortType === 'bottom') ||
                    (conn.toPortType === 'top' || conn.toPortType === 'bottom')) {
                    return;
                }
                const fromNode = nodes.find(n => n.id === conn.fromNodeId);
                const toNode = nodes.find(n => n.id === conn.toNodeId);

                if (fromNode && toNode) {
                    let actualForceCShapeForThisDraw = conn.forceCShape; // Start with the stored property

                    // Check for paired connection and adjust actualForceCShapeForThisDraw
                    const pairedConnection = connections.find(pConn =>
                        pConn.fromNodeId === conn.toNodeId && pConn.toNodeId === conn.fromNodeId
                    );

                    if (pairedConnection) { // This connection is part of a loop
                        if (conn.forceCShape === true) {
                            // This 'conn' is the one initially designated to be C-shaped.
                            // Let's check its pair's natural shape.
                            const pairedFromNode = toNode; // Pair's fromNode is current conn's toNode
                            const pairedToNode = fromNode;   // Pair's toNode is current conn's fromNode

                            const pairedPathPoints = calculateOrthogonalPathPoints(
                                pairedConnection,
                                pairedFromNode,
                                pairedToNode,
                                nodePortConnectionsMap, // Use the full map for correct indexing
                                false // Calculate natural path for the pair
                            );

                            if (isPathNaturallyCShape(pairedPathPoints, pairedConnection, pairedFromNode, pairedToNode)) {
                                // If the 'paired' connection (which should be straight) is NATURALLY C-shaped,
                                // then this 'conn' (originally forced C) should become straight.
                                // console.log(`%cLoop Logic SWAP: Paired ${pairedConnection.id} is naturally C. ${conn.id} becomes STRAIGHT.`, "color: blue;");
                                actualForceCShapeForThisDraw = false;
                            } else {
                                // If the 'paired' connection is straight, this 'conn' remains forced C.
                                // console.log(`%cLoop Logic KEEP: Paired ${pairedConnection.id} is straight. ${conn.id} remains C-FORCED.`, "color: green;");
                                actualForceCShapeForThisDraw = true; // Explicitly set to true
                            }
                        } else {
                            // This 'conn' is the one initially designated to be straight in the loop.
                            // It should always be drawn with its natural path (unless its partner becomes C-shaped naturally,
                            // in which case this 'conn' might need to become C if its partner's C is not ideal - this part is complex
                            // and the current logic simplifies it to: the conn.forceCShape=false one is always natural).
                            // For now, we keep it simple: the one not marked forceCShape is always drawn naturally.
                            actualForceCShapeForThisDraw = false;
                        }
                    }
                    // If not part of a pair, actualForceCShapeForThisDraw just remains conn.forceCShape

                    const uniquePathPoints = calculateOrthogonalPathPoints(
                        conn,
                        fromNode,
                        toNode,
                        nodePortConnectionsMap,
                        actualForceCShapeForThisDraw // Use the dynamically determined value
                    );

                    if (uniquePathPoints.length < 2) {
                        // console.warn("Path has less than 2 unique points for drawing:", conn.id, uniquePathPoints);
                        return;
                    }

                    // Generate the full path string with rounded corners
                    const d_str_full_rounded = getRoundedPathD(uniquePathPoints, ConnectionCornerRadius);

                    // Create a temporary path element to get total length
                    const tempPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempPathElement.setAttribute('d', d_str_full_rounded);
                    // connectionSvg.appendChild(tempPathElement); // Temporarily add to DOM to get length - NO, causes flicker

                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', d_str_full_rounded); // Always set the full rounded path
                    pathElement.classList.add('connection-line');
                    pathElement.dataset.connectionId = conn.id;

                    // Apply stroke-dasharray and stroke-dashoffset for visual truncation
                    // Must append to SVG to get total length correctly
                    connectionSvg.appendChild(pathElement);
                    const totalLength = pathElement.getTotalLength(); // Get length after appending
                    const desiredLength = Math.max(0, totalLength - 6); // End the line 6px before the tip
                    pathElement.style.strokeDasharray = totalLength;
                    pathElement.style.strokeDashoffset = totalLength - desiredLength; // This creates the gap


                    if (activeNode && conn.fromNodeId === activeNode.id) {
                        pathElement.classList.add('active-connection');
                    }

                    // Arrow tip and direction now use the full path's end point (p4_coord from uniquePathPoints)
                    const arrowTip = uniquePathPoints[uniquePathPoints.length - 1];
                    const preArrowTip = uniquePathPoints[uniquePathPoints.length - 2];

                    if (!preArrowTip) {
                        // console.warn("Could not determine preArrowTip for arrow:", conn.id, uniquePathPoints);
                        if (uniquePathPoints.length === 1) {
                            // preArrowTip = { x: arrowTip.x - 1, y: arrowTip.y }; // Arbitrary point for direction
                        } else {
                            return;
                        }
                    }

                    const dx_arrow = arrowTip.x - preArrowTip.x;
                    const dy_arrow = arrowTip.y - preArrowTip.y;

                    const angle = Math.atan2(dy_arrow, dx_arrow);
                    const arrowSize = 12; /* Made arrowhead slightly bigger */
                    const arrowWingAngle = Math.PI / 7;

                    let finalArrowYOffset = 0;
                    // Apply ARROW_Y_OFFSET only if the line segment is primarily horizontal
                    if (Math.abs(dx_arrow) > Math.abs(dy_arrow)) {
                        finalArrowYOffset = ARROW_Y_OFFSET;
                    }

                    const arrowX1 = arrowTip.x - arrowSize * Math.cos(angle - arrowWingAngle);
                    const arrowY1 = arrowTip.y - arrowSize * Math.sin(angle - arrowWingAngle) + finalArrowYOffset;
                    const arrowX2 = arrowTip.x - arrowSize * Math.cos(angle + arrowWingAngle);
                    const arrowY2 = arrowTip.y - arrowSize * Math.sin(angle + arrowWingAngle) + finalArrowYOffset;

                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // A path for a sharp, filled arrowhead
                    const d = `M ${arrowTip.x},${arrowTip.y + finalArrowYOffset} L ${arrowX1},${arrowY1} L ${arrowX2},${arrowY2} Z`;
                    arrow.setAttribute('d', d);
                    arrow.setAttribute('fill', '#3498db'); // Match line color
                    arrow.style.pointerEvents = 'none';

                    arrow.style.opacity = '1.0'; /* Make arrow fully opaque */
                    connectionSvg.appendChild(arrow);


                    // Text positioning: Calculate position on the VISIBLE path based on ConnectionTextPositionPercentage
                    // Use the actual pathElement that's in the DOM for getPointAtLength
                    const textAnchorPoint = pathElement.getPointAtLength(desiredLength * (ConnectionTextPositionPercentage / 100));


                    const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    textGroup.dataset.connectionId = conn.id; textGroup.classList.add('connection-text-group');
                    // Use the calculated point for positioning
                    textGroup.setAttribute('transform', `translate(${textAnchorPoint.x}, ${textAnchorPoint.y})`);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.classList.add('connection-text');

                    // --- MODIFIED: Dissssplay interaction type on the connection line ---
                    // --- NEW: Add bezier icon for tweened transitions ---
                    let tweenIcon = '';
                    if (conn.transitionType === 'Tweened') {
                        // Unicode for a bezier-like curve icon. Using a simple SVG path would be more complex here.
                        // This relies on a font that supports this character or a similar-looking one.
                        tweenIcon = ' '; // This is the "SINE WAVE" character, which looks like a simple bezier curve.
                    }
                    const preset = INTERACTION_PRESETS.find(p => p.id === conn.interactionType);
                    let connectionTextContent = preset?.shortName || preset?.name || conn.interactionType;
                    if (conn.interactionType === 'OnLoopComplete') {
                        connectionTextContent = `Loops: ${conn.interactionDetails.loopCount || 1}`;
                    }else if (conn.interactionType.startsWith('onPointer')) { 
                        connectionTextContent = `${preset?.shortName || preset?.name || conn.interactionType}`;
                    } else if (conn.interactionType === 'onClick') { // Simplify for 'onClick'
                        connectionTextContent = 'Click';
                    } else if (conn.interactionType === 'CustomEvent') {
                        connectionTextContent = `Event: ${conn.interactionDetails.customEventName || 'N/A'}`;
                    } else if (conn.interactionType === 'Direct') {
                         connectionTextContent = 'Direct';
                    }

                    if (Array.isArray(conn.action) && conn.action.length > 0 && globalState) {
                        
                        // 1. Find ALL active actions for this connection
                        const activeActions = conn.action.filter(a => a.type && a.type !== '');
                        
                        let actionText = '';

                        if (activeActions.length === 1) {
                            // 2. Exactly one action: Show its details
                            const firstAction = activeActions[0];
                            switch (firstAction.type) {
                                case 'Increment':
                                    actionText = ` |  +${firstAction.value || 1}`;
                                    break;
                                case 'Decrement':
                                    actionText = ` |  -${firstAction.value || 1}`;
                                    break;
                                case 'SetNumeric':
                                    actionText = ` |  ${firstAction.value}`;
                                    break;
                                case 'SetBoolean':
                                    const boolVal = (firstAction.value === 'true' || firstAction.value === true);
                                    actionText = ` |  ${boolVal}`;
                                    break;
                                case 'Toggle':
                                    actionText = ' | ';
                                    break;
                            }
                        } else if (activeActions.length > 1) {
                            // 3. More than one action: Show the generic bolt icon
                            actionText = ' | '; // Unicode bolt character
                        }
                        // 4. If activeActions.length === 0, actionText remains '' (empty string), so nothing is added.

                        connectionTextContent += actionText;
                    }
                    // --- END: REVISED ACTION DISPLAY LOGIC ---

                    // --- MODIFIED: Prepend the tween icon if it exists ---
                    text.textContent = tweenIcon + connectionTextContent;
                    // --- END MODIFIED ---

                    textGroup.appendChild(text);

                    connectionSvg.appendChild(textGroup);

                    const textBBox = text.getBBox();
                    const textPadding = 6;
                    const rectWidth = textBBox.width + textPadding * 2;
                    const rectHeight = textBBox.height + textPadding * 2;
                    const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    textBg.setAttribute('x', textBBox.x - textPadding);
                    textBg.setAttribute('y', textBBox.y - textPadding);
                    textBg.setAttribute('width', rectWidth); textBg.setAttribute('height', rectHeight);
                    textBg.classList.add('connection-text-bg'); 
                    textBg.setAttribute('rx', rectHeight / 2); // Make it fully rounded (pill shape)
                    textBg.setAttribute('ry', rectHeight / 2); // Make it fully rounded (pill shape)
                    textGroup.prepend(textBg);

                    textGroup.addEventListener('mousedown', (e) => {
                        startPillDrag(e, conn);
                    });
                    
                    textGroup.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Check the flag set by onPillDrop to see if a drag just happened
                        if (e.currentTarget.dataset.didJustDrag === "true") {
                            e.currentTarget.dataset.didJustDrag = "false"; // Reset flag
                            return; // Don't open the modal
                        }
                        // If no drag, open the modal as usual
                        openConnectionEditorModal(conn);
                    });
                    // --- END NEW ---
                }
            });
        }
        // --- NEW: Segregated function to draw only guard connections ---
function drawGuardConnections() {
            if (!globalState) return;

            guardConnections.forEach(conn => {
                const fromNode = globalState;
                const toNode = nodes.find(n => n.id === conn.toNodeId);

                if (fromNode && toNode) {
                    // Start point: The center of the global state node
                    const startPoint = {
                        x: fromNode.x + 60,
                        y: fromNode.y + 60
                    };

                    // End point: The center of the target state node
                    const endPoint = {
                        x: toNode.x + (NODE_WIDTH / 2),
                        y: toNode.y + (NODE_HEIGHT / 2)
                    };

                    // --- NEW: Calculate control points for a Bezier curve ---
                    const dx = endPoint.x - startPoint.x;
                    const dy = endPoint.y - startPoint.y;

                    // Control points are placed horizontally from the start/end points
                    // to create a smooth, flowing curve. The offset is a fraction of the horizontal distance.
                    const controlPoint1 = { x: startPoint.x + dx * 0.5, y: startPoint.y };
                    const controlPoint2 = { x: endPoint.x - dx * 0.5, y: endPoint.y };

                    const d_str = `M ${startPoint.x} ${startPoint.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${endPoint.x} ${endPoint.y}`;

                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', d_str);
                    pathElement.classList.add('guard-connection-line');
                    pathElement.dataset.connectionId = conn.id;

                    pathElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openGuardConditionModal(conn);
                    });

                    connectionSvg.appendChild(pathElement);

                    // --- NEW: Add text pill for the guard condition ---
                    const textPosition = pathElement.getPointAtLength(pathElement.getTotalLength() * 0.5);

                    const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    textGroup.dataset.connectionId = conn.id;
                    textGroup.classList.add('connection-text-group');
                    textGroup.setAttribute('transform', `translate(${textPosition.x}, ${textPosition.y})`);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.classList.add('guard-connection-text');

                    // --- MODIFIED: Improved text logic for "None" conditions ---
                    text.textContent = '';

                    // 1. Filter out conditions that are set to "None"
                    const activeConditions = conn.conditions.filter(c => c.condition !== 'None');

                    if (activeConditions.length === 0) {
                        // 2. If no active conditions, display "No conditions"
                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        tspan.setAttribute('x', 0);
                        tspan.textContent = 'No conditions';
                        text.appendChild(tspan);
                    } else {
                        // 3. If there are active conditions, display up to 2 of them
                        const conditionsToDisplay = activeConditions.slice(0, 2);
                        
                        conditionsToDisplay.forEach((condition, index) => {
                            const variable = globalState.inputs.find(v => v.id === condition.variableId);
                            if (variable) {
                                // --- NEW: Map condition ID to symbol for display ---
                                const conditionSymbols = {
                                    'Equal': '=',
                                    'NotEqual': '!=',
                                    'GreaterThan': '>',
                                    'LessThan': '<',
                                    'None': ''
                                };
                                const conditionSymbol = conditionSymbols[condition.condition] || condition.condition;
                                // --- END NEW ---
                                
                                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                tspan.setAttribute('x', 0);
                                if (index > 0) {
                                    tspan.setAttribute('dy', '2.2em'); // Increased line spacing
                                }

                                // --- START: MODIFIED to use tspans for pills ---
                                const variableTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                variableTspan.textContent = variable.name;
                                variableTspan.classList.add('variable-pill');

                                const operatorTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                operatorTspan.textContent = ` ${conditionSymbol} ${condition.value} `;
                                operatorTspan.setAttribute('dx', '8'); 

                                tspan.appendChild(variableTspan);
                                tspan.appendChild(operatorTspan);
                                // --- END: MODIFICATION ---

                                text.appendChild(tspan);
                            }
                        });

                        // 5. Show ellipsis if there are more than 2 active conditions
                        if (activeConditions.length > 2) {
                            const ellipsisTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            ellipsisTspan.setAttribute('x', 0);
                            ellipsisTspan.setAttribute('dy', '1.9em'); // Increased line spacing
                            ellipsisTspan.textContent = '...';
                            text.appendChild(ellipsisTspan);
                        }
                    }
                    // --- END MODIFIED ---
                            
                    // Append text elements to the DOM *before* measuring them
                    textGroup.appendChild(text);
                    connectionSvg.appendChild(textGroup);

                    // --- START: MOVED BLOCK ---
                    // This logic now runs *after* the text element is in the DOM.
                    text.querySelectorAll('.variable-pill').forEach(pillTspan => {
                        const bbox = pillTspan.getBBox(); // Now this will return correct dimensions
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        
                        // --- START: VERTICAL PADDING CHANGE ---
                        const innerHorizontalPadding = 6;
                        const innerVerticalPaddingTop = 2;
                        const innerVerticalPaddingBottom = 4; // Add more space at the bottom

                        rect.setAttribute('x', bbox.x - innerHorizontalPadding); 
                        rect.setAttribute('y', bbox.y - innerVerticalPaddingTop);
                        rect.setAttribute('width', bbox.width + (innerHorizontalPadding * 2)); 
                        rect.setAttribute('height', bbox.height + innerVerticalPaddingTop + innerVerticalPaddingBottom);
                        // --- END: VERTICAL PADDING CHANGE ---
                        
                        rect.classList.add('variable-pill-bg');
                        
                        // Insert the rect into the <g> (textGroup), right before the <text> element
                        textGroup.insertBefore(rect, text);
                    });
                    // --- END: MOVED BLOCK ---

                    const textBBox = text.getBBox(); // This BBox is for the main (outer) pill

                    // --- NEW PADDING CONTROLS ---
                    // You can adjust these four values independently
                    const paddingTop = 8;
                    const paddingBottom = 9;
                    const paddingLeft = 12;
                    const paddingRight = 10;
                    // --- END NEW PADDING CONTROLS ---

                    const rectWidth = textBBox.width + paddingLeft + paddingRight;
                    const rectHeight = textBBox.height + paddingTop + paddingBottom;
                    
                    const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    textBg.setAttribute('x', textBBox.x - paddingLeft); // Use paddingLeft
                    textBg.setAttribute('y', textBBox.y - paddingTop); // Use paddingTop
                    
                    textBg.setAttribute('width', rectWidth);
                    textBg.setAttribute('height', rectHeight);
                    textBg.classList.add('guard-connection-text-bg');

                    textGroup.prepend(textBg); // Prepend so it's behind the text

                    // Add click listener to the group as well
                    textGroup.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openGuardConditionModal(conn);
                    });
                    // --- END NEW TEXT PILL ---
                }
            });
        }
        // Function to draw the ghost line and arrow
        function drawGhostLine(fromNodeId, fromPortType, mouseX, mouseY) {
            if (!isConnecting || !firstNodeSelected) {
                ghostConnectionLine.style.display = 'none';
                ghostConnectionArrow.style.display = 'none'; // Arrow is always hidden for ghost line now
                return;
            }

            const sourceNode = nodes.find(n => n.id === fromNodeId);
            if (!sourceNode) return;

            const startPoint = getPortCoordinates(sourceNode, fromPortType);
            let endPoint = { x: mouseX, y: mouseY };

            // --- MODIFICATION: Use a Bezier curve for the ghost line ---
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;

            // Control points are placed to create a smooth curve.
            // The first control point is horizontal from the start, and the second is horizontal from the end.
            const controlPoint1 = { x: startPoint.x + dx * 0.5, y: startPoint.y };
            const controlPoint2 = { x: endPoint.x - dx * 0.5, y: endPoint.y };

            const d_str = `M ${startPoint.x} ${startPoint.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${endPoint.x} ${endPoint.y}`;
            ghostConnectionLine.setAttribute('d', d_str);
            ghostConnectionLine.style.display = 'block';
        }

        // --- NEW: Segregated function for the guard ghost line ---
        function drawGuardGhostLine(startPoint, endPoint) {
            // Use the same ghost-line element, but style it differently
            if (startPoint && endPoint) {
                const d_str = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
                ghostConnectionLine.setAttribute('d', d_str);
                ghostConnectionLine.style.stroke = '#dc3545'; // Solid Red
                ghostConnectionLine.style.strokeDasharray = 'none';
                ghostConnectionLine.style.display = 'block';
                ghostConnectionArrow.style.display = 'none';
            } else {
                // Hide it
                ghostConnectionLine.style.display = 'none';
            }
        }
        /*
        function addConnection(fromNodeId, fromPortTypeUserSelected, toNodeId, toPortTypeUserSelected) {
            if (fromPortTypeUserSelected === 'top' || fromPortTypeUserSelected === 'bottom' ||
                toPortTypeUserSelected === 'top' || toPortTypeUserSelected === 'bottom') {
                console.warn('Cannot create connections using top or bottom ports as they are disabled.');
                isConnecting = false; updateModeUI();
                return;
            }
            if (fromNodeId === toNodeId && fromPortTypeUserSelected === toPortTypeUserSelected) {
                 console.warn('Cannot connect a node to its own same port.');
                 isConnecting = false; updateModeUI();
                 return;
            }

            const existingConnectionInThisDirection = connections.some(c =>
                c.fromNodeId === fromNodeId && c.toNodeId === toNodeId
            );

            if (existingConnectionInThisDirection) {
                console.warn(`A connection from node ${fromNodeId} to node ${toNodeId} already exists.`);
                connectionExistsIndicator.style.display = 'block';
                setTimeout(() => { connectionExistsIndicator.style.display = 'none'; }, 3000);
                isConnecting = false; updateModeUI();
                return;
            }

            let finalFromPortType = fromPortTypeUserSelected;
            let finalToPortType = toPortTypeUserSelected;
            let forceCShapeForPath = false;

            const existingReverseConnection = connections.find(c =>
                c.fromNodeId === toNodeId && c.toNodeId === fromNodeId
            );

            if (existingReverseConnection) {
                // A loop is being formed.
                // The new connection (fromNodeId -> toNodeId) should use the opposite ports
                // of what the existingReverseConnection uses on these nodes.

                // Port used by existingReverseConnection on fromNodeId (which is existingReverseConnection.toNodeId)
                const portUsedOnFromNodeByExisting = existingReverseConnection.toPortType;
                // Port used by existingReverseConnection on toNodeId (which is existingReverseConnection.fromNodeId)
                const portUsedOnToNodeByExisting = existingReverseConnection.fromPortType;

                finalFromPortType = getOppositePort(portUsedOnFromNodeByExisting);
                finalToPortType = getOppositePort(portUsedOnToNodeByExisting);

                console.log(`Loop detected. New connection from ${fromNodeId} to ${toNodeId}.`);
                console.log(`  Existing (rev): ${existingReverseConnection.fromNodeId}.${existingReverseConnection.fromPortType} -> ${existingReverseConnection.toNodeId}.${existingReverseConnection.toPortType}`);
                console.log(`  New connection ports forced to: ${fromNodeId}.${finalFromPortType} -> ${toNodeId}.${finalToPortType}`);

                forceCShapeForPath = false; // The new connection (loop back) is initially straight.
                existingReverseConnection.forceCShape = true; // The first connection becomes the C-shape candidate.
            }


            const newConnection = {
                id: generateId(),
                fromNodeId,
                fromPortType: finalFromPortType,
                toNodeId,
                toPortType: finalToPortType,
                transitionType: 'Transition', // Default to standard Transition
                duration: 0.5,
                easing: [0, 0, 1, 1], // Default to linear
                interactionType: 'onComplete', // Default interaction preset
                interactionDetails: {}, // Initialize empty object for details
                forceCShape: forceCShapeForPath
            };
            connections.push(newConnection);



            fitCanvasToNodesMinimally();
            isConnecting = false;
            updateModeUI();
        }
        */


        function addConnection(fromNodeId, fromPortTypeUserSelected, toNodeId, toPortTypeUserSelected) {
            if (fromPortTypeUserSelected === 'top' || fromPortTypeUserSelected === 'bottom' ||
                toPortTypeUserSelected === 'top' || toPortTypeUserSelected === 'bottom') {
                console.warn('Cannot create connections using top or bottom ports as they are disabled.');
                isConnecting = false; updateModeUI();
                return;
            }
            if (fromNodeId === toNodeId && fromPortTypeUserSelected === toPortTypeUserSelected) {
                 console.warn('Cannot connect a node to its own same port.');
                 isConnecting = false; updateModeUI();
                 return;
            }

            const existingConnectionInThisDirection = connections.some(c =>
                c.fromNodeId === fromNodeId && c.toNodeId === toNodeId
            );

            if (existingConnectionInThisDirection) {
                console.warn(`A connection from node ${fromNodeId} to node ${toNodeId} already exists.`);
                connectionExistsIndicator.style.display = 'block';
                setTimeout(() => { connectionExistsIndicator.style.display = 'none'; }, 3000);
                isConnecting = false; updateModeUI();
                return;
            }

            let finalFromPortType = fromPortTypeUserSelected;
            let finalToPortType = toPortTypeUserSelected;
            let forceCShapeForPath = false;

            const existingReverseConnection = connections.find(c =>
                c.fromNodeId === toNodeId && c.toNodeId === fromNodeId
            );

            if (existingReverseConnection) {
                // A loop is being formed.
                // The new connection (fromNodeId -> toNodeId) should use the opposite ports
                // of what the existingReverseConnection uses on these nodes.

                // Port used by existingReverseConnection on fromNodeId (which is existingReverseConnection.toNodeId)
                const portUsedOnFromNodeByExisting = existingReverseConnection.toPortType;
                // Port used by existingReverseConnection on toNodeId (which is existingReverseConnection.fromNodeId)
                const portUsedOnToNodeByExisting = existingReverseConnection.fromPortType;

                finalFromPortType = getOppositePort(portUsedOnFromNodeByExisting);
                finalToPortType = getOppositePort(portUsedOnToNodeByExisting);

                console.log(`Loop detected. New connection from ${fromNodeId} to ${toNodeId}.`);
                console.log(`  Existing (rev): ${existingReverseConnection.fromNodeId}.${existingReverseConnection.fromPortType} -> ${existingReverseConnection.toNodeId}.${existingReverseConnection.toPortType}`);
                console.log(`  New connection ports forced to: ${fromNodeId}.${finalFromPortType} -> ${toNodeId}.${finalToPortType}`);

                forceCShapeForPath = false; // The new connection (loop back) is initially straight.
                
                // --- START: MODIFICATION ---
                // Check if this is a right-to-right AND left-to-left loop.
                const isR2R_L2L_Loop = 
                    (existingReverseConnection.fromPortType === 'right' && existingReverseConnection.toPortType === 'right' && finalFromPortType === 'left' && finalToPortType === 'left') ||
                    (existingReverseConnection.fromPortType === 'left' && existingReverseConnection.toPortType === 'left' && finalFromPortType === 'right' && finalToPortType === 'right');

                if (isR2R_L2L_Loop) {
                    // This is the user's scenario. Do NOT force a C-shape.
                    // Both connections will use their natural S-bend path.
                    existingReverseConnection.forceCShape = false; 
                } else {
                    // This is a standard right-to-left loop. Force the C-shape.
                    existingReverseConnection.forceCShape = true;
                }
                // --- END: MODIFICATION ---
            }


            const newConnection = {
                id: generateId(),
                fromNodeId,
                fromPortType: finalFromPortType,
                toNodeId,
                toPortType: finalToPortType,
                transitionType: 'Transition', // Default to standard Transition
                duration: 0.5,
                easing: [0, 0, 1, 1], // Default to linear
                interactionType: 'onComplete', // Default interaction preset
                interactionDetails: {}, // Initialize empty object for details
                forceCShape: forceCShapeForPath
            };
            connections.push(newConnection);



            fitCanvasToNodesMinimally();
            isConnecting = false;
            updateModeUI();
        }

        function deleteConnection(connectionId) {
            const deletedConn = connections.find(c => c.id === connectionId);
            connections = connections.filter(conn => conn.id !== connectionId);

            if (deletedConn) {
                // If the deleted connection was part of a loop and was the C-shape candidate,
                // its pair (which is now no longer part of a loop) should revert to not being forced.
                const pairedConnection = connections.find(pConn =>
                    pConn.fromNodeId === deletedConn.toNodeId && pConn.toNodeId === deletedConn.fromNodeId
                );
                if (pairedConnection && deletedConn.forceCShape === true) {
                    pairedConnection.forceCShape = false; // No longer needs to be a C-shape candidate
                    // console.log(`Loop broken by deleting ${deletedConn.id}. Paired connection ${pairedConnection.id} forceCShape reset to false.`);
                }
                 // If the deleted connection was the *straight* one in a loop, its pair (which was C-shape candidate)
                 // should also revert to not being forced C-shape as the loop is broken.
                else if (pairedConnection && deletedConn.forceCShape === false && pairedConnection.forceCShape === true) {
                    pairedConnection.forceCShape = false;
                     // console.log(`Loop broken by deleting ${deletedConn.id}. Paired C-shape candidate ${pairedConnection.id} forceCShape reset to false.`);
                }
            }

            fitCanvasToNodesMinimally();
            connectionEditorModal.classList.remove('open'); // FIX: Use classList to trigger animation
            selectedConnectionForEdit = null; updateModeUI();
        }


        canvasContainer.addEventListener('mousedown', startPan);
        connectionSvg.addEventListener('mousedown', startPan);
        function startPan(e) {
            if (e.target.closest('.node') || e.target.closest('.global-state-node') || e.target.classList.contains('connection-line') || e.target.classList.contains('guard-connection-line') || e.target.classList.contains('connection-text-bg')) return;
            
            canvasContainer.style.transition = 'none';
            isPanningCanvas = true;
            lastMouseX = e.clientX; lastMouseY = e.clientY;
            canvasContainer.style.cursor = 'grabbing'; connectionSvg.style.cursor = 'grabbing';
            if (flowchartArea.style.cursor !== 'grabbing') flowchartArea.style.cursor = 'grabbing';
            e.preventDefault(); e.stopPropagation();
        }
        
        flowchartArea.addEventListener('mousemove', (e) => {
            if (isPanningCanvas) {
                let deltaX = e.clientX - lastMouseX, deltaY = e.clientY - lastMouseY;
                let newPanOffsetX = panOffsetX + deltaX, newPanOffsetY = panOffsetY + deltaY;
                const caWidth = canvasContainer.offsetWidth;
                const caHeight = canvasContainer.offsetHeight;
                const faWidth = flowchartArea.offsetWidth;
                const faHeight = flowchartArea.offsetHeight;
                if (caWidth <= faWidth) newPanOffsetX = Math.max(0, Math.min(newPanOffsetX, faWidth - caWidth));
                else newPanOffsetX = Math.max(faWidth - caWidth, Math.min(newPanOffsetX, 0));
                if (caHeight <= faHeight) newPanOffsetY = Math.max(0, Math.min(newPanOffsetY, faHeight - caHeight));
                else newPanOffsetY = Math.max(faHeight - caHeight, Math.min(newPanOffsetY, 0));
                panOffsetX = newPanOffsetX; panOffsetY = newPanOffsetY;
                canvasContainer.style.left = `${panOffsetX}px`; canvasContainer.style.top = `${panOffsetY}px`;
                lastMouseX = e.clientX; lastMouseY = e.clientY;
            } else if (isConnecting && firstNodeSelected) {
                // Get the bounding box of the pannable SVG container.
                const canvasRect = canvasContainer.getBoundingClientRect();
                // Calculate the mouse position relative to the container's top-left corner.
                const svgMouseX = e.clientX - canvasRect.left;
                const svgMouseY = e.clientY - canvasRect.top;
                drawGhostLine(firstNodeSelected.id, firstPortType, svgMouseX, svgMouseY);

                // Handle destination port highlighting
                let hoveredNodeElement = null;
                for (const nodeData of nodes.filter(n => n.type !== 'action')) { // Don't highlight action nodes
                    const nodeElement = document.getElementById(nodeData.id);
                    if (nodeElement && nodeElement !== firstNodeSelected) {
                        const nodeRect = nodeElement.getBoundingClientRect();
                        if (e.clientX >= nodeRect.left && e.clientX <= nodeRect.right &&
                            e.clientY >= nodeRect.top && e.clientY <= nodeRect.bottom) {
                            hoveredNodeElement = nodeElement;
                            break;
                        }
                    }
                }

                if (hoveredNodeElement) {
                    if (currentHoveredDestinationNode && currentHoveredDestinationNode !== hoveredNodeElement) { 
                        currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port'); 
                        currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port'); 
                        if (currentHoveredDestinationNode !== firstNodeSelected) { 
                            currentHoveredDestinationNode.querySelector('.left-port').classList.add('hidden-by-js'); 
                            currentHoveredDestinationNode.querySelector('.right-port').classList.add('hidden-by-js'); 
                        }
                    }
                    currentHoveredDestinationNode = hoveredNodeElement;

                    const nodeRect = hoveredNodeElement.getBoundingClientRect();
                    const clickXRelativeToNode = e.clientX - nodeRect.left;
                    const hoveredPortType = (clickXRelativeToNode < hoveredNodeElement.offsetWidth / 2) ? 'left' : 'right';

                    const leftPort = hoveredNodeElement.querySelector('.left-port');
                    const rightPort = hoveredNodeElement.querySelector('.right-port');

                    leftPort.classList.remove('hidden-by-js'); 
                    rightPort.classList.remove('hidden-by-js'); 
                    leftPort.classList.remove('highlighted-destination-port');
                    rightPort.classList.remove('highlighted-destination-port');

                    if (hoveredPortType === 'left') {
                        leftPort.classList.add('highlighted-destination-port');
                    } else {
                        rightPort.classList.add('highlighted-destination-port');
                    }
                } else {
                    if (currentHoveredDestinationNode) { 
                        currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port'); 
                        currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port'); 
                        if (currentHoveredDestinationNode !== firstNodeSelected) { 
                            currentHoveredDestinationNode.querySelector('.left-port').classList.add('hidden-by-js'); 
                            currentHoveredDestinationNode.querySelector('.right-port').classList.add('hidden-by-js'); 
                        }
                        currentHoveredDestinationNode = null;
                    }
                }
            } else if (isCreatingGuardConnection && globalState) {
                // --- NEW: Handle ghost line for guard connection drag ---
                const startCoords = { x: globalState.x + 60, y: globalState.y + 93 };
                const canvasRect = canvasContainer.getBoundingClientRect();
                const endCoords = {
                    x: e.clientX - canvasRect.left,
                    y: e.clientY - canvasRect.top
                };
                // --- NEW: Prevent highlighting action nodes as targets ---
                const hoveredTarget = e.target.closest('.node-wrapper');
                if (hoveredTarget) {
                    const targetData = nodes.find(n => n.id === hoveredTarget.id);
                    if (targetData && targetData.type === 'action') {
                        document.body.style.cursor = 'not-allowed';
                    } else { document.body.style.cursor = ''; }
                } else { document.body.style.cursor = ''; }
                drawGuardGhostLine(startCoords, endCoords);
                // --- END NEW ---
            }
        });
        
        flowchartArea.addEventListener('mouseup', () => {
            if (isPanningCanvas) {
                isPanningCanvas = false;
                canvasContainer.style.cursor = 'grab'; connectionSvg.style.cursor = 'grab';
                if (flowchartArea.style.cursor !== 'default') flowchartArea.style.cursor = 'default';
                drawConnections(); 
                document.body.style.cursor = 'default'; // Reset cursor on mouse up
            }
        });
        
        flowchartArea.addEventListener('mouseleave', () => {
            if (isPanningCanvas) {
                isPanningCanvas = false;
                canvasContainer.style.cursor = 'grab';
                connectionSvg.style.cursor = 'grab';
                if (flowchartArea.style.cursor !== 'default') flowchartArea.style.cursor = 'default';
                drawConnections();
            }
        });

        // Function to close all custom dropdowns
        function closeAllCustomDropdowns() {
            document.querySelectorAll('.custom-dropdown-options.open').forEach(options => {
                options.classList.remove('open');
                // --- NEW: Also remove the overflow class from the parent ---
                options.closest('.variable-editor-block')?.classList.remove('dropdown-open');
            });
        }

        // --- New Function: Clear Flowchart ---
        function clearFlowchart() {
            // Remove all node elements from canvasContainer
            const nodeElements = canvasContainer.querySelectorAll('.node-wrapper');
            nodeElements.forEach(nodeEl => nodeEl.remove());

            // Clear internal data arrays
            nodes = [];
            connections = [];

            // Reset global state related to flowchart elements
            selectedNodeForEdit = null;
            selectedConnectionForEdit = null;
            firstNodeSelected = null;
            currentHoveredDestinationNode = null;
            isConnecting = false;

            // Call redrawAll to clear the SVG visually
            redrawAll();

            // Reset UI modes
            updateModeUI();

            // Reset pan and canvas size to default or minimal
            panOffsetX = 0;
            panOffsetY = 0;
            updateActionNodeButtonState(); // Update button state
            canvasContainer.style.left = '0px';
            canvasContainer.style.top = '0px';
            fitCanvasToNodesMinimally(); // This will set to default empty canvas size
        }

        // --- New Function: Find Initial Node ID for Export ---
        function findInitialNodeId() {
          const initialNode = nodes.find(n => n.isInitial);
            if (initialNode) {
                return initialNode.name; // Return the name of the explicitly initial node
            }
            const activeNode = nodes.find(n => n.isActive);
            if (activeNode) {
                return activeNode.name;
            }
            if (nodes.length > 0) {
                return nodes[0].name; // Fallback to the first node if none are active
            }
            return null; // Or a default string like 'default_initial_state'
        }

          // --- NEW: Reusable function to save connection settings without closing the modal ---
      function saveConnectionSettings() {
    if (!selectedConnectionForEdit) {
        console.warn("[Save Error] saveConnectionSettings called but no connection is selected for edit.");
        return;
    }

    const originalConnection = connections.find(c => c.id === selectedConnectionForEdit.id);
    if (!originalConnection) {
        console.error(`[Save Error] Could not find original connection with ID: ${selectedConnectionForEdit.id}`);
        return;
    }

    // --- All properties, INCLUDING 'action' array and 'openUrlAction' object, ---
    // --- have already been updated on tempConnectionData by the UI event listeners.
    // We just need to commit all changes from the temporary object to the original one.

    Object.assign(originalConnection, tempConnectionData);

    // --- The rest of the function remains the same ---

    updateSourceNodeLoopStatus(originalConnection.fromNodeId);

    const sourceNodeForCleanup = nodes.find(n => n.id === originalConnection.fromNodeId);
    if (sourceNodeForCleanup) {
        const animationForCleanup = availableAnimations.find(anim => anim.id === sourceNodeForCleanup.animationId);
        if (animationForCleanup && animationForCleanup.jsonContent) {
            let lottieJson = JSON.parse(animationForCleanup.jsonContent);
            const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes);
            if (removedCount > 0) {
                animationForCleanup.jsonContent = JSON.stringify(cleanedJson);
                if (selectedNodeForEdit && selectedNodeForEdit.id === sourceNodeForCleanup.id) {
                    openNodePropertiesModal(selectedNodeForEdit);
                }
            }
        }
    }

    redrawAll();
}


        window.addEventListener('load', async() => {
           
            const mainWrapper = document.getElementById('main-wrapper');
            const leftPanelToggle = document.getElementById('left-panel-toggle');

            // --- NEW: Toggle logic for the left panel ---
            leftPanelToggle.addEventListener('click', () => {
                mainWrapper.classList.toggle('left-panel-collapsed');
            });


            // --- NEW: Loader Logic ---
            const loaderOverlay = document.getElementById('loader-overlay');
            let dataLoadedViaMessage = false;

            // Set a timeout to hide the loader and start the app normally if no data is received
            const loadingTimeout = setTimeout(() => {
                if (!dataLoadedViaMessage) {
                    loaderOverlay.style.opacity = '0';
                    setTimeout(() => {
                        loaderOverlay.style.display = 'none';
                        addNode(); // Normal startup
                    }, 500); // Wait for fade-out transition
                }
            }, 2000); // 2-second wait

            // Listen for a message with the Lottie data
            window.addEventListener('message', (event) => {
                // Assuming the format is { type: 'lottieDataForStateMachine', lottieData: {...}, filename: '...' }
                if (event.data && event.data.type === 'lottieDataForStateMachine' && !dataLoadedViaMessage) {
                    console.log("Lottie data received via postMessage within 2 seconds.");
                    dataLoadedViaMessage = true;
                    clearTimeout(loadingTimeout); // Prevent the normal startup

                    // Process the received data (reusing the logic from the file input handler)
                    processAndLoadAnimation(event.data.lottieData, event.data.filename);

                    // --- FIX: If no state machine is provided, initialize with a default node ---
                    if (!event.data.stateMachine) {
                         setTimeout(() => {
                        addNode();}, 10);
                        // Create the initial "Idle" node
                        // Simulate a click on the newly active node to open its properties panel
                        
                    }

                    // --- NEW: Check for and load an incoming state machine JSON ---
                    if (event.data.stateMachine) {
                        console.log("State machine data also received via postMessage. Loading it now.");
                        try {
                            const stateMachineJson = event.data.stateMachine;

                            // Ensure converter functions are available
                            if (typeof convertJsonToNodesAndConnections !== 'function') {
                                throw new Error('State machine converter library not loaded correctly.');
                            }

                            // Use the converter to get UI data from the state machine JSON
                            const importedData = convertJsonToNodesAndConnections(stateMachineJson);

                            // Clear the existing flowchart before loading the new one
                            clearFlowchart();

                            // Populate the global data arrays with the imported data
                            nodes = importedData.nodes;
                            connections = importedData.connections;
                            globalState = importedData.globalState;
                            guardConnections = importedData.guardConnections;

                            // --- FIX: Explicitly set the initial node ---
                            const initialNodeFromImport = nodes.find(n => n.id === importedData.initialNodeId);
                            if (initialNodeFromImport) {
                                nodes.forEach(n => n.isInitial = false); // Clear any previous initial node
                                initialNodeFromImport.isInitial = true;
                            }

                            const importedInitialNodeId = importedData.initialNodeId;

                            // Render the global state node if it was imported
                            if (globalState) {
                                const globalStateEl = createGlobalStateElement(globalState);
                                canvasContainer.appendChild(globalStateEl);
                            }

                            // Render the new nodes from the state machine
                            nodes.forEach(nodeData => {
                                canvasContainer.appendChild(createNodeElement(nodeData));
                            });

                            fitCanvasToNodesMinimally(); // Adjust canvas to fit the new layout
                            updateNodeStyles(); // Apply active/initial styles

                            // 3. *** RUN CLEANUP LOGIC HERE ***
                            // Now that 'nodes' and 'connections' are populated, we can
                            // correctly clean the animation file.
                            console.log('[Post-Load Cleanup] Running cleanup for orphaned interactive layers...');
                            let totalRemoved = 0;
                            availableAnimations.forEach(anim => {
                                if (anim.jsonContent) {
                                    let lottieJson = JSON.parse(anim.jsonContent);
                                    
                                    // Pass the now-populated global arrays
                                    const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes); 
                                    
                                    if (removedCount > 0) {
                                        console.log(`[Post-Load Cleanup] Cleaned ${removedCount} orphaned layer(s) from animation '${anim.name}'.`);
                                        anim.jsonContent = JSON.stringify(cleanedJson); // Save the cleaned JSON
                                        totalRemoved += removedCount;
                                    }
                                }
                            });
                            if (totalRemoved > 0) {
                                populateLeftPanelMarkers(globalAnimationId); // Refresh UI if changes were made
                            }



                             setTimeout(() => {
                            console.log('[.lottie Load] Simulating click on initial node after import.');
                            const initialNodeToClick = nodes.find(n => n.isInitial);
                            if (initialNodeToClick) {
                                const initialNodeElement = document.getElementById(initialNodeToClick.id);
                                if (initialNodeElement) initialNodeElement.click();
                            }
                        }, 50); // Slight delay to ensure DOM is ready


                        } catch (error) {
                            console.error("Error processing state machine data from postMessage:", error);
                            showCustomAlert(`Error loading state machine: ${error.message}`);
                        }
                    }

                    // --- NEW: Hide UI elements for embedded mode ---
                    document.getElementById('global-animation-controls').style.display = 'none';

                    // Hide specific control buttons
                    const buttonsToHide = [
                        'add-segments-button',
                        'connect-nodes-button',
                        'add-animation-json-button',
                        'load-json-button',
                        'export-json-button',
                        'load-lottie-button',
                        'export-lottie-button'
                    ];
                    buttonsToHide.forEach(id => document.getElementById(id).style.display = 'none');

                    // Hide the loader
                    loaderOverlay.style.opacity = '0';
                    setTimeout(() => loaderOverlay.style.display = 'none', 500);
                }
            }, { once: true }); // Listen only for the first valid message
            // --- END NEW ---

            // --- NEW: Set the CSS custom property from the global JS variable ---
            document.documentElement.style.setProperty('--node-hover-padding', `${NODE_HOVER_AREA_PERCENTAGE}%`);
            // --- END NEW ---

            // --- NEW: Initialize and set up the global animation dropdown ---
            updateActionNodeButtonState(); // Initial check
            populateGlobalAnimationDropdown();

            globalAnimationControls.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = globalAnimationOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    globalAnimationOptionsContainer.classList.add('open');
                }
            });

            globalAnimationOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const selectedOption = e.target.closest('.custom-dropdown-option');
                if (selectedOption) {
                    const newAnimationId = selectedOption.dataset.value;
                    globalAnimationNativeSelect.value = newAnimationId;
                    globalAnimationDisplay.textContent = truncateText(selectedOption.textContent, 20);

                    globalAnimationOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    globalAnimationOptionsContainer.classList.remove('open');

                    // This is the key part: update the global state and all nodes
                    setGlobalAnimation(newAnimationId);
                }
            });
            // --- END NEW ---


            // Initialize DotLottie player for the modal preview
            modalDotLottiePlayer = new DotLottie({
                canvas: modalLottieCanvas,
                loop: true,
                autoplay: true,
                speed: 1.0
            });


            // addNode(); // This is now handled by the new loader logic

            flowchartArea.style.cursor = 'default';
            canvasContainer.style.cursor = 'grab'; connectionSvg.style.cursor = 'grab';
            canvasContainer.style.transition = 'none';

            // --- Event Listeners ---

            // NEW: Initial Node Toggle Logic
            previewTargetToggle.addEventListener('click', () => {
                previewTargetToggle.classList.toggle('active');
                const isActive = previewTargetToggle.classList.contains('active');
                
                // 1. Generate the list of valid layer names based on current transitions
                const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
                const pointerInteractionTypes = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
                const validLayerNames = [];

                connections.forEach(conn => {
                    if (pointerInteractionTypes.includes(conn.interactionType)) {
                        const fromNodeName = nodeIdToNameMap.get(conn.fromNodeId);
                        const toNodeName = nodeIdToNameMap.get(conn.toNodeId);
                        const interactionName = conn.interactionType.replace('on', '').toLowerCase();

                        if (fromNodeName && toNodeName) {
                            const layerName = `${fromNodeName}_${interactionName}_to_${toNodeName}`;
                            validLayerNames.push(layerName);
                        }
                    }
                });

                // 2. Pass the current animation data and the list to the function, then reload the player with the result
                if (modalDotLottiePlayer && currentPreviewAnimationData) {
                    // Pass the global preview data, get the modified version back, and update the global variable
                    currentPreviewAnimationData = hideInteractionLayers(currentPreviewAnimationData, validLayerNames, isActive); // shouldHide is true when toggle is OFF
                    modalDotLottiePlayer.load({
                            data: currentPreviewAnimationData
                        });
                    modalDotLottiePlayer.setLoop(true);
                    modalDotLottiePlayer.play();
                    console.log(`Preview Target Layers ${isActive ? 'HIDDEN' : 'SHOWN'}`);
                    
                }

                if (isActive) {
                    console.log("--- Valid Interactive Layer Names ---");
                    console.log(validLayerNames);
                }
            });

            initialNodeCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    if (initialNodeCheckbox.checked) {
                        // If checking this node as initial
                        nodes.forEach(node => {
                            node.isInitial = false; // Remove initial status from all other nodes
                            node.isActive = false; // Also deactivate other nodes
                        });
                        selectedNodeForEdit.isInitial = true; // Set this node as initial
                        selectedNodeForEdit.isActive = true; // Make it active too
                    } else {
                        // If unchecking this node as initial, automatically assign it to the next available node.
                        selectedNodeForEdit.isInitial = false;
                        const stillAnInitialNode = nodes.some(n => n.isInitial);

                        if (!stillAnInitialNode) {
                            // Find the first node that is NOT the one we just deselected.
                            const nextNode = nodes.find(n => n.id !== selectedNodeForEdit.id && n.type !== 'action');
                            if (nextNode) {
                                nextNode.isInitial = true; // Make it the new initial node.
                            } else if (nodes.filter(n => n.type !== 'action').length > 0) {
                                selectedNodeForEdit.isInitial = true; // Re-assign if it's the only one left.
                            }
                        }
                    }
                    updateNodeStyles(); // Re-render styles for all nodes
                }
            });


            // NEW: Event Listeners for Action Node Modal
            saveActionNodeProperties.addEventListener('click', () => {
    console.log('[LOG] Action Node save button clicked.');
    if (selectedNodeForEdit && selectedNodeForEdit.type === 'action') {
        console.log(`[LOG] Finalizing properties for node: ${selectedNodeForEdit.id}`);

        // --- 1. Filter out any "No action" types from variable actions ---
        if (Array.isArray(selectedNodeForEdit.action)) {
            selectedNodeForEdit.action = selectedNodeForEdit.action.filter(a => a.type && a.type !== '');
        }

        // --- 2. NEW: Read and save the URL action ---
        const urlInput = document.getElementById('action-node-url-input');
        const urlValue = urlInput.value.trim();

        if (urlValue) {
            // If there's a URL, create or update the action
            selectedNodeForEdit.openUrlAction = {
                type: 'OpenUrl',
                url: urlValue,
                target: '_blank' // You can make this configurable later
            };
            console.log(`[LOG] Saved URL action: ${urlValue}`);
        } else {
            // If the input is empty, remove the action
            selectedNodeForEdit.openUrlAction = null;
            console.log('[LOG] Cleared URL action.');
        }
        // --- END NEW ---
        
        // 3. Trigger one final update on the canvas node to be safe.
        const nodeWrapper = document.getElementById(selectedNodeForEdit.id);
        if (nodeWrapper) {
            updateActionNodeVisual(nodeWrapper.querySelector('.node'), selectedNodeForEdit);
        }
        
        console.log('[LOG] Final saved variable actions:', JSON.parse(JSON.stringify(selectedNodeForEdit.action)));

        // 4. Close the properties panel.
        closeNodePropertiesModal(); 

    } else {
        console.warn('[LOG] Save button clicked, but no action node is selected for edit.');
    }
});

            // Make the slider clickable for the initial node toggle
            initialNodeToggleGroup.querySelector('.slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                initialNodeCheckbox.checked = !initialNodeCheckbox.checked;
                initialNodeCheckbox.dispatchEvent(new Event('change'));
            });


            const exportLottieButton = document.getElementById('export-lottie-button'); // Get the new button

            exportLottieButton.addEventListener('click', async () => {
                saveNodePropertiesButton.click(); // Ensure current node properties are saved before export
                const initialNodeName = findInitialNodeId();

                // Find the globally selected animation from the available animations.
                const selectedAnimation = availableAnimations.find(anim => anim.id === globalAnimationId);

                if (!selectedAnimation) {
                    showCustomAlert("Cannot export: The globally selected animation could not be found.");
                    return;
                }

                // Pass only the selected animation to the export function.
                await exportLottieFile(nodes, connections, initialNodeName, globalState, guardConnections, [selectedAnimation]);
            });

            // --- New Event Listeners for .lottie Import ---
            // --- NEW: Event Listeners for single Lottie .json import ---
            addAnimationJsonButton.addEventListener('click', () => {
                animationJsonFileInput.click();
            });

            // --- NEW: Centralized function to process and load a new animation ---
           function processAndLoadAnimation(animationJson, fileName) {
                try {
                    // Basic Lottie validation
                    if (!animationJson.v || !animationJson.w || !animationJson.h || !animationJson.op) {
                        showCustomAlert("The provided data does not appear to be a valid Lottie JSON.");
                        return;
                    }

                    // --- CLEANUP CALL REMOVED FROM HERE ---
                    // It will be called later, after the state machine is loaded.

                    const animationId = fileName.replace(/\.json$/i, '').replace(/[^a-z0-9]/gi, '_');

                    // Process the JSON to add "Full Animation" marker and normalize `ip`
                    const processedJson = processSingleLottieJson(animationJson); // Use the raw JSON
                    const { markers } = extractMarkersFromLogic(JSON.stringify(processedJson));

                    const newAnimation = {
                        id: animationId,
                        name: animationId,
                        markers: markers,
                        jsonContent: JSON.stringify(processedJson),
                        clickLayers: new Set()
                    };

                    // Replace all existing animations with this new one.
                    availableAnimations = [newAnimation];
                    // --- FIX: Pass the new ID directly to ensure the correct animation is set globally ---
                    setGlobalAnimation(newAnimation.id, false); // Set the new animation, don't show alert yet.
                    populateGlobalAnimationDropdown(); // Now populate the dropdown with the correct state.

                    showCustomAlert(`Loaded '${newAnimation.name}' as the new global animation.`);
                } catch (error) {
                    console.error('Error processing animation data:', error);
                    showCustomAlert(`Error processing animation data: ${error.message}`);
                }
            }

            animationJsonFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const jsonContentString = e.target.result;
                    const animationJson = JSON.parse(jsonContentString);
                    processAndLoadAnimation(animationJson, file.name);
                    animationJsonFileInput.value = ''; // Clear the file input
                };
                reader.readAsText(file);
            });

            loadLottieButton.addEventListener('click', () => {
                lottieFileInput.click(); // Trigger the hidden .lottie file input
            });

            lottieFileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showCustomAlert("No .lottie file selected.");
                    return;
                }

  const animationMarkers = await extractAnimationMarkersFromLottie(file);
  availableAnimations = animationMarkers;
  // --- FIX: Reset the globalAnimationId after loading new animations ---
  globalAnimationId = null; 

  // Load the first animation's JSON into the player immediately after upload
  if (modalDotLottiePlayer && availableAnimations.length > 0 && availableAnimations[0].jsonContent) {
      modalDotLottiePlayer.load({
          // Use the global animation ID to load the correct animation
          data: JSON.parse(availableAnimations.find(a => a.id === globalAnimationId)?.jsonContent || availableAnimations[0].jsonContent),
          loop: true,
      });
  }

    console.log (JSON.stringify(animationMarkers, null, 2));

    // --- FIX: Refresh the properties panel if it's open for the active node ---
    populateGlobalAnimationDropdown(); // This will re-populate and trigger the update for all nodes
    // --- NEW: Simulate a click on the first animation in the dropdown ---
    const firstAnimationOption = globalAnimationOptionsContainer.querySelector('.custom-dropdown-option');
    if (firstAnimationOption) {
        console.log(`[LOG] Simulating click on first global animation: ${firstAnimationOption.textContent}`);
        firstAnimationOption.click();
    }
    // --- END NEW ---

                try {
                    // Call the extractStateMachineJson function
                    const extractedJsons = await extractStateMachineJson(file);

                    if (extractedJsons.length > 0) {
                        const firstStateMachineJson = extractedJsons[0]; // Take the first JSON found


                        // Ensure converter functions are available
                        if (typeof convertJsonToNodesAndConnections !== 'function' || typeof extractFrameRangeMarkersFromJson !== 'function') {
                            showCustomAlert('Error: State machine converter library not loaded correctly. Make sure statemachineconvertersimplified.js is loaded.');
                            return;
                        }

                        // Extract frame-range markers from the imported JSON
const processedJson = await processLottieStateMachineJson(firstStateMachineJson, availableAnimations);
                       const extractedFrameMarkers = extractFrameRangeMarkersFromJson(processedJson);
				  console.log("Loading first state machine JSON from .lottie:", JSON.stringify(processedJson, null, 2));
            console.log('Extracted Frame Markers from .lottie (StateMachine JSON):', extractedFrameMarkers);

            updateAvailableAnimationsWithNewMarkers(extractedFrameMarkers);

                        // --- FIX: Use the 'processedJson' which has been correctly structured ---
                        const importedData = convertJsonToNodesAndConnections(processedJson);

                        clearFlowchart(); // Clear existing canvas

                        nodes = importedData.nodes;
                        connections = importedData.connections;
                        globalState = importedData.globalState; // <-- This was the missing piece
                        guardConnections = importedData.guardConnections; // <-- This was the missing piece
                        const importedInitialNodeId = importedData.initialNodeId;
                updateActionNodeButtonState(); // Update button state after import

                        // --- FIX: Render the global state node if it was imported ---
                        if (globalState) {
                            const globalStateEl = createGlobalStateElement(globalState);
                            canvasContainer.appendChild(globalStateEl);
                        }
                        // --- END FIX ---

                        // Map animation names/IDs from imported JSON to availableAnimations IDs
                        nodes.forEach(node => {
                            const matchingAnimation = availableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
                            if (matchingAnimation) {
                                node.animationId = matchingAnimation.id;
                            } else {
                                console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations. Defaulting.`);
                                node.animationId = availableAnimations[0]?.id || '';
                            }
                        });

                        // Set the active node based on the imported initialNodeId
                        if (importedInitialNodeId) {
                          const initialNode = nodes.find(n => n.id === importedInitialNodeId);
                          if (initialNode) {
                              initialNode.isActive = true;
                              initialNode.isInitial = true; // NEW: Set isInitial for the imported initial node
                          } else if (nodes.length > 0) {
                              nodes[0].isActive = true; // Fallback if specified initial not found
                              nodes[0].isInitial = true; // NEW: Set isInitial for fallback
                          }
                      } else if (nodes.length > 0) {
                          nodes[0].isActive = true; // Fallback if no initial specified
                          nodes[0].isInitial = true; // NEW: Set isInitial for fallback
                      }

                        // Render new nodes
                        nodes.forEach(nodeData => {
                            canvasContainer.appendChild(createNodeElement(nodeData));
                        });

                        fitCanvasToNodesMinimally(); // Adjust canvas and apply positions
                        updateNodeStyles(); // Apply active styles
                        // --- NEW: Simulate a click on the initial node to open its properties ---
                       
                      
                        // --- END NEW ---
                        showCustomAlert("State machine loaded successfully from .lottie file!");

                        // --- NEW: Clean orphaned layers from all loaded animations after import ---
                        console.log('[Initial Load Cleanup] Running cleanup for orphaned interactive layers...');
                        let totalRemoved = 0;
                        availableAnimations.forEach(anim => {
                            if (anim.jsonContent) {
                                let lottieJson = JSON.parse(anim.jsonContent);
                                const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes);
                                if (removedCount > 0) {
                                    console.log(`[Initial Load Cleanup] Cleaned ${removedCount} orphaned layer(s) from animation '${anim.name}'.`);
                                    anim.jsonContent = JSON.stringify(cleanedJson);
                                    totalRemoved += removedCount;
                                }
                            }
                        });
                        if (totalRemoved > 0) {
                            populateLeftPanelMarkers(globalAnimationId); // Refresh UI if changes were made
                        }



                    } else {
                        // This block runs if the .lottie file contains animations but no state machine.
                        // --- NEW: Clean orphaned layers even if no state machine is found ---
                        console.log('[.lottie Load] No state machine found. Cleaning all animations based on empty flowchart.');
                        let totalRemoved = 0;
                        availableAnimations.forEach(anim => {
                            if (anim.jsonContent) {
                                let lottieJson = JSON.parse(anim.jsonContent);
                                // Pass empty arrays for connections and nodes to remove all interactive layers
                                const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, [], []);
                                if (removedCount > 0) {
                                    console.log(`[Initial Load Cleanup] Cleaned ${removedCount} orphaned layer(s) from animation '${anim.name}'.`);
                                    anim.jsonContent = JSON.stringify(cleanedJson);
                                    totalRemoved += removedCount;
                                }
                            }
                        });
                        if (totalRemoved > 0) {
                            populateLeftPanelMarkers(globalAnimationId); // Refresh UI if changes were made
                        }
                        // The user's intent is to load the animations and assign the first one to the current node.
                        showCustomAlert('Animations loaded. No state machine found in the .lottie file.');

                        const activeNode = nodes.find(n => n.isActive);
                        if (activeNode && availableAnimations.length > 0) {
                            // Get the first animation that was just loaded
                            const firstNewAnimation = availableAnimations[0];
                            
                            // Assign it to the currently active node
                            activeNode.animationId = firstNewAnimation.id;
                            activeNode.marker = ''; // Reset the marker as the animation has changed
                            
                            console.log(`Assigned new animation "${firstNewAnimation.name}" to node "${activeNode.name}".`);

                            // Update the node's visual representation on the canvas
                            updateNodeElement(activeNode);

                            // Re-open/refresh the properties modal for the active node to reflect the change
                            openNodePropertiesModal(activeNode);
                            
                            // --- FIX: Explicitly adjust aspect ratio after loading new animation ---
                            adjustPreviewAspectRatio(firstNewAnimation.id);
                        } else if (nodes.length > 0 && !activeNode) {
                            // --- FIX: If no node was active, just select the first one to be helpful ---
                            nodes[0].isActive = true;
                            updateNodeStyles();
                            // If no node was active, just select the first one to be helpful
                            nodes[0].isActive = true;
                            updateNodeStyles();
                            openNodePropertiesModal(nodes[0]);
                        }
                    }
                } catch (error) {
                    console.error('Error processing .lottie file:', error);
                    showCustomAlert(`Error loading .lottie file: ${error.message}. Please ensure it is a valid .lottie archive containing state machine JSONs in 'states/' folder.`);
                } finally {
                    lottieFileInput.value = ''; // Clear the file input
                }
            });
            // --- End New Event Listeners for .lottie Import ---





            // NEW: Add input event listener for nodeNameInput to save changes
            const broadcastEntryCheckbox = document.getElementById('broadcast-entry-checkbox');
            const broadcastExitCheckbox = document.getElementById('broadcast-exit-checkbox');

            broadcastEntryCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    selectedNodeForEdit.broadcastOnEntry = broadcastEntryCheckbox.checked;
                }
            });

            broadcastExitCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    selectedNodeForEdit.broadcastOnExit = broadcastExitCheckbox.checked;
                }
            });

            document.querySelector('#broadcast-entry-toggle-group .slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                broadcastEntryCheckbox.checked = !broadcastEntryCheckbox.checked;
                broadcastEntryCheckbox.dispatchEvent(new Event('change'));
            });

            document.querySelector('#broadcast-exit-toggle-group .slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                broadcastExitCheckbox.checked = !broadcastExitCheckbox.checked;
                broadcastExitCheckbox.dispatchEvent(new Event('change'));
            });

            // NEW: Event listener for Freeze on First Frame checkbox
                        freezeOnFirstFrameCheckbox.addEventListener('change', () => {
                            if (selectedNodeForEdit) {
                                selectedNodeForEdit.autoplay = !freezeOnFirstFrameCheckbox.checked; // If checked, autoplay is false
                                if (modalDotLottiePlayer) {
                                    if (selectedNodeForEdit.autoplay) {
                                        modalDotLottiePlayer.play();
                                    } else if (modalDotLottiePlayer) { // Check if player exists before freezing
                                        const currentAnimation = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
                                        let frameToFreezeAt = 0;
                                        if (currentAnimation) {
                                            let markerToUse = currentAnimation.markers.find(m => m.name === selectedNodeForEdit.marker);
                                            if (!markerToUse) {
                                                markerToUse = currentAnimation.markers.find(m => m.name === 'Full Animation');
                                            }

                                            if (markerToUse) {
                                                // If playing in reverse, freeze at the end frame. Otherwise, freeze at the start frame.
                                              
                                                if (playInReverseCheckbox.checked) {
                                                   //frameToFreezeAt = Math.round(markerToUse.end);
                                                    frameToFreezeAt = Math.round(markerToUse.start);
                                               } else {
                                                   frameToFreezeAt = Math.round(markerToUse.start);
                                               }
                                            }
                                        }
                                        //if(frameToFreezeAt>0) { frameToFreezeAt = frameToFreezeAt - 1; } // Slightly before the marker start for better visibility
                                        modalDotLottiePlayer.setFrame(frameToFreezeAt);
                                        modalDotLottiePlayer.freeze();
                                        console.log(`[Player Control] Freeze toggled ON. Player frozen at frame ${frameToFreezeAt}.`);
                                    }
                                }
                                // --- NEW: Instantly update the node on the canvas ---
                                const nodeElement = document.getElementById(selectedNodeForEdit.id);
                                if (nodeElement) {
                                    // Find the actual .node div inside the wrapper
                                    updateNodeDetailsChips(nodeElement.querySelector('.node'), selectedNodeForEdit);
                                }
                            }
                        });

                        // NEW: Event listener for Freeze on First Frame slider
                        document.querySelector('#freeze-on-first-frame-toggle-group .slider.round').addEventListener('click', (e) => {
                            e.stopPropagation();
                            freezeOnFirstFrameCheckbox.checked = !freezeOnFirstFrameCheckbox.checked;
                            freezeOnFirstFrameCheckbox.dispatchEvent(new Event('change'));
                        });

            animationDropdownGroup.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = animationOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    animationOptionsContainer.classList.add('open');
                }
            });

            markerDropdownGroup.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = markerOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    markerOptionsContainer.classList.add('open');
                }
            });

            animationOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const selectedOption = e.target.closest('.custom-dropdown-option');
                if (selectedOption) {
                    const value = selectedOption.dataset.value;
                    const text = selectedOption.textContent;
                    animationNativeSelect.value = value;
                    animationDisplay.textContent = text;
                    animationOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    animationOptionsContainer.classList.remove('open');
                    const changeEvent = new Event('change');
                    animationNativeSelect.dispatchEvent(changeEvent);


                    // Simulate a click on the currently active node
                    if (selectedNodeForEdit) {
                        const activeNodeElement = document.getElementById(selectedNodeForEdit.id);
                        if (activeNodeElement) {
                            activeNodeElement.click(); // This will re-open the modal and refresh its content
                        }
                    }
                }
            });

            markerOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                // NEW: Check for either a standard option or our custom button
                const selectedOption = e.target.closest('.custom-dropdown-option, [data-value="add_segment_action"]');
                if (selectedOption) {
                    const value = selectedOption.dataset.value;
                    // NEW: Handle special action for adding segments
                    if (value === 'add_segment_action') {
                        addSegmentsButton.click(); // Simulate click on the main button
                        closeAllCustomDropdowns();
                        return;
                    }
                    const text = selectedOption.textContent;
                    markerNativeSelect.value = value;
                    markerDisplay.textContent = text;
                    markerOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    markerOptionsContainer.classList.remove('open');
                    const changeEvent = new Event('change');
                    markerNativeSelect.dispatchEvent(changeEvent);
                }
            });

            // --- FIX: Add a dedicated listener for the loop count input ---
            loopCountInput.addEventListener('input', () => {
                if (tempConnectionData && tempConnectionData.interactionDetails) {
                    // Immediately update the temporary data when the loop count changes
                    tempConnectionData.interactionDetails.loopCount = parseInt(loopCountInput.value, 10) || 1;
                }
            });


            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown-group')) {
                    closeAllCustomDropdowns();
                }
            });


            const loopSlider = document.querySelector('#loop-checkbox + .slider.round');
            // const loopCheckbox = document.getElementById('loop-checkbox'); // Already defined globally

            if (loopSlider && loopCheckbox) {
                loopSlider.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loopCheckbox.checked = !loopCheckbox.checked;
                    const changeEvent = new Event('change');
                    loopCheckbox.dispatchEvent(changeEvent);
                });
            }

            loopCheckbox.addEventListener('change', () => {
               if (selectedNodeForEdit) {
                   selectedNodeForEdit.loop = loopCheckbox.checked;
                   // Theses were incorrectly placed here, broadcast checkboxes have their own listeners
                   // selectedNodeForEdit.broadcastOnEntry = broadcastEntryCheckbox.checked;
                   // selectedNodeForEdit.broadcastOnExit = broadcastExitCheckbox.checked;
                   if (modalDotLottiePlayer) {

       }
                   updateNodeDetailsChips(document.getElementById(selectedNodeForEdit.id)?.querySelector('.node'), selectedNodeForEdit);
               }
            });

            loadJsonButton.addEventListener('click', () => {
                jsonFileInput.click();
            });

            addActionNodeButton.addEventListener('click', addActionNode); // NEW
              addNodeButton.addEventListener('click', () => { addNode(); isConnecting = false; updateModeUI(); });
              connectNodesButton.addEventListener('click', () => {
                  isConnecting = !isConnecting; updateModeUI();
                  if (isConnecting) connectModeIndicator.textContent = 'Click a port on the source node, then a port on the target node.';
              });
              // NEW: Double-click on blank area to toggle the preview panel
              flowchartArea.addEventListener('dblclick', (e) => {
                  if (!e.target.closest('.node-wrapper') && !e.target.closest('.global-state-node') && !e.target.closest('.connection-text-group') && !e.target.classList.contains('connection-line')) {
                      previewToggleButton.click(); // Simulate a click to toggle visibility
                  }
              });
              flowchartArea.addEventListener('click', (e) => {
                  if (!e.target.closest('.node') && !e.target.closest('.connection-text-group') && !e.target.classList.contains('connection-line')) {
                        
                       // --- MODIFICATION: Prevent deselecting all nodes. At least one must remain active. ---
                      // nodes.forEach(n => n.isActive = false);
                      // updateNodeStyles();                                     
                  }
              });
              flowchartArea.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  if (isConnecting) { isConnecting = false; updateModeUI(); connectModeIndicator.textContent = 'Click a port on the source node, then a port on the target node.'; }
              });
              closeNodeModalButtons.forEach(button => button.addEventListener('click', closeNodePropertiesModal));

              animationNativeSelect.addEventListener('change', async() => {
               if (selectedNodeForEdit) {
                   // This listener is now obsolete because the dropdown is hidden.
                   // The global dropdown handles animation changes.
               }
           });

              markerNativeSelect.addEventListener('change', async() => {
                if (selectedNodeForEdit) {
                    const newMarkerName = markerNativeSelect.value; // e.g., "intro_segment"
                    selectedNodeForEdit.marker = newMarkerName;
                    /*
                    // --- NEW: Auto-fill node name based on selected marker ---
                    // We don't want to rename the node if "Full Animation" is selected.
                    if (newMarkerName && newMarkerName !== 'Full Animation') {
                        let potentialName = newMarkerName;
                        let counter = 1;
                        // Check for uniqueness against other nodes (excluding the one being edited)
                        while (nodes.some(n => n.name === potentialName && n.id !== selectedNodeForEdit.id)) {
                            potentialName = `${newMarkerName}_${counter++}`;
                        }

                        // Update the data model and the UI input field
                        selectedNodeForEdit.name = potentialName;
                        nodeNameInput.value = potentialName;

                        // Also update the node's title on the canvas immediately
                        const nodeElement = document.getElementById(selectedNodeForEdit.id)?.querySelector('.node');
                        if (nodeElement) {
                            nodeElement.querySelector('.node-title').textContent = selectedNodeForEdit.name;
                        }
                    }
                    // --- END NEW ---
                    */
                    // --- NEW: Synchronize click layer duration on marker change ---
                    const animationForSync = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
                    if (animationForSync && animationForSync.jsonContent) {
                        const lottieJson = JSON.parse(animationForSync.jsonContent);
                        const syncedJson = synchronizeClickLayers(lottieJson, selectedNodeForEdit.animationId);
                        animationForSync.jsonContent = JSON.stringify(syncedJson);
                        // Also update the live preview data if it's being shown
                        currentPreviewAnimationData = syncedJson;
                    }
                    // --- END NEW ---

                    // --- MODIFIED: Refresh the left panel and chips AFTER synchronizing the click layers ---
                    populateLeftPanelMarkers(selectedNodeForEdit.animationId);
                    updateNodeDetailsChips(document.getElementById(selectedNodeForEdit.id)?.querySelector('.node'), selectedNodeForEdit);

                    if (true) {
          const currentAnimation = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
          // --- FIX: If freeze is checked, go to start and stop, otherwise play ---
          if (freezeOnFirstFrameCheckbox.checked) {
              let frameToFreezeAt = 0;
              const markerNameForLookup = newMarkerName === 'Full Animation' ? 'Full Animation' : newMarkerName;
              const marker = currentAnimation?.markers.find(m => m.name === markerNameForLookup);
              if (marker) {
                  // If playing in reverse, freeze at the end frame. Otherwise, freeze at the start frame.
                 if (playInReverseCheckbox.checked) {
                     //frameToFreezeAt = Math.round(marker.end);
                     frameToFreezeAt = Math.round(marker.start);
                 } else {
                     frameToFreezeAt = Math.round(marker.start);
                 }
              }
              
              //if(frameToFreezeAt>0) { frameToFreezeAt = frameToFreezeAt - 1; }
              modalDotLottiePlayer.setFrame(frameToFreezeAt);
              modalDotLottiePlayer.freeze();

          } else if (selectedNodeForEdit.marker && currentAnimation) {
              const marker = currentAnimation.markers.find(m => m.name === selectedNodeForEdit.marker);
              if (marker) {
                console.log('am i even herrreeee?')
                  modalDotLottiePlayer.setSegment(marker.start, marker.end);
                  modalDotLottiePlayer.play();
              } else {
                  // If marker not found (e.g., "Full Animation"), set segment to full range
                  if (modalDotLottiePlayer.totalFrames > 0) {
                      modalDotLottiePlayer.setSegment(0, modalDotLottiePlayer.totalFrames);
                  }
                  modalDotLottiePlayer.play();
              }
          } else {
              // If no marker selected, play full animation by setting segment to full range
              if (modalDotLottiePlayer.totalFrames > 0) { modalDotLottiePlayer.setSegment(0, modalDotLottiePlayer.totalFrames); }
              modalDotLottiePlayer.play();
          }
      }
                }


              });


              saveNodePropertiesButton.addEventListener('click', () => {


                      if (selectedNodeForEdit) {
                          const newName = nodeNameInput.value.trim();
                          if (!newName) {
                              showCustomAlert("Node name cannot be empty.");
                              return;
                          }
                          const isDuplicate = nodes.some(node => node.name === newName && node.id !== selectedNodeForEdit.id);
                          if (isDuplicate) {
                              showCustomAlert(`Node name "${newName}" already exists. Please choose a unique name.`);
                              return;
                          }
                          selectedNodeForEdit.autoplay = !freezeOnFirstFrameCheckbox.checked; // NEW: Save autoplay state
                          selectedNodeForEdit.name = newName;
                          selectedNodeForEdit.speed = parseFloat(speedSlider.value);

                          // NEW LOGIC: Determine node.loop based on checkbox AND active OnLoopComplete connection
                          const onLoopCompleteConn = connections.find(conn =>
                              conn.fromNodeId === selectedNodeForEdit.id && conn.interactionType === 'onLoopComplete'
                          );
                          if (loopCheckbox.checked) {
                              // If the loop checkbox is checked AND there's an OnLoopComplete connection,
                              // set node.loop to the loopCount from that connection.
                              if (onLoopCompleteConn && typeof onLoopCompleteConn.interactionDetails.loopCount === 'number' && onLoopCompleteConn.interactionDetails.loopCount > 0) {
                                  selectedNodeForEdit.loop = onLoopCompleteConn.interactionDetails.loopCount;                              } else {
                                  // Otherwise, if checked but no specific loop count connection, it's boolean true.
                                  selectedNodeForEdit.loop = true; // This branch is fine.
                              }
                          } else {
                              // If checkbox is unchecked, loop is false, unless an onLoopComplete connection dictates otherwise.
                              selectedNodeForEdit.loop = onLoopCompleteConn ? (onLoopCompleteConn.interactionDetails.loopCount || 1) : false;
                          }

                          updateNodeElement(selectedNodeForEdit);
                          // Update broadcast text if name changed
                          const broadcastEntryNodeNameSpan = document.getElementById('broadcast-entry-node-name');
                          const broadcastExitNodeNameSpan = document.getElementById('broadcast-exit-node-name');
                          broadcastEntryNodeNameSpan.textContent = `${selectedNodeForEdit.name}_entry`;
                      }

                  });

              deleteNodeButton.addEventListener('click', () => {
                  const nodeToDelete = selectedNodeForEdit;
                  if (!nodeToDelete) { console.error("Delete Node button clicked, but no node is selected for editing."); return; }
                  showCustomConfirm('Are you sure you want to delete this node and its connections?', () => { deleteNode(nodeToDelete.id); });
              });

              speedSlider.addEventListener('input', () => {
                  const newSpeed = parseFloat(speedSlider.value);
                  speedValueSpan.textContent = newSpeed.toFixed(1) + 'x';
                  if (selectedNodeForEdit) {
                      selectedNodeForEdit.speed = newSpeed;
                  }
                  if (modalDotLottiePlayer) {
                      modalDotLottiePlayer.setSpeed(newSpeed);
                      modalDotLottiePlayer.play();
                  }
              });

              closeConnectionEditorButtons.forEach(button => button.addEventListener('click', closeConnectionEditorModal));

        


          


              interactionPresetNativeSelect.addEventListener('change', () => {
                    const selectedPresetId = interactionPresetNativeSelect.value;

                    if (tempConnectionData) {
                        tempConnectionData.interactionType = selectedPresetId;
                    }

                    const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
                    if (pointerEvents.includes(selectedPresetId)) {
                        openClickAreaEditor();
                        setTimeout(() => {
                            updateDynamicInteractionFields(selectedPresetId, tempConnectionData.interactionDetails || {});
                        }, 450);
                    } else {
                        updateDynamicInteractionFields(selectedPresetId, tempConnectionData.interactionDetails || {});
                    }

                    if (selectedPresetId === 'onLoopComplete') {
                        const fromNode = nodes.find(n => n.id === tempConnectionData.fromNodeId);
                        if (fromNode) {
                            fromNode.loop = parseInt(loopCountInput.value, 10) || 1;
                        }
                    }
                    
                    // --- REMOVED THE OBSOLETE CALLS TO updateActionsSection ---
                    
                    if (selectedNodeForEdit && selectedConnectionForEdit && selectedNodeForEdit.id === selectedConnectionForEdit.fromNodeId) {
                        const freezeToggleContainer = document.getElementById('freeze-on-first-frame-toggle-group');
                        const freezeToggleLabel = freezeToggleContainer.querySelector('label');

                        let shouldForceLoop = false;
                        let shouldDisableLoop = false;

                        // Check the newly selected interaction
                        if (selectedPresetId === 'onLoopComplete') {
                            shouldForceLoop = true;
                            shouldDisableLoop = true;
                        } else if (selectedPresetId === 'onComplete') {
                            shouldForceLoop = false;
                            shouldDisableLoop = true;
                        } else {
                            // Check other existing connections
                            const otherOutgoingConnections = connections.filter(
                                conn => conn.fromNodeId === selectedNodeForEdit.id && conn.id !== selectedConnectionForEdit.id
                            );
                            // --- FIX: Check for lowercase 'on...' ---
                            if (otherOutgoingConnections.some(conn => conn.interactionType === 'onLoopComplete')) {
                                shouldForceLoop = true;
                                shouldDisableLoop = true;
                            } else if (otherOutgoingConnections.some(conn => conn.interactionType === 'onComplete')) {
                                shouldForceLoop = false;
                                shouldDisableLoop = true;
                            }
                        }

                        // Apply the logic to the loop checkbox
                        if (shouldDisableLoop) {
                            loopCheckbox.checked = shouldForceLoop;
                        } else {
                            // No 'onComplete' or 'onLoopComplete' connections, so read from the node's data
                            const effectivelyLoops = (typeof selectedNodeForEdit.loop === 'boolean' && selectedNodeForEdit.loop === true) ||
                                                (typeof selectedNodeForEdit.loop === 'number' && selectedNodeForEdit.loop > 0);
                            loopCheckbox.checked = effectivelyLoops;
                        }
                    
                        // --- This is the original freeze-frame logic, which is still needed ---
                        if (shouldDisableLoop) { // <-- Use the new, correctly defined variable
                            freezeOnFirstFrameCheckbox.checked = false;
                            freezeToggleContainer.style.pointerEvents = 'none';
                            freezeToggleContainer.style.opacity = '0.4';
                            freezeToggleLabel.title = 'Cannot freeze frame when using an On Complete or On Loop Complete trigger.';
                        } else {
                            freezeToggleContainer.style.pointerEvents = 'auto';
                            freezeToggleContainer.style.opacity = '1.0';
                            freezeToggleLabel.title = '';
                        }
                    }
                });

 

       

       

        /**
         * Inserts a new shape layer into a Lottie animation's JSON data, intended to be used as a clickable area.
         * The layer is a transparent rectangle covering the entire animation area.
         * @param {object} animationData - The Lottie JSON data object.
         * @param {string} layerName - The desired name for the new layer (e.g., "StateName_click_area").
         * @param {string} [markerName] - Optional. The name of a marker to define the layer's in and out points.
         * @returns {object|null} The modified Lottie JSON data, or null if input is invalid.
         */
        function addClickAreaLayer(animationData, layerName, markerName) {
            // --- NEW: Log when this function is called ---
            console.log(`[LOG] Adding a new full-frame interactive layer named: "${layerName}"`);

             if (!animationData || !animationData.w || !animationData.h || !animationData.op) {
                 console.error("Invalid Lottie data: Missing width, height, or out-point.");
                 return null;
             }
 
             // Create a deep copy to avoid side effects
             const newData = JSON.parse(JSON.stringify(animationData));
             
             const frameWidth = newData.w;
             const frameHeight = newData.h;
 
             // --- Duration Logic ---
             let inPoint = 0;
             let outPoint = newData.op; // Default to the full animation duration
 
             if (markerName && newData.markers && newData.markers.length > 0) {
                 const targetMarker = newData.markers.find(marker => marker.cm === markerName);
                 if (targetMarker) {
                     inPoint = targetMarker.tm;
                     outPoint = targetMarker.tm + targetMarker.dr;
                     console.log(`Found marker "${markerName}". Setting layer duration from frame ${inPoint} to ${outPoint}.`);
                 } else {
                     console.warn(`Marker "${markerName}" not found. Defaulting to full animation duration.`);
                 }
             }
             // --- End Duration Logic ---
 
             // --- Find the highest current layer index to ensure our new layer has a unique one ---
             const maxIndex = newData.layers.reduce((max, layer) => Math.max(max, layer.ind || 0), 0);
             const newLayerIndex = maxIndex + 1;
             
             const newFrameLayer = {
                 "ddd": 0, "ty": 4, "nm": layerName, "sr": 1, "ind": newLayerIndex,
                 "ks": {
                     "o": { "a": 0, "k": 100, "ix": 11 },
                     "r": { "a": 0, "k": 0, "ix": 10 },
                     "p": { "a": 0, "k": [frameWidth / 2, frameHeight / 2, 0], "ix": 2 },
                     "a": { "a": 0, "k": [0, 0, 0], "ix": 1 },
                     "s": { "a": 0, "k": [100, 100, 100], "ix": 6 }
                 },
                 "ao": 0,
                 "shapes": [{
                     "ty": "gr", "nm": "Frame Group", "np": 3,
                     "it": [
                             { "ty": "rc", "nm": "Rectangle", "d": 1, "p": { "a": 0, "k": [0, 0], "ix": 2 }, "s": { "a": 0, "k": [frameWidth, frameHeight], "ix": 3 }, "r": { "a": 0, "k": 0, "ix": 4 } },
                             { "ty": "fl", "nm": "Gray Fill", "c": { "a": 0, "k": [0.5, 0.5, 0.5, 1], "ix": 3 }, "o": { "a": 0, "k": 10, "ix": 4 } },
                         { "ty": "tr", "nm": "Transform", "p": { "a": 0, "k": [0, 0], "ix": 2 }, "a": { "a": 0, "k": [0, 0], "ix": 1 }, "s": { "a": 0, "k": [100, 100], "ix": 3 }, "r": { "a": 0, "k": 0, "ix": 6 }, "o": { "a": 0, "k": 100, "ix": 7 }, "sk": { "a": 0, "k": 0, "ix": 4 }, "sa": { "a": 0, "k": 0, "ix": 5 } }
                     ],
                     "ks": { "o": { "a": 0, "k": 100 }, "r": { "a": 0, "k": 0 }, "p": { "a": 0, "k": [0, 0] }, "a": { "a": 0, "k": [0, 0] }, "s": { "a": 0, "k": [100, 100] } }
                 }],
                 "ip": inPoint, "op": outPoint, "st": inPoint, "bm": 0
             };
 
             // Add the new layer to the beginning of the layers array to render it first.
             newData.layers.unshift(newFrameLayer);
             
             return newData;
         }

        /**
         * Automatically finds the source node of a connection, checks if a click/hover layer is needed
         * for the selected interaction, and injects it into the Lottie JSON if it doesn't already exist.
         * @param {object} connection - The connection object being edited.
         * @param {string} interactionType - The newly selected interaction type (e.g., 'onClick').
         */
        function autoCreateInteractionLayer(connection, interactionType) {
            console.log(`[LOG] autoCreateInteractionLayer called for connection ${connection.id} with type: ${interactionType}`);
            // FIX: Use the correct lowercase 'on' prefix to match the values from INTERACTION_PRESETS.
            const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
            if (!pointerEvents.includes(interactionType)) {
                return; // Not an interaction that needs a layer
            }

            const fromNode = nodes.find(n => n.id === connection.fromNodeId);
            if (!fromNode) return;
            console.log(`[LOG] Found source node: ${fromNode.name}`);

            const animation = availableAnimations.find(anim => anim.id === fromNode.animationId);
            if (!animation || !animation.jsonContent) {
                console.error(`[LOG] ABORT: Lottie JSON for animation '${fromNode.animationId}' is not loaded.`);
                return;
            }
            console.log(`[LOG] Found animation data for: ${animation.name}`);

            // --- NEW: Generate transition-specific layer name ---
            const toNode = nodes.find(n => n.id === connection.toNodeId);
            const interactionName = interactionType.replace('on', '').toLowerCase();
            const layerName = `${fromNode.name}_${interactionName}_to_${toNode.name}`;

            // --- FIX: Check if a layer with the target name already exists in the JSON ---
            // This is more robust than the clickLayers set and prevents adding a duplicate layer.
            const currentJson = JSON.parse(animation.jsonContent);
            const layerAlreadyExists = currentJson.layers.some(layer => layer.nm === layerName);

            if (layerAlreadyExists) {
                console.log(`[LOG] autoCreateInteractionLayer: A layer named '${layerName}' already exists. Skipping default layer creation.`);
                return;
            }
            // --- END FIX ---

            // Add the click area layer
            console.log(`[LOG] Calling addClickAreaLayer with name: '${layerName}' and marker: '${fromNode.marker}'`);
            const modifiedJsonData = addClickAreaLayer(currentJson, layerName, fromNode.marker);

            if (modifiedJsonData) {
                // Define markerIdentifier to use for the clickLayers set.
                const markerIdentifier = fromNode.marker || 'full_animation';

                animation.jsonContent = JSON.stringify(modifiedJsonData);
                animation.clickLayers.add(markerIdentifier); // Mark this segment as having a click layer
                console.log(`[LOG] SUCCESS: Auto-created layer '${layerName}' and updated animation.jsonContent.`);
                showCustomAlert(`Auto-created layer: '${layerName}'`);

                // --- MODIFIED: Refresh the preview player and the entire properties panel ---
                if (selectedNodeForEdit && selectedNodeForEdit.id === fromNode.id && modalDotLottiePlayer) {
                    console.log("[LOG] Refreshing properties panel to reflect new interactive layer.");
                    // Update the global preview data with the modified JSON
                    currentPreviewAnimationData = modifiedJsonData;
                    // Simulate a click on the origin node's element to re-trigger openNodePropertiesModal
                    const fromNodeElement = document.getElementById(fromNode.id);
                    if (fromNodeElement) {
                        console.log(`[LOG] Simulating click on origin node '${fromNode.name}' to refresh properties panel.`);
                        fromNodeElement.click();
                    }
                }
            }
        }


                      saveConnectionEditorButton.addEventListener('click', () => {
                        if (selectedConnectionForEdit) {
                            saveConnectionSettings();

                            // --- NEW: Run the cleanup function after saving the transition ---
                            const sourceNodeForCleanup = nodes.find(n => n.id === selectedConnectionForEdit.fromNodeId);
                            if (sourceNodeForCleanup) {
                                const animationForCleanup = availableAnimations.find(anim => anim.id === sourceNodeForCleanup.animationId);
                                if (animationForCleanup && animationForCleanup.jsonContent) {
                                    let lottieJson = JSON.parse(animationForCleanup.jsonContent);
                                    const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes);
                                    if (removedCount > 0) {
                                        console.log(`[LOG] Cleaned ${removedCount} orphaned layer(s) after saving transition settings.`);
                                        // Update the master animation data with the cleaned version
                                        animationForCleanup.jsonContent = JSON.stringify(cleanedJson);

                                        // Refresh the preview player if it's showing this animation
                                        if (selectedNodeForEdit && selectedNodeForEdit.id === sourceNodeForCleanup.id && modalDotLottiePlayer) {
                                            openNodePropertiesModal(selectedNodeForEdit);
                                        }
                                    }
                                }
                            }
                            // --- NEW: Trigger the highlight animation on the connection pill ---
                            triggerConnectionPillAnimation(selectedConnectionForEdit.id);

                            transitionEditorStateBackup = null; // Prevent the close function from reverting the save
                            closeConnectionEditorModal();
                        }
                      });

                      // --- NEW: Function to trigger the shockwave animation on a connection pill ---
      function triggerConnectionPillAnimation(connectionId) {
          const textGroup = document.querySelector(`.connection-text-group[data-connection-id="${connectionId}"]`);
          if (textGroup) {
              const textBg = textGroup.querySelector('.connection-text-bg');
              if (!textBg) return;

              const pillX = parseFloat(textBg.getAttribute('x'));
              const pillY = parseFloat(textBg.getAttribute('y'));
              const pillWidth = parseFloat(textBg.getAttribute('width'));
              const pillHeight = parseFloat(textBg.getAttribute('height'));

              const shockwave = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
              // --- FIX: Create a square container for the animation to ensure it's a circle ---
              shockwave.setAttribute('x', pillX + (pillWidth / 2) - (pillHeight / 2)); // Center the square horizontally
              shockwave.setAttribute('y', pillY);
              shockwave.setAttribute('width', pillHeight); // Use height for both width and height
              shockwave.setAttribute('height', pillHeight);
              // --- NEW: Ensure the container doesn't clip the expanding animation ---
              shockwave.style.overflow = 'visible';
              shockwave.innerHTML = `<div xmlns="http://www.w3.org/1999/xhtml" class="shockwave"></div>`;
              
              textGroup.prepend(shockwave);

              setTimeout(() => shockwave.remove(), 600); // Remove after animation duration
          }
      }



              deleteConnectionButton.addEventListener('click', () => {
                   if (selectedConnectionForEdit) {
                      const connectionToDelete = selectedConnectionForEdit;
                      deleteConnection(connectionToDelete.id);
                  }
              });


    // --- NEW: Event listeners for node name validation on defocus or Enter key ---
            nodeNameInput.addEventListener('blur', () => {
                if (!selectedNodeForEdit) return; // Safety check

                const newName = nodeNameInput.value.trim();

                // Check 1: Is the input empty?
                if (!newName) {
                    // If empty on blur, revert to the original name without an alert.
                    nodeNameInput.value = selectedNodeForEdit.name;
                    return;
                }

                // Check 2: Is the new name a duplicate?
                const isDuplicate = nodes.some(node => node.name === newName && node.id !== selectedNodeForEdit.id);
                if (isDuplicate) {
                    showCustomAlert(`Node name "${newName}" already exists. Reverting to original name.`);
                    nodeNameInput.value = selectedNodeForEdit.name; // Revert to original name
                    return;
                }

                // If all checks pass, proceed with the save logic.
                saveNodePropertiesButton.click();
            });

             nodeNameInput.addEventListener('keydown', (e) => {
                // When 'Enter' is pressed, blur the input, which in turn triggers the 'blur' event listener.
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevents any default 'Enter' key behavior
                    nodeNameInput.blur();
                }
            });

            jsonFileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const jsonContent = e.target.result;
                const parsedJson = JSON.parse(jsonContent);
		//console.log('UPLOADED STATEMACHINE'+JSON.stringify(parsedJson));
                if (typeof convertJsonToNodesAndConnections !== 'function') {
                    showCustomAlert('Error: State machine converter library not loaded correctly.');
                    return;
                }

                // NEW STEP 1: Extract frame-range markers from the imported JSON
                const extractedFrameMarkers = extractFrameRangeMarkersFromJson(parsedJson);
		//console.log('Extracted Frame Markers from JSON:', extractedFrameMarkers); // Add this line


                // NEW STEP 2: Update availableAnimations with these new markers
                updateAvailableAnimationsWithNewMarkers(extractedFrameMarkers);

                const importedData = convertJsonToNodesAndConnections(parsedJson, availableAnimations);
                clearFlowchart(); // Clear existing canvas

                nodes = importedData.nodes;
                connections = importedData.connections;
                globalState = importedData.globalState; // NEW
                guardConnections = importedData.guardConnections; // NEW
                const importedInitialNodeId = importedData.initialNodeId;
                updateActionNodeButtonState(); // Update button state after import

                // NEW: Render global state node if it exists
                if (globalState) {
                    const globalStateEl = createGlobalStateElement(globalState);
                    canvasContainer.appendChild(globalStateEl);
                    // Dragging for global state node
                    let isDragging = false, offsetX, offsetY;
                    globalStateEl.addEventListener('mousedown', e => { isDragging = true; offsetX = e.clientX - globalStateEl.getBoundingClientRect().left; offsetY = e.clientY - globalStateEl.getBoundingClientRect().top; });
                    document.addEventListener('mousemove', e => { if(isDragging) { globalState.x = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX; globalState.y = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY; globalStateEl.style.left = `${globalState.x}px`; globalStateEl.style.top = `${globalState.y}px`; drawConnections(); }});
                    document.addEventListener('mouseup', () => { if(isDragging) { isDragging = false; fitCanvasToNodesMinimally(); }});
                }


                // No change needed here for node.animationId as convertJsonToNodesAndConnections
                // handles mapping JSON names to internal IDs already.
                nodes.forEach(node => {
                    const matchingAnimation = availableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
                    if (matchingAnimation) {
                        node.animationId = matchingAnimation.id;
                    } else {
                        console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations. Defaulting.`);
                        node.animationId = availableAnimations[0]?.id || '';
                    }
                });

                // Set the active node based on the imported initialNodeId
                if (importedInitialNodeId) {
                    const initialNode = nodes.find(n => n.id === importedInitialNodeId);
                    if (initialNode) {
                        initialNode.isActive = true;
                    } else if (nodes.length > 0) {
                        nodes[0].isActive = true; // Fallback if specified initial not found
                    }
                } else if (nodes.length > 0) {
                    nodes[0].isActive = true; // Fallback if no initial specified
                }

                // Render new nodes
                nodes.forEach(nodeData => {
                    canvasContainer.appendChild(createNodeElement(nodeData));
                });

                fitCanvasToNodesMinimally(); // Adjust canvas and apply positions
                updateNodeStyles(); // Apply active styles

                // --- START FIX: Manually find and click the initial node to open its properties ---
                const initialNode = nodes.find(n => n.isInitial);
                if (initialNode) {
                    document.getElementById(initialNode.id)?.click();
                } else if (nodes.length > 0) {
                    // Fallback: click the first node if no initial node is set
                    document.getElementById(nodes[0].id)?.click();
                }
                // --- END FIX ---
                

                // --- NEW: Clean orphaned layers from all loaded animations after import ---
                console.log('[JSON Load Cleanup] Running cleanup for orphaned interactive layers...');
                let totalRemoved = 0;
                availableAnimations.forEach(anim => {
                    if (anim.jsonContent) {
                        let lottieJson = JSON.parse(anim.jsonContent);
                        const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes);
                        if (removedCount > 0) {
                            console.log(`[JSON Load Cleanup] Cleaned ${removedCount} orphaned layer(s) from animation '${anim.name}'.`);
                            anim.jsonContent = JSON.stringify(cleanedJson);
                            totalRemoved += removedCount;
                        }
                    }
                });
                if (totalRemoved > 0) {
                    populateLeftPanelMarkers(globalAnimationId); // Refresh UI if changes were made
                }


            } catch (error) {
                console.error('Error parsing JSON file:', error);
                showCustomAlert('Error: Could not parse the JSON file. Please ensure it is a valid state machine JSON.');
            } finally {
                jsonFileInput.value = '';
            }
        };
        reader.readAsText(file);
    }
});

exportJsonButton.addEventListener('click', () => {

                // --- NEW: Smart save logic ---
                // Check which properties panel is currently open and click its save button.
                if (nodePropertiesModal.style.display === 'flex') {
                    saveNodePropertiesButton.click();
                } else if (actionNodePropertiesContainer.style.display === 'flex') {
                    saveActionNodeProperties.click();
                }
                // No need to save global state, as it saves on input.
                // --- END NEW ---

                if (typeof convertNodesAndConnectionsToJson !== 'function') {
                    showCustomAlert('Error: State machine converter library not loaded correctly.');
                    return;
                }

                const initialId = findInitialNodeId();
                if (!initialId && nodes.length > 0) {
                    showCustomAlert("Warning: No initial state is clearly defined. Defaulting to the first node or a placeholder.");
                }

                const stateMachineJson = convertNodesAndConnectionsToJson(nodes, connections, initialId, globalState, guardConnections);
                const jsonString = JSON.stringify(stateMachineJson, null, 2); // Pretty print

                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stateMachine.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

        });

        
        // --- NEW: Drag and Drop for creating nodes from marker cards ---
        flowchartArea.addEventListener('dragover', (e) => {
            e.preventDefault(); // This is necessary to allow a drop
            e.dataTransfer.dropEffect = 'copy';
        });

        flowchartArea.addEventListener('drop', (e) => {
            e.preventDefault();
            const markerName = e.dataTransfer.getData('text/plain');
            if (markerName) {
                const canvasRect = canvasContainer.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;

                // --- NEW: Logic to ensure the new node has a unique name ---
                let newNodeName = markerName;
                let counter = 1;
                // Check if a node with the marker's name already exists and append a number if it does.
                while (nodes.some(n => n.name === newNodeName)) {
                    newNodeName = `${markerName}_${counter++}`;
                }
                // --- END NEW ---

                // --- MODIFIED: Create a full node object before passing to addNode ---
                // This ensures it has all the default properties of a state node,
                // just like when clicking the "Add State" button.
                const newNodeData = {
                    marker: markerName,
                    x: x,
                    y: y,
                    name: newNodeName, // Use the generated unique name
                    // We let addNode handle the rest of the defaults (ID, isActive, etc.)
                };
                // --- FIX: Deactivate other nodes before adding the new one ---
                // This prevents layout jumps by ensuring only the new node is active
                // when fitCanvasToNodesMinimally() is called inside addNode().
                nodes.forEach(n => n.isActive = false);
                newNodeData.isActive = true;
                // --- END FIX ---
                addNode(newNodeData);
                // --- END MODIFICATION ---
            }
        });
        // --- END NEW ---

        // --- NEW: Keyboard shortcut for deleting nodes ---
        document.addEventListener('keydown', (e) => {
            // Check if the pressed key is 'Delete' or 'Backspace'
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Prevent deletion if the user is currently typing in an input field
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    return;
                }

                // Check if the global state properties panel is visible
                if (globalState && globalStatePropertiesContainer.style.display !== 'none') {
                    e.preventDefault(); // Prevent default browser action (like navigating back)
                    showCustomConfirm('Are you sure you want to delete the global variable and all its conditions?', deleteGlobalState);
                    return; // Exit after handling
                }

                // Check if a regular state or action node is selected
                if (selectedNodeForEdit) {
                    e.preventDefault(); // Prevent default browser action
                    const nodeToDelete = selectedNodeForEdit;
                    const message = nodeToDelete.type === 'action'
                        ? 'Are you sure you want to delete this action node?'
                        : 'Are you sure you want to delete this node and its connections?';

                    showCustomConfirm(message, () => { deleteNode(nodeToDelete.id); });
                }
            }
        });
        // --- END NEW ---
-



        // --- NEW: Event Listeners for Global State, Guards, Actions ---

        addGlobalStateButton.addEventListener('click', () => {
            addOrShowGlobalStateNode();
        });

        saveGuardConditionButton.addEventListener('click', () => {
            if (selectedGuardConnectionForEdit) {
        // Saving of conditions happens live via delegated listeners.
        // We just need to save the tweening properties here.
        if (selectedGuardConnectionForEdit.transitionType === 'Tweened') {
            const durationInput = document.getElementById('guard-tweened-duration-input');
            const easingInput = document.getElementById('guard-tweened-easing-input');
            selectedGuardConnectionForEdit.duration = parseFloat(durationInput.value) || 0.5;
            try {
                const easingArray = easingInput.value.split(',').map(s => parseFloat(s.trim()));
                if (easingArray.length === 4 && easingArray.every(n => !isNaN(n))) {
                    selectedGuardConnectionForEdit.easing = easingArray;
                } else {
                    throw new Error("Invalid format.");
                }
            } catch (e) {
                showCustomAlert("Invalid Easing format. Please use four comma-separated numbers. Reverting to default.");
                selectedGuardConnectionForEdit.easing = [0, 0, 1, 1];
            }
        }

        guardConditionModal.classList.remove('open');
        selectedGuardConnectionForEdit = null;
        redrawAll();
    }
});

        // NEW: Add event listener for the new guard transition type dropdown
        

        // Attach listener for the global state save button
        saveGlobalStateButton.addEventListener('click', () => {
            // The button's only job is now to close the panel. Saving happens live.
            if (!statePreviewWindow.classList.contains('hidden')) {
                previewToggleButton.click();
            }
        });

             // NEW: Event listener for "Play in Reverse" checkbox
            document.querySelector('#play-in-reverse-toggle-group .slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                playInReverseCheckbox.checked = !playInReverseCheckbox.checked;
                playInReverseCheckbox.dispatchEvent(new Event('change'));
            });

            // NEW: Event listener for "Play in Reverse" checkbox
            playInReverseCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    selectedNodeForEdit.playInReverse = playInReverseCheckbox.checked;
                    // Update the preview player's mode and play it
                    if (modalDotLottiePlayer) {
                        const animation = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
                        const marker = animation?.markers.find(m => m.name === selectedNodeForEdit.marker);

                        // Set the mode on the existing player instance
                        if (playInReverseCheckbox.checked) {
                            modalDotLottiePlayer.setMode('reverse');
                        } else {
                            modalDotLottiePlayer.setMode('normal');
                        }

                        // Re-apply segment and play without reloading
                        if (marker) {
                            modalDotLottiePlayer.setSegment(marker.start, marker.end);
                        }
                        
                        if (!freezeOnFirstFrameCheckbox.checked) modalDotLottiePlayer.play();
                    }
                }
            });

            // NEW: Event listener for deleting an action node
            deleteActionNodeButton.addEventListener('click', () => {
                const nodeToDelete = selectedNodeForEdit;
                if (!nodeToDelete || nodeToDelete.type !== 'action') {
                    console.error("Delete Action Node button clicked, but no action node is selected for editing.");
                    return;
                }
                showCustomConfirm('Are you sure you want to delete this action node?', () => { deleteNode(nodeToDelete.id); });
            });

        // NEW: Event listener for deleting the global state
            deleteGlobalStateButton.addEventListener('click', () => {
                showCustomConfirm('Are you sure you want to delete the global variable and all its conditions?', deleteGlobalState);
            });

            deleteGuardConnectionButton.addEventListener('click', () => {
                if (selectedGuardConnectionForEdit) {
                    deleteGuardConnection(selectedGuardConnectionForEdit.id);
                    guardConditionModal.classList.remove('open');
                }
            });
           // --- FIX: Ensure the close button (X) also correctly closes the modal ---
        guardConditionModal.querySelectorAll('.close-button').forEach(b => {
            b.addEventListener('click', () => {
                guardConditionModal.classList.remove('open');
            });
        });

            

            // NEW: Event listeners for Guard Condition Modal dropdown
            guardConditionTypeOptionsContainer.addEventListener('click', (e) => {
                // This is now the main dropdown for the guard condition type
                e.stopPropagation();
                const optionsContainer = document.getElementById('guard-condition-type-options');
                const nativeSelect = document.getElementById('guard-condition-type-select');
                const option = e.target.closest('.custom-dropdown-option');
                // --- FIX START ---
                if (option) {
                    const value = option.dataset.value;
                    const display = guardConditionTypeDropdownGroup.querySelector('.custom-dropdown-display');

                    // Update the native select, which holds the actual value
                    nativeSelect.value = value;
                    // Update the custom display text
                    display.textContent = option.textContent;
                    // Update the 'selected' class for styling
                    optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    // Close the dropdown
                    optionsContainer.classList.remove('open');
                }
                // --- FIX END ---
            });

            // NEW: Click listener for the new dropdown group
            const guardConditionDropdownGroup = document.getElementById('guard-condition-type-dropdown-group');
            if (guardConditionDropdownGroup) {
                guardConditionDropdownGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const optionsContainer = document.getElementById('guard-condition-type-options');
                    const wasOpen = optionsContainer.classList.contains('open');
                    closeAllCustomDropdowns();
                    if (!wasOpen) optionsContainer.classList.add('open');
                });
            }

          

function updateAvailableAnimationsWithNewMarkers(newMarkersData) {
//console.log('ths is  beforeudpate'+availableAnimations);

    newMarkersData.forEach(newAnimData => {
        let existingAnim = availableAnimations.find(a => a.id === newAnimData.id);

        if (!existingAnim) {
            // If the animation itself doesn't exist, add it
            existingAnim = { id: newAnimData.id, name: newAnimData.name, markers: [] };
            availableAnimations.push(existingAnim);
        }

        newAnimData.markers.forEach(newMarker => {
            // Only add the new marker if it doesn't already exist in the existing animation's markers
            if (!existingAnim.markers.some(m => m.name === newMarker.name)) {
                existingAnim.markers.push(newMarker);
            }
        });
    });


  //  console.log('--- updateAvailableAnimationsWithNewMarkers: after update ---');
    //console.log(JSON.parse(JSON.stringify(availableAnimations))); // Log a deep copy of the state after modifications
}










function readFileAsArrayBuffer(file) {
       return new Promise((resolve, reject) => {
           const reader = new FileReader();
           reader.onload = () => resolve(reader.result);
           reader.onerror = error => reject(error);
           reader.readAsArrayBuffer(file);
       });
   }


   /**
    * Extracts and parses all JSON files located in the 'states/' directory within a .lottie archive.
    * @param {File} dotLottieFile - The .lottie file (zip archive) to process.
    * @returns {Promise<Array<object>>} A promise that resolves with an array of parsed JSON objects
    * found in the 'states/' directory. Returns an empty array if no
    * JSON files are found or if JSZip is not loaded.
    */
   async function extractStateMachineJson(dotLottieFile) {
       if (typeof JSZip === 'undefined') {
           console.error("JSZip library is not loaded. Please ensure it's available in the global scope (e.g., via a <script> tag).");
           return [];
       }

       const arrayBuffer = await readFileAsArrayBuffer(dotLottieFile);
       const zip = new JSZip();
       const loadedZip = await zip.loadAsync(arrayBuffer);

       const stateMachineJsons = [];

       for (const filename in loadedZip.files) {
           const fileEntry = loadedZip.files[filename];
           if (!fileEntry.dir && (filename.startsWith('states/') || filename.startsWith('s/')) && filename.endsWith('.json')) {
               try {
                   const jsonContent = await fileEntry.async('text');
                   stateMachineJsons.push(JSON.parse(jsonContent));
               } catch (e) {
                   console.warn(`Could not parse JSON file from states/: ${filename}`, e);
               }
           }
       }
       return stateMachineJsons;
   }




   function extractMarkersFromLogic(jsonString) { // Renamed to avoid conflict if another function with similar name exists
          const markers = [];
          let parseError = null;
          if (!jsonString) { // Handle cases where content might be null (e.g., read error)
               return { markers, error: "JSON content is missing." };
          }
          try {
              const animationJson = JSON.parse(jsonString);
              if (animationJson && animationJson.markers && Array.isArray(animationJson.markers)) {
                  animationJson.markers.forEach(marker => {
                      const startTime = typeof marker.tm === 'number' ? marker.tm : (typeof marker.t === 'number' ? marker.t : undefined);
                      if (marker.cm && typeof startTime === 'number' && typeof marker.dr === 'number') {
                          markers.push({
                              name: marker.cm,
                              start: startTime,
                              end: startTime + marker.dr
                          });
                      } else {
                          console.warn('Invalid or incomplete marker (cm, tm/t, dr) found in JSON:', marker);
                      }
                  });
              }
          } catch (e) {
              console.error("Error parsing JSON for marker extraction (cm, tm/t, dr):", e);
              parseError = `Error parsing JSON: ${e.message}`;
          }
          return { markers, error: parseError };
      }



      // New function to update the source node's loop property
      // Refined function to update the source node's loop property based on connection types
 function updateSourceNodeLoopStatus(sourceNodeId) {
    const sourceNode = nodes.find(n => n.id === sourceNodeId);
    if (!sourceNode) {
        return;
    }

    const outgoingConnections = connections.filter(conn => conn.fromNodeId === sourceNodeId);
    const onLoopCompleteConnections = outgoingConnections.filter(conn => conn.interactionType === 'onLoopComplete');
    const onCompleteConnections = outgoingConnections.filter(conn => conn.interactionType === 'onComplete');

    // --- FIX START: This logic is now more precise ---
    let nodeLoopActuallyChanged = false;

    if (onLoopCompleteConnections.length > 0) {
        // Priority 1: An "onLoopComplete" connection exists.
        const firstOnLoopCompleteConn = onLoopCompleteConnections[0];
        let loopCount = 1;
        if (firstOnLoopCompleteConn.interactionDetails && typeof firstOnLoopCompleteConn.interactionDetails.loopCount === 'number' && firstOnLoopCompleteConn.interactionDetails.loopCount > 0) {
            loopCount = firstOnLoopCompleteConn.interactionDetails.loopCount;
        }
        if (sourceNode.loop !== loopCount) {
            sourceNode.loop = loopCount;
            nodeLoopActuallyChanged = true;
        }
    } else if (onCompleteConnections.length > 0) {
        // Priority 2: "onComplete" exists. Loop must be false.
        if (sourceNode.loop !== false) {
            sourceNode.loop = false;
            nodeLoopActuallyChanged = true;
        }
    }
    
    if (nodeLoopActuallyChanged) {
        console.log(`Node ${sourceNode.name} (${sourceNode.id}) loop property was updated to: ${sourceNode.loop}`);
    }
    // --- FIX END ---

    // Now, sync the UI based on the corrected data model and connection state
    if (selectedNodeForEdit && selectedNodeForEdit.id === sourceNode.id) {
        const loopCheckboxContainer = document.getElementById('loop-checkbox').closest('.toggle-group');
        const loopLabel = loopCheckboxContainer.querySelector('label');
        const freezeToggleContainer = document.getElementById('freeze-on-first-frame-toggle-group');
        const freezeToggleLabel = freezeToggleContainer.querySelector('label');

        // --- FIX START: The UI-syncing logic is now also corrected ---
        const shouldBeDisabled = onLoopCompleteConnections.length > 0 || onCompleteConnections.length > 0;
        
        if (shouldBeDisabled) {
            // If disabled, determine if it should be checked or unchecked
            const shouldBeChecked = onLoopCompleteConnections.length > 0;

            loopCheckboxContainer.style.pointerEvents = 'none';
            loopCheckboxContainer.style.opacity = '0.4';
            loopLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
            loopCheckbox.checked = shouldBeChecked; // <-- This now correctly sets the state

            // Freeze frame is always disabled when a completion trigger is used
            freezeToggleContainer.style.pointerEvents = 'none';
            freezeToggleContainer.style.opacity = '0.4';
            freezeToggleLabel.title = 'Cannot freeze frame when using an On Complete or On Loop Complete trigger.';
            freezeOnFirstFrameCheckbox.checked = false;

        } else {
            // If not disabled, re-enable it and set its state from the node's data
            loopCheckboxContainer.style.pointerEvents = 'auto';
            loopCheckboxContainer.style.opacity = '1.0';
            loopLabel.title = '';
            const effectivelyLoops = (typeof sourceNode.loop === 'boolean' && sourceNode.loop === true) || (typeof sourceNode.loop === 'number' && sourceNode.loop > 0);
            loopCheckbox.checked = effectivelyLoops;

            freezeToggleContainer.style.pointerEvents = 'auto';
            freezeToggleContainer.style.opacity = '1.0';
            freezeToggleLabel.title = '';
            freezeOnFirstFrameCheckbox.checked = !sourceNode.autoplay;
        }
        // --- FIX END ---
    }

    // Always updatess the source node's visual details chip on the canvas
    const sourceNodeElement = document.getElementById(sourceNode.id);
    if (sourceNodeElement) {
        // The function is now inside the module, so no 'window.' prefix
        updateNodeDetailsChips(sourceNodeElement.querySelector('.node'), sourceNode);
    }
}




   /**
 * Extracts and parses all JSON files located in the 'animations/' directory within a .lottie archive,
 * and for each, returns its name and all marker names defined within it.
 *
 * @param {File} dotLottieFile - The .lottie file (zip archive) to process.
 * @returns {Promise<Array<{animationName: string, markers: Array<string>}>>}
 * A promise that resolves with an array of objects, where each object
 * contains the animation's file name (without extension) and an array of its marker names.
 * Returns an empty array if no JSON files are found or if JSZip is not loaded,
 * or if animations do not contain a 'markers' property.
 */
 async function extractAnimationMarkersFromLottie(dotLottieFile) {
    if (typeof JSZip === 'undefined') {
        console.error("JSZip library is not loaded. Cannot process .lottie file.");
        throw new Error("JSZip library is required for .lottie processing.");
    }

    const arrayBuffer = await readFileAsArrayBuffer(dotLottieFile);
    const zip = new JSZip();
    const loadedZip = await zip.loadAsync(arrayBuffer);
    const animationsData = []; // Renamed from availableAnimations to avoid confusion with global

    for (const filename in loadedZip.files) {
        const fileEntry = loadedZip.files[filename];

        if (!fileEntry.dir && (filename.startsWith('animations/') || filename.startsWith('a/')) && filename.toLowerCase().endsWith('.json')) {
            let animationId;
            if (filename.startsWith('animations/')) {
                animationId = filename.replace('animations/', '').replace(/\.json$/i, '');
            } else {
                animationId = filename.replace('a/', '').replace(/\.json$/i, '');
            }
            const animationName = animationId; // Default name to ID
            let animationEntry = { id: animationId, name: animationName, markers: [], jsonContent: null, error: null, clickLayers: new Set() }; // Add jsonContent and clickLayers

            try {
                let jsonContentString = await fileEntry.async('text');
                if (jsonContentString) {
                    let animationJson = JSON.parse(jsonContentString);

                    // 1. Modify the ip property and add the "Full Animation" marker
                    const originalIp = animationJson.ip || 0;
                    if (originalIp !== 0) {
                        // Adjust all keyframe times if ip is not 0
                        // This is a simplified adjustment. A full implementation would need to traverse the whole JSON.
                        // For now, we just set ip to 0.
                        animationJson.ip = 0;
                        console.log(`[LOG] Animation '${animationId}': Original ip was ${originalIp}, set to 0.`);
                    }

                    // Ensure markers array exists
                    if (!animationJson.markers) {
                        animationJson.markers = [];
                    }

                    
                    addOrUpdateFullAnimationMarker(animationJson, originalIp);
                    // Validate and adjust all markers to have a minimum duration
                    validateAndAdjustMarkers(animationJson);

                    // Make interactive layers visible by default
                    const visibleAnimationJson = showLayersByOpacity(animationJson);

                    // Re-serialize the modified JSON
                    jsonContentString = JSON.stringify(visibleAnimationJson);

                    // 2. Store the modified JSON and extract markers from it
                    animationEntry.jsonContent = jsonContentString;
                    const markerData = extractMarkersFromLogic(jsonContentString);
                    animationEntry.markers = markerData.markers;
                    if (markerData.error) {
                        animationEntry.error = `Marker extraction error: ${markerData.error}`;
                        console.warn(`Error processing markers for ${filename}: ${markerData.error}`);
                    }
                } else {
                    animationEntry.error = "JSON content was empty or unreadable.";
                }
            } catch (e) {
                console.warn(`Could not read or process animation JSON from ${filename}:`, e);
                animationEntry.error = `Failed to read/process ${filename}: ${e.message}`;
            }
            animationsData.push(animationEntry);
        }
    }
    return animationsData; // Return the collected animations data
}



function hideInteractionLayersByOpacity(lottieJson) { // Renamed from hideLayersByOpacity
    if (!lottieJson || !lottieJson.layers) {
        return lottieJson;
    }

    // Create a deep copy to avoid modifying the original object.
    const modifiedJson = JSON.parse(JSON.stringify(lottieJson));

    // This regex identifies layers named like "StateA_click_to_StateB".
    const interactiveLayerRegex = /.+_(click|pointerenter|pointerexit|pointerdown|pointerup|pointermove)_to_.+/;

    modifiedJson.layers.forEach(layer => {
        // Check if the layer name matches our interactive layer naming convention.
        if (layer.nm && interactiveLayerRegex.test(layer.nm)) {
            console.log(`[LOG] Hiding interactive layer '${layer.nm}' for export.`);

            // Also remove the "Gray Fill" from the layer's shapes
            if (layer.shapes && Array.isArray(layer.shapes)) {
                layer.shapes.forEach(shapeGroup => {
                    if (shapeGroup.it && Array.isArray(shapeGroup.it)) {
                        // Filter out the fill shape
                        shapeGroup.it = shapeGroup.it.filter(item => item.ty !== 'fl' || item.nm !== 'Gray Fill');
                    }
                });
            }

            // Ensure the layer has a transform property object ('ks').
            if (!layer.ks) {
                layer.ks = {};
            }

            // Set the layer's opacity ('o') to a static value ('a': 0) of 0 ('k': 0).
            layer.ks.o = { a: 0, k: 1 };
        }
    });

    return modifiedJson;
}

/**
 * Sets the opacity of all interactive layers (e.g., "StateA_click_to_StateB") to 100.
 * This is useful to make them visible by default when loading a Lottie file.
 * @param {object} lottieJson - The parsed Lottie JSON data.
 * @returns {object} The modified Lottie JSON with visible interactive layers.
 */
function showLayersByOpacity(lottieJson) {
     if (!lottieJson || !lottieJson.layers) {
         return lottieJson;
     }
 
     // Create a deep copy to avoid modifying the original object.
     const modifiedJson = JSON.parse(JSON.stringify(lottieJson));
 
     // This regex identifies layers named like "StateA_click_to_StateB".
     const interactiveLayerRegex = /.+_(click|pointerenter|pointerexit|pointerdown|pointerup|pointermove)_to_.+/;
 
     // This is the standard "Gray Fill" shape object that we will add back.
     const grayFillShape = { "ty": "fl", "nm": "Gray Fill", "c": { "a": 0, "k": [0.5, 0.5, 0.5, 1], "ix": 3 }, "o": { "a": 0, "k": 10, "ix": 4 } };
 
     modifiedJson.layers.forEach(layer => {
         // Check if the layer name matches our interactive layer naming convention.
         if (layer.nm && interactiveLayerRegex.test(layer.nm)) {
             console.log(`[LOG] Making interactive layer '${layer.nm}' visible for preview.`);
 
             // Add back the "Gray Fill" if it doesn't exist.
             if (layer.shapes && Array.isArray(layer.shapes)) {
                 layer.shapes.forEach(shapeGroup => {
                     if (shapeGroup.it && Array.isArray(shapeGroup.it)) {
                         const hasGrayFill = shapeGroup.it.some(item => item.ty === 'fl' && item.nm === 'Gray Fill');
                         if (!hasGrayFill) {
                             // Insert the fill just before the transform ('tr') item for correct rendering order.
                             const transformIndex = shapeGroup.it.findIndex(item => item.ty === 'tr');
                             shapeGroup.it.splice(transformIndex, 0, JSON.parse(JSON.stringify(grayFillShape)));
                         }
                     }
                 });
             }
 
             // Set the layer's opacity ('o') to a static value ('a': 0) of 100 ('k': 100).
             layer.ks.o = { a: 0, k: 100 };
         }
     });
 
     return modifiedJson;
}

/**
 * Generates a minimal Lottie manifest JSON object.
 * @param {Array<Object>} animations - Array of animation objects (from availableAnimations).
 * @param {Array<Object>} nodes - Array of node objects (for state names).
 * @returns {Object} The manifest JSON object.
 */
function generateLottieManifest(animations, nodes) {
    // Dynamically create an entry for each animation being bundled.
    const animationEntries = animations.map(anim => ({ id: anim.id }));

    return {
        version: "2",
        generator: "@dotlottie/dotlottie-js@1.3.1",
        animations: animationEntries, // Use the dynamically generated array
        stateMachines: [
            { id: "stateMachine" } // This matches the hardcoded "stateMachine.json" filename.
        ]
    };
}

/**
 * Exports the current state machine and associated animations as a .lottie file.
 * @param {Array<Object>} nodesData - The array of current node objects.
 * @param {Array<Object>} connectionsData - The array of current connection objects.
 * @param {string|null} initialNodeName - The name of the initial node for the state machine JSON.
 * @param {Array<Object>} animationsToInclude - The array of animation data including their JSON content.
 */
async function exportLottieFile(nodesData, connectionsData, initialNodeName, globalState, guardConnections, animationsToInclude, returnBlob = false) {
    if (typeof JSZip === 'undefined') {
        showCustomAlert("Error: JSZip library is not loaded, cannot export .lottie.");
        if (returnBlob) return null;
        return;
    }

    if (animationsToInclude.length === 0) {
        showCustomAlert("Cannot export .lottie: No animations are loaded.");
        if (returnBlob) return null;
        return;
    }

    const zip = new JSZip();

    // 1. Add manifest.json
    const manifest = generateLottieManifest(animationsToInclude, nodesData);
    zip.file("manifest.json", JSON.stringify(manifest, null, 2));

    // 2. Add animations to 'animations/' folder
    const animationsFolder = zip.folder("a");
    animationsToInclude.forEach(anim => {
        if (anim.jsonContent) {
            // Before adding, parse the JSON, remove visual styles from interactive layers, and then stringify it.
            const originalJson = JSON.parse(anim.jsonContent);
            const cleanedJson = hideInteractionLayersByOpacity(originalJson);
            animationsFolder.file(`${anim.id}.json`, JSON.stringify(cleanedJson));
        } else {
            console.warn(`Animation '${anim.id}' does not have 'jsonContent'. Skipping addition to .lottie.`);
        }
    });

    // 3. Add state machine JSON to 'states/' folder
    const statesFolder = zip.folder("s");
    const stateMachineJson = convertNodesAndConnectionsToJson(nodesData, connectionsData, initialNodeName, globalState, guardConnections);
    statesFolder.file("stateMachine.json", JSON.stringify(stateMachineJson, null, 2));

    // 4. Generate the .lottie (zip) file and trigger download
    try {
        const content = await zip.generateAsync({ type: "blob" });

        if (returnBlob) {
            return content;
        }

        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'exportedStateMachine.lottie'; // Default filename
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showCustomAlert("State machine and animations exported as .lottie file!");
    } catch (error) {
        console.error("Error generating .lottie file:", error);
        showCustomAlert(`Error exporting .lottie file: ${error.message}`);
        if (returnBlob) {
            return null;
        }
    }
}




/**
 * Processes a state machine JSON object (e.g., from a .lottie file) by:
 * - Extracting and updating frame markers based on the JSON's segments.
 * - Mapping animation IDs for nodes, defaulting where necessary.
 *
 * This function returns a new, processed JSON object. It internally causes
 * updates to the global 'availableAnimations' list.
 *
 * @param {object} rawStateMachineJson - The raw, parsed state machine JSON object to process.
 * @param {Array<object>} allAvailableAnimations - The array of all animations currently available in the application.
 * This array is used for lookups and is expected to be updated globally
 * by the internal call to updateAvailableAnimationsWithNewMarkers.
 * @returns {object} A new JSON object representing the processed state machine.
 */
async function processLottieStateMachineJson(rawStateMachineJson, allAvailableAnimations) {
    // Basic validation for converter functions. If missing, we cannot process correctly.


    // Deep clone the incoming JSON to ensure we don't modify the original argument indirectly.
    const stateMachineJson = JSON.parse(JSON.stringify(rawStateMachineJson));

    // Get the ID of the first animation available, to be used as a default.
    const firstAvailableAnimationId = allAvailableAnimations.length > 0 ? allAvailableAnimations[0].id : '';


	 const importedData = convertJsonToNodesAndConnections(stateMachineJson, allAvailableAnimations);
    let processedNodes = importedData.nodes;
    let processedConnections = importedData.connections;
    let processedInitialNodeId = importedData.initialNodeId;

    let anyNodeHadAnimationIdDefined = false;

    // Step 3: Process nodes to map animation IDs and handle defaults.
    processedNodes.forEach(node => {
        if (node.animationId) {
            anyNodeHadAnimationIdDefined = true;
            const matchingAnimation = allAvailableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
            if (matchingAnimation) {
                node.animationId = matchingAnimation.id;
            } else {
                console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations for node "${node.name}". Defaulting to first available.`);
                node.animationId = firstAvailableAnimationId;
            }
        } else {
            node.animationId = ''; // Initialize to empty for later checks.
        }
    });

    // Step 4: Apply logic if no animationId was defined in any state in the original JSON.
    if (!anyNodeHadAnimationIdDefined && firstAvailableAnimationId) {
        console.log(`No animationId found in any imported state. Assigning all states to first animation: "${firstAvailableAnimationId}"`);
        processedNodes.forEach(node => {
            node.animationId = firstAvailableAnimationId;
        });
    }

    // Step 5: Final fallback to ensure no node has an empty animationId if animations are available.
    processedNodes.forEach(node => {
         if (!node.animationId && allAvailableAnimations.length > 0) {
             node.animationId = allAvailableAnimations[0].id;
         }
    });

    // Step 6: Convert the processed internal data (nodes/connections) back into the
    // state machine JSON format expected by your application.
    // We need the initial node's *name* for convertNodesAndConnectionsToJson.
    const initialNodeForReturn = processedNodes.find(n => n.id === processedInitialNodeId);
    const initialNodeNameForReturn = initialNodeForReturn ? initialNodeForReturn.name : null;

    const finalStateMachineJson = convertNodesAndConnectionsToJson(
        processedNodes,
        processedConnections,
        initialNodeNameForReturn,
        importedData.globalState, // Pass through global state
        importedData.guardConnections, // Pass through guard connections
        allAvailableAnimations
    );

    return finalStateMachineJson;
}

// --- NEW: Function to update action node properties from the UI instantly ---

// --- END NEW ---

async function openActionNodePropertiesModal(nodeData) {
    // --- 1. Set up active states ---
    nodes.forEach(n => n.isActive = (n.id === nodeData.id));
    updateNodeStyles();
    document.getElementById('global_state_node')?.classList.remove('active');
    document.getElementById(nodeData.id)?.classList.add('active');

    if (!statePreviewWindow.contains(actionNodePropertiesContainer)) {
        statePreviewWindow.appendChild(actionNodePropertiesContainer);
    }

    // --- START: MODIFIED ANIMATION LOGIC ---
    const panelToShow = actionNodePropertiesContainer;
    const animatableChildren = Array.from(panelToShow.children);
    const { panel: currentVisiblePanel, children: oldAnimatables } = findCurrentVisiblePanel();

    if (currentVisiblePanel && currentVisiblePanel !== panelToShow) {
        // Animate out old panel
        oldAnimatables.forEach(child => child.classList.add('panel-content-exit'));
        await new Promise(resolve => setTimeout(resolve, 150));
        currentVisiblePanel.style.display = 'none';
        oldAnimatables.forEach(child => child.classList.remove('panel-content-exit'));
        
        // Set "in" start state
        animatableChildren.forEach(child => child.classList.add('panel-content-exit'));

    } else if (currentVisiblePanel === panelToShow) {
            // Already showing, just update content (no animation)
    } else {
        // Opening from closed, set start state
        animatableChildren.forEach(child => child.classList.add('panel-content-exit'));
    }
    // --- END: MODIFIED ANIMATION LOGIC ---

    panelToShow.style.display = 'flex';
    if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

    selectedNodeForEdit = nodeData;

    // --- 2. Backward Compatibility & Data Normalization for the Action Node ---
    if (selectedNodeForEdit.action && !Array.isArray(selectedNodeForEdit.action)) {
        selectedNodeForEdit.action = [selectedNodeForEdit.action];
    } else if (!selectedNodeForEdit.action) {
        selectedNodeForEdit.action = [];
    }
    // --- NEW: Ensure openUrlAction is at least null ---
    if (!selectedNodeForEdit.openUrlAction) {
        selectedNodeForEdit.openUrlAction = null;
    }
    // --- END NEW ---

    // --- 3. Render the UI for Variable Actions ---
    const editorContent = document.getElementById('action-node-editor-content');
    const descriptionElement = actionNodePropertiesContainer.querySelector('.global-state-description');
    const actionsListContainer = document.getElementById('node-actions-list');
    actionsListContainer.innerHTML = ''; // Clear previous list

    if (globalState && globalState.inputs.length > 0) {
        descriptionElement.style.display = 'block';
        editorContent.style.display = 'block';
        const addActionButton = document.getElementById('add-node-action-button');
        if (addActionButton) {
            addActionButton.style.display = 'none';
        }
        globalState.inputs.forEach(variable => {
            let actionForThisVariable = selectedNodeForEdit.action.find(a => a.variableId === variable.id);
            if (!actionForThisVariable) {
                actionForThisVariable = {
                    _tempId: `action_${generateId()}`,
                    type: '',
                    value: '',
                    variableId: variable.id
                };
                selectedNodeForEdit.action.push(actionForThisVariable);
            }
            renderAndAttachActionRow(actionForThisVariable, actionsListContainer, selectedNodeForEdit.action);
        });
    } else {
        descriptionElement.style.display = 'none';
        editorContent.style.display = 'none';
        actionsListContainer.innerHTML = `
            <div class="action-node-prompt">
                <p>To use Action Nodes, you first need to create a Global Variable.</p>
                <button id="create-global-node-from-action-panel">Create Global Variable</button>
            </div>`;
        document.getElementById('create-global-node-from-action-panel')?.addEventListener('click', () => {
            addOrShowGlobalStateNode();
        });
    }

    // --- 4. Render the UI for the URL Action ---
    const urlInput = document.getElementById('action-node-url-input');
    if (selectedNodeForEdit.openUrlAction && selectedNodeForEdit.openUrlAction.url) {
        urlInput.value = selectedNodeForEdit.openUrlAction.url;
    } else {
        urlInput.value = ''; // Clear it if no action is set
    }

    // --- START: ADD THIS ---
    // This adds the auto-save listener.
  urlInput.oninput = () => {
        if (!selectedNodeForEdit) return; // Safety check
        
        const urlValue = urlInput.value.trim();
        if (urlValue) {
            // If there's a URL, create or update the action
            selectedNodeForEdit.openUrlAction = {
                type: 'OpenUrl',
                url: urlValue,
                target: '_blank' // Default to _blank
            };
        } else {
            // If the input is empty, remove the action
            selectedNodeForEdit.openUrlAction = null;
        }

        // --- NEW: Trigger canvas update ---
        // This tells the node on the canvas to redraw itself.
        if (selectedNodeForEdit && selectedNodeForEdit.type === 'action') {
            const nodeWrapper = document.getElementById(selectedNodeForEdit.id);
            if (nodeWrapper) {
                const nodeElement = nodeWrapper.querySelector('.node');
                if (nodeElement) {
                    updateActionNodeVisual(nodeElement, selectedNodeForEdit);
                }
            }
        }
        // --- END NEW ---
    };
    // --- END: ADD THIS ---

    // --- 5. Animate IN ---
    if (!currentVisiblePanel || currentVisiblePanel !== panelToShow) {
        await new Promise(resolve => setTimeout(resolve, 10));
        animatableChildren.forEach(child => child.classList.remove('panel-content-exit'));
    }
}

function openGuardConditionModal(guardConn) {
    selectedGuardConnectionForEdit = guardConn;
    const modalBody = guardConditionModal.querySelector('.modal-body');

    // --- 1. Clear previous dynamic content ---
    const dynamicFieldsContainer = modalBody.querySelector('#guard-dynamic-fields');
    dynamicFieldsContainer.innerHTML = ''; // Clear tweening fields
    // We will build the condition editors inside the main modal body now.
    // Let's clear everything except the transition type toggle.
    const allButToggle = modalBody.querySelectorAll('.combined-input-group, .separator-with-text');
    allButToggle.forEach(el => el.remove());

    // --- 2. Dynamically create an editor for each global variable ---
    globalState.inputs.forEach((variable, index) => {
        // Find the condition for this variable. If it doesn't exist, create a default.
        let condition = guardConn.conditions.find(c => c.variableId === variable.id);
        if (!condition) {
            condition = { variableId: variable.id, condition: 'Equal', value: variable.type === 'Boolean' ? 'false' : '0' };
            guardConn.conditions.push(condition);
        }

        // Add a separator for visual clarity between conditions
        if (index > 0) {
                     modalBody.insertAdjacentHTML('beforeend', `<div class="separator-with-text" style="margin: 20px 0 20px; display: none;"><div class="separator-line"></div><span class="separator-pill">AND</span><div class="separator-line"></div></div>`);
        }

        const isNumeric = variable.type === 'Numeric';
        const isBoolean = variable.type === 'Boolean';
        const boolValue = (condition.value === 'true' || condition.value === true);
        const isNone = condition.condition === 'None';

        // --- 3. Create the HTML for this variable's editor ---
        const editorHTML = `
            <div class="combined-input-group" data-variable-id="${variable.id}">
                <div class="dropdown-group guard-condition-type-dropdown-group" style="flex: 3.5; margin: 0; border: none; background: transparent;">
                    <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                       <label style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">IF <span class="variable-pill">${variable.name}</span></label>
                        <div class="custom-dropdown-container">
                            <div class="custom-dropdown-display" data-target-select="guard-condition-type-${variable.id}">${condition.condition}</div>
                            <div class="custom-dropdown-options"></div>
                            <select id="guard-condition-type-${variable.id}" style="display: none;"></select>
                        </div>
                    </div>
                    <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto 1rem auto auto;"></i>
                </div>
                <div class="combined-input-separator" style="display: ${isNone ? 'none' : 'block'};"></div>
                <div class="guard-numeric-value-container" style="display: ${isNumeric && !isNone ? 'flex' : 'none'};">
                    <button class="decrement-guard-value modal-stepper-button">-</button>
                    <input type="number" class="guard-value-input" value="${condition.value}">
                    <button class="increment-guard-value modal-stepper-button">+</button>
                </div>
                <div class="guard-boolean-value-container" style="display: ${isBoolean && !isNone ? 'flex' : 'none'};">
                    <span class="guard-boolean-value-display" style="color: ${boolValue ? '#28a745' : '#dc3545'};">${boolValue ? 'true' : 'false'}</span>
                    <button class="guard-boolean-value-toggle"><i class="fas fa-sync-alt"></i></button>
                </div>
            </div>`;
        modalBody.insertAdjacentHTML('beforeend', editorHTML);

        // --- 4. Populate the dropdown we just created ---
        const newGroup = modalBody.querySelector(`.combined-input-group[data-variable-id="${variable.id}"]`);
        populateDropdowns(
            newGroup.querySelector('select'),
            newGroup.querySelector('.custom-dropdown-display'),
            newGroup.querySelector('.custom-dropdown-options'),
            getConditionOptionsForType(variable.type),
            condition.condition
        );
    });

    // --- 5. Handle Transition Type Toggle and Dynamic Fields (existing logic, slightly adapted) ---
    const guardTransitionToggle = document.getElementById('guard-transition-type-toggle');
    guardTransitionToggle.querySelectorAll('.boolean-toggle-option').forEach(option => {
        option.classList.toggle('active', option.dataset.value === (guardConn.transitionType || 'Transition'));
    });
    // This function will now just handle showing/hiding the tweening fields
    handleGuardTransitionTypeChange();

    // --- 6. Attach a single set of delegated listeners for the whole modal ---
    attachDynamicGuardModalListeners();

    guardConditionModal.classList.add('open');
}



/**
 * Shows or hides the tweening (duration/easing) fields in the guard condition modal
 * based on the currently selected transition type.
 */
function handleGuardTransitionTypeChange() {
    if (!selectedGuardConnectionForEdit) return;

    const guardDynamicFieldsContainer = document.getElementById('guard-dynamic-fields');
    guardDynamicFieldsContainer.innerHTML = ''; // Clear previous fields first

    // Only show the fields if the transition type is 'Tweened'
    if (selectedGuardConnectionForEdit.transitionType === 'Tweened') {
        const guardConn = selectedGuardConnectionForEdit; // Alias for readability

        // --- Determine the preset name from the easing value ---
        const currentEasingValue = guardConn.easing || [0.42, 0, 0.58, 1];
        const currentEasingString = currentEasingValue.join(',');
        let presetName = 'custom';
        let isCustom = true;

        if (currentEasingString === '0.42,0,1,1') { presetName = 'ease-in'; isCustom = false; }
        else if (currentEasingString === '0,0,0.58,1') { presetName = 'ease-out'; isCustom = false; }
        else if (currentEasingString === '0.42,0,0.58,1') { presetName = 'ease-in-out'; isCustom = false; }
        else if (currentEasingString === '0,0,1,1') { presetName = 'linear'; isCustom = false; }

        // --- Create and inject the HTML for the tweening fields ---
        guardDynamicFieldsContainer.innerHTML = `
            <div class="dynamic-field-group" style="margin-top: 10px; flex-direction: row; align-items: center; gap: 10px;">
                <label for="guard-tweened-duration-input" style="margin-left: 10px; flex-shrink: 0;">DURATION</label>
                <input type="number" id="guard-tweened-duration-input" min="0" step="0.1" value="${guardConn.duration || 0.5}" style="width: 100px; margin: auto 0;">
            </div>
            <div class="dynamic-field-group" style="flex-direction: row; align-items: center; gap: 62px; margin-bottom: 10px; margin-top: 10px;">
                <label for="guard-tweened-easing-input" style="margin-left: 10px; flex-shrink: 0;">EASING</label>
                <div style="position: relative; flex-grow: 1; display: flex; align-items: center;">
                     <input
                        type="text"
                        id="guard-tweened-easing-input"
                        placeholder="e.g., 0.42, 0, 0.58, 1"
                        value="${currentEasingValue.join(', ')}"
                        style="width: 100%; margin: 0; padding-right: 130px; box-sizing: border-box; opacity: ${isCustom ? '1' : '0.6'};"
                        ${isCustom ? '' : 'disabled'}
                    >
                    <div class="dropdown-group" id="guard-easing-preset-dropdown-group" style="width: 100px; position: absolute; right: 0; top: 0; height: 30px; margin: 3px; padding: 0 12px; border: none; background: #e6f6ff; align-items: center;">
                        <div class="custom-dropdown-container" style="width: 120px;">
                            <div class="custom-dropdown-display" id="guard-easing-preset-display" style="font-size: 12px; padding-right: 4px; padding-bottom: 1px;">${presetName}</div>
                            <div class="custom-dropdown-options" id="guard-easing-preset-options" style="width: 150px; right: -32px; left: auto;">
                                <div class="custom-dropdown-option" data-value="[0.42, 0, 1, 1]">ease-in</div>
                                <div class="custom-dropdown-option" data-value="[0, 0, 0.58, 1]">ease-out</div>
                                <div class="custom-dropdown-option" data-value="[0.42, 0, 0.58, 1]">ease-in-out</div>
                                <div class="custom-dropdown-option" data-value="[0, 0, 1, 1]">linear</div>
                                <div class="custom-dropdown-option" data-value="custom">custom</div>
                            </div>
                        </div>
                        <i class="fas fa-chevron-down dropdown-indicator" style="margin-left: 0px;"></i>
                    </div>
                </div>
            </div>
        `;

        // --- IMPORTANT: Attach event listeners to the new dropdown we just created ---
        attachGuardEasingPresetListeners();
    }
}

/**
 * Attaches delegated event listeners for the dynamically created easing preset dropdown
 * within the guard condition modal.
 */

 /*
function attachGuardEasingPresetListeners() {
    const dynamicFieldsContainer = document.getElementById('guard-dynamic-fields');
    if (!dynamicFieldsContainer) return;

    // Use event delegation on the container for the dropdown elements
    dynamicFieldsContainer.addEventListener('click', (e) => {
        const dropdownGroup = e.target.closest('#guard-easing-preset-dropdown-group');
        const option = e.target.closest('.custom-dropdown-option');

        if (dropdownGroup && !option) {
            // Clicked on the main dropdown body to open/close it
            e.stopPropagation();
            const optionsContainer = dropdownGroup.querySelector('.custom-dropdown-options');
            const wasOpen = optionsContainer.classList.contains('open');
            closeAllCustomDropdowns();
            if (!wasOpen) {
                optionsContainer.classList.add('open');
            }
        } else if (option) {
            // Clicked on a specific preset option
            e.stopPropagation();
            const presetValue = option.dataset.value;
            const easingInput = document.getElementById('guard-tweened-easing-input');
            const display = document.getElementById('guard-easing-preset-display');
            const optionsContainer = option.closest('.custom-dropdown-options');

            display.textContent = option.textContent;
            optionsContainer.classList.remove('open');

            if (presetValue !== 'custom' && selectedGuardConnectionForEdit) {
                const easingArray = JSON.parse(presetValue);
                selectedGuardConnectionForEdit.easing = easingArray;
                easingInput.value = easingArray.join(', ');
                easingInput.disabled = true;
                easingInput.style.opacity = '0.6';
            } else if (presetValue === 'custom') {
                // If 'custom' is selected, enable the input for editing
                easingInput.disabled = false;
                easingInput.style.opacity = '1';
                easingInput.focus(); // Focus the input for immediate editing
            }
        }
    });
}
*/


const handleGuardEasingClick = (e) => {
            const dropdownGroup = e.target.closest('#guard-easing-preset-dropdown-group');
            const option = e.target.closest('.custom-dropdown-option');

            if (dropdownGroup && !option) {
                // Clicked on the main dropdown body to open/close it
                e.stopPropagation();
                const optionsContainer = dropdownGroup.querySelector('.custom-dropdown-options');
                const wasOpen = optionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    optionsContainer.classList.add('open');
                }
            } else if (option) {
                // Clicked on a specific preset option
                e.stopPropagation();
                const presetValue = option.dataset.value;
                const easingInput = document.getElementById('guard-tweened-easing-input');
                const display = document.getElementById('guard-easing-preset-display');
                const optionsContainer = option.closest('.custom-dropdown-options');

                display.textContent = option.textContent;
                optionsContainer.classList.remove('open');

                if (presetValue !== 'custom' && selectedGuardConnectionForEdit) {
                    const easingArray = JSON.parse(presetValue);
                    selectedGuardConnectionForEdit.easing = easingArray;
                    easingInput.value = easingArray.join(', ');
                    easingInput.disabled = true;
                    easingInput.style.opacity = '0.6';
                } else if (presetValue === 'custom') {
                    // If 'custom' is selected, enable the input for editing
                    easingInput.disabled = false;
                    easingInput.style.opacity = '1';
                    easingInput.focus(); // Focus the input for immediate editing
                }
            }
        };

        /**
         * Attaches delegated event listeners for the dynamically created easing preset dropdown
         * within the guard condition modal.
         */
        function attachGuardEasingPresetListeners() {
            const dynamicFieldsContainer = document.getElementById('guard-dynamic-fields');
            if (!dynamicFieldsContainer) return;

            // --- MODIFICATION: Remove old listener before adding new one ---
            // Use event delegation on the container for the dropdown elements
            dynamicFieldsContainer.removeEventListener('click', handleGuardEasingClick);
            dynamicFieldsContainer.addEventListener('click', handleGuardEasingClick);
            // --- END MODIFICATION ---
        }



/**
 * Attaches all necessary event listeners for the transition editor modal.
 * This should be called every time the modal is opened to ensure interactivity.
 */
/**
 * Attaches all necessary event listeners for the transition editor modal.
 * This should be called every time the modal is opened to ensure interactivity.
 */
function attachTransitionEditorListeners() {
    // Transition Type Toggle
    const transitionToggle = document.getElementById('transition-type-toggle');
    if (transitionToggle) {
        // Use .onclick to easily replace the listener each time
        transitionToggle.onclick = (e) => {
            const clickedOption = e.target.closest('.boolean-toggle-option');
            if (clickedOption && tempConnectionData) {
                tempConnectionData.transitionType = clickedOption.dataset.value;
                document.querySelectorAll('#transition-type-toggle .boolean-toggle-option').forEach(opt => opt.classList.remove('active'));
                clickedOption.classList.add('active');
                updateDynamicInteractionFields(tempConnectionData.interactionType, tempConnectionData.interactionDetails);
            }
        };
    }

    // Interaction Preset Dropdown
    const presetDropdownGroup = document.getElementById('interaction-preset-dropdown-group');
    if (presetDropdownGroup) {
        const optionsContainer = presetDropdownGroup.querySelector('.custom-dropdown-options');
        const nativeSelect = document.getElementById('interaction-preset-select');
        const display = presetDropdownGroup.querySelector('.custom-dropdown-display');

        // Listener for the main dropdown group to open/close it
        presetDropdownGroup.onclick = (e) => {
            // Prevent clicks on options from closing the dropdown immediately
            if (e.target.closest('.custom-dropdown-option')) return;
            
            e.stopPropagation();
            const wasOpen = optionsContainer.classList.contains('open');
            closeAllCustomDropdowns();
            if (!wasOpen) {
                optionsContainer.classList.add('open');
            }
        };

        // Listener for clicking a specific option
        optionsContainer.onclick = (e) => {
            e.stopPropagation();
            const selectedOption = e.target.closest('.custom-dropdown-option');
            if (selectedOption) {
                const value = selectedOption.dataset.value;
                nativeSelect.value = value;
                display.textContent = selectedOption.textContent;
                optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                selectedOption.classList.add('selected');
                optionsContainer.classList.remove('open');
                
                // Trigger the change event to update dynamic fields
                const changeEvent = new Event('change');
                nativeSelect.dispatchEvent(changeEvent);
            }
        };
    }
}

const handleModalClick = (e) => {
        const target = e.target;
        const variableId = target.closest('[data-variable-id]')?.dataset.variableId;
        if (!variableId || !selectedGuardConnectionForEdit) return;

        const condition = selectedGuardConnectionForEdit.conditions.find(c => c.variableId === variableId);
        if (!condition) return;

        // --- FIX: Retrieve the actual variable object from globalState.inputs ---
        const variable = globalState.inputs.find(v => v.id === variableId);
        if (!variable) {
            console.error("Variable not found in globalState.inputs for ID:", variableId);
            return;
        }
        // Handle Dropdown Toggle
        const dropdownGroup = target.closest('.guard-condition-type-dropdown-group');
        if (dropdownGroup) {
            e.stopPropagation();
            const optionsContainer = dropdownGroup.querySelector('.custom-dropdown-options');
            const wasOpen = optionsContainer.classList.contains('open');
            closeAllCustomDropdowns();
            if (!wasOpen) optionsContainer.classList.add('open');
        }

        // Handle Dropdown Option Selection
        const option = target.closest('.custom-dropdown-option');
        if (option) {
            e.stopPropagation();
            const value = option.dataset.value;
            const display = option.closest('.custom-dropdown-container').querySelector('.custom-dropdown-display');
            condition.condition = value;
            display.textContent = option.textContent;

            // --- NEW: Show/hide value fields based on selection ---
            const group = option.closest('.combined-input-group');
            const isNone = value === 'None';
            group.querySelector('.combined-input-separator').style.display = isNone ? 'none' : 'block';
            group.querySelector('.guard-numeric-value-container').style.display = (variable.type === 'Numeric' && !isNone) ? 'flex' : 'none';
            group.querySelector('.guard-boolean-value-container').style.display = (variable.type === 'Boolean' && !isNone) ? 'flex' : 'none';
            // --- END NEW ---
            option.closest('.custom-dropdown-options').classList.remove('open');
            redrawAll(); // Redraw line text immediately
        }

        // Handle Stepper Buttons
        const numericContainer = target.closest('.guard-numeric-value-container');
        if (numericContainer) {
            const input = numericContainer.querySelector('input');
            if (target.classList.contains('decrement-guard-value')) {
                input.stepDown();
                condition.value = input.value;
            }
            if (target.classList.contains('increment-guard-value')) {
                input.stepUp();
                condition.value = input.value;
            }
            redrawAll(); // Redraw line text immediately
        }

        // Handle Boolean Toggle
        const booleanContainer = target.closest('.guard-boolean-value-container');
        if (booleanContainer && target.closest('.guard-boolean-value-toggle')) {
            const isCurrentlyTrue = (condition.value === 'true' || condition.value === true);
            condition.value = !isCurrentlyTrue;
            const display = booleanContainer.querySelector('.guard-boolean-value-display');
            display.textContent = condition.value ? 'true' : 'false';
            display.style.color = condition.value ? '#28a745' : '#dc3545';
            redrawAll(); // Redraw line text immediately
        }
    };

    const handleModalInput = (e) => {
        const target = e.target;
        const variableId = target.closest('[data-variable-id]')?.dataset.variableId;
        if (!variableId || !selectedGuardConnectionForEdit) return;
        
        const condition = selectedGuardConnectionForEdit.conditions.find(c => c.variableId === variableId);
        if (!condition) return;

        // Handle Numeric Inputs
        if (target.classList.contains('guard-value-input')) {
            condition.value = target.value;
            // Debounce redraw for smoother typing
            clearTimeout(window.redrawDebounce);
            window.redrawDebounce = setTimeout(() => redrawAll(), 300);
        }
    };



function attachDynamicGuardModalListeners() {
    const modalBody = guardConditionModal.querySelector('.modal-body');

    // Use a function to remove and re-add listeners to prevent duplication
    const rebindListeners = () => {
        modalBody.removeEventListener('click', handleModalClick);
        modalBody.removeEventListener('input', handleModalInput);
        modalBody.addEventListener('click', handleModalClick);
        modalBody.addEventListener('input', handleModalInput);
    };

    
    rebindListeners();

    // Also rebind the transition type toggle listener
    const guardTransitionToggle = document.getElementById('guard-transition-type-toggle');
    guardTransitionToggle.removeEventListener('click', handleTransitionTypeClick);
    guardTransitionToggle.addEventListener('click', handleTransitionTypeClick);
}

// Helper for the listener above
const handleTransitionTypeClick = (e) => {
    const clickedOption = e.target.closest('.boolean-toggle-option');
    if (clickedOption && selectedGuardConnectionForEdit) {
        selectedGuardConnectionForEdit.transitionType = clickedOption.dataset.value;
        document.querySelectorAll('#guard-transition-type-toggle .boolean-toggle-option').forEach(opt => opt.classList.remove('active'));
        clickedOption.classList.add('active');
        handleGuardTransitionTypeChange();
    }
};
/*
function updateActionsSection(connection, customDisplay, customOptionsContainer, customNativeSelect, customValueField, editorContent) {
    const toNode = nodes.find(n => n.id === connection.toNodeId);
    const isActionNodeDest = toNode?.type === 'action';

    // If destination is an action node, hide the section. Otherwise, show if globalState exists.
    if (isActionNodeDest || !globalState) {
        actionsSection.style.display = 'none';
    } else {
        actionsSection.style.display = 'block';
        // --- MODIFIED: Remove 'None' option for Action Nodes ---
        const isActionNodeEditor = !!customDisplay; // A simple check to see if we're in the action node context

        // --- NEW: Update the label dynamically ---
        const actionLabel = (customDisplay ? editorContent.querySelector('label') : actionsSection.querySelector('label[for="action-type-select"]'));
        if (actionLabel && globalState && globalState.inputs && globalState.inputs.length > 0) {
            // --- FIX: Use the first variable's name, not the container's name ---
            const variableName = globalState.inputs[0].name;
            actionLabel.textContent = `'${truncateText(variableName, 30)}' will be`;
        }
        // --- END NEW ---

        let actionOptions = [];
        if (!isActionNodeEditor) {
            actionOptions.push({ id: '', name: 'No action selected' });
        }

        // Use provided elements or fallback to the connection modal's elements
        const display = customDisplay || actionTypeDisplay;
        const optionsContainer = customOptionsContainer || actionTypeOptionsContainer;
        const nativeSelect = customNativeSelect || actionTypeNativeSelect;

        // --- NEW: Add event listeners for the dropdown to handle selection ---
        // This ensures that when an option is clicked, the UI updates correctly.
        optionsContainer.onclick = (e) => {
            const option = e.target.closest('.custom-dropdown-option');
            if (option) {
                e.stopPropagation();
                const selectedValue = option.dataset.value;
                nativeSelect.value = selectedValue;
                display.textContent = option.textContent;

                // Update the 'selected' class for visual feedback
                optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                optionsContainer.classList.remove('open');

                // Update the temporary data model and the value field
                if (tempConnectionData) {
                    // --- NEW: Preserve the value when switching between action types ---
                    const currentValue = tempConnectionData.action?.value || document.getElementById('action-value-input').value || '';
                    tempConnectionData.action = selectedValue ? { type: selectedValue } : null;
                    // If a new action is selected, carry over the existing value.
                    if (tempConnectionData.action) {
                        tempConnectionData.action.value = currentValue;
                    }
                    // --- END NEW ---

                    updateActionValueField(selectedValue, currentValue);
                }
            }
        };
        // --- END NEW ---

        // --- NEW: Add listeners for stepper buttons ---
      // Use the provided editorContent or fallback to document to scope the query
        const scope = editorContent || document;
        const actionValueInput = scope.querySelector('#action-value-input, .action-node-value-input');
        const decrementBtn = scope.querySelector('#decrement-action-value, .decrement-action-value');
        const incrementBtn = scope.querySelector('#increment-action-value, .increment-action-value');

        decrementBtn.onclick = () => {
            actionValueInput.stepDown();
            actionValueInput.dispatchEvent(new Event('input'));
        };
        incrementBtn.onclick = () => {
            actionValueInput.stepUp();
            actionValueInput.dispatchEvent(new Event('input'));
        };
        actionValueInput.oninput = () => { tempConnectionData.action.value = actionValueInput.value; };
        // --- END NEW ---

        if (globalState.inputs[0].type === 'Numeric') {
            actionOptions.push({ id: 'Increment', name: `increased by` });
            actionOptions.push({ id: 'Decrement', name: `decreased by` });
            actionOptions.push({ id: 'SetNumeric', name: `set to` });
        } else if (globalState.inputs[0].type === 'Boolean') { // <-- FIX: Was missing .type
            actionOptions.push({ id: 'Toggle', name: `toggled` });
            actionOptions.push({ id: 'SetBoolean', name: `set to` });
        } else if (globalState.inputs[0].type === 'String') { // <-- FIX: Was missing .type
            actionOptions.push({ id: 'SetString', name: `set to` });
        }

        const currentActionType = connection.action ? connection.action.type : '';
        populateDropdowns(nativeSelect, display, optionsContainer, actionOptions, currentActionType);
        updateActionValueField(currentActionType, connection.action ? connection.action.value : '', customValueField);
    }
}
*/
function updateActionValueField(actionType, value = '', customValueField) {
    const fieldContainer = customValueField || document.getElementById('action-value-field');
    const input = fieldContainer.querySelector('input[type="text"], input[type="number"], .action-node-value-input');
    const combinedGroup = fieldContainer.closest('.combined-input-group');
    // --- NEW: Get containers for different value types ---
    // --- MODIFIED: Use class selectors to work for both modals ---
    const numericContainer = fieldContainer.querySelector('.action-numeric-container');
    const booleanContainer = fieldContainer.querySelector('.action-boolean-container');
    const separator = combinedGroup ? combinedGroup.querySelector('.combined-input-separator') : null;

    // --- NEW: Clear any custom UI like the boolean toggle ---
    const existingToggle = fieldContainer.querySelector('.boolean-toggle-container');
    if (existingToggle) existingToggle.remove();
    // --- END NEW ---

    if (!input || !fieldContainer) return;
    // --- NEW: Hide both containers by default ---
    if (numericContainer) numericContainer.style.display = 'none';
    if (booleanContainer) booleanContainer.style.display = 'none';

    if (actionType === 'Increment' || actionType === 'Decrement') {
        fieldContainer.style.display = 'flex';
        if (numericContainer) numericContainer.style.display = 'flex';
        if (separator) separator.style.display = 'block'; // Use 'block' to show
        input.value = value || '1'; // Default to 1 for inc/dec
        input.type = 'number';
    } else if (actionType === 'SetNumeric' || actionType === 'SetString') {
        fieldContainer.style.display = 'flex';
        if (numericContainer) numericContainer.style.display = 'flex';
        if (separator) separator.style.display = 'block'; // Use 'block' to show
        input.value = value;
        input.type = (actionType === 'SetNumeric') ? 'number' : 'text';
    } else if (actionType === 'SetBoolean') {
        // --- NEW: Logic for the new boolean UI ---
        fieldContainer.style.display = 'flex';
        if (separator) separator.style.display = 'block'; // Keep separator for boolean set to
        if (booleanContainer) {
            booleanContainer.style.display = 'flex';
            const display = booleanContainer.querySelector('.action-boolean-value-display');
            const toggleBtn = booleanContainer.querySelector('.action-boolean-value-toggle');
            
            // Set initial value, defaulting to true if not set
            let isTrue = (value === 'true' || value === true || value === '');
            display.textContent = isTrue ? 'true' : 'false';
            display.style.color = isTrue ? '#28a745' : '#dc3545';

            // Update the correct data model (transition or action node)
            if (tempConnectionData && tempConnectionData.action) {
                tempConnectionData.action.value = isTrue;
            } else if (selectedNodeForEdit && selectedNodeForEdit.type === 'action' && selectedNodeForEdit.action) {
                selectedNodeForEdit.action.value = isTrue;
            }

            // Add a one-time listener for the toggle button
            const newToggleBtn = toggleBtn.cloneNode(true); // Clone to remove old listeners
            toggleBtn.parentNode.replaceChild(newToggleBtn, toggleBtn);
            newToggleBtn.addEventListener('click', () => {
                const currentVal = display.textContent === 'true';
                // Re-render the UI with the toggled value
                updateActionValueField(actionType, !currentVal, customValueField); 
                // If it's an action node, trigger an immediate save
                if (customValueField) updateActionNodeFromUI();
            });
        }
    } else {
        // --- MODIFIED: Hide both the value field and the separator when no action is selected ---
        fieldContainer.style.display = 'none';
        if (separator) separator.style.display = 'none';
    }

}

/**
 * Processes a single Lottie JSON object by normalizing its in-point (ip) and adding a "Full Animation" marker.
 * This ensures consistency with animations loaded from .lottie archives.
 * @param {object} animationJson - The parsed Lottie JSON object.
 * @returns {object} A new, processed Lottie JSON object.
 */
function processSingleLottieJson(animationJson) {
    // Create a deep copy to avoid modifying the original object
    const newJson = JSON.parse(JSON.stringify(animationJson));

    const originalIp = newJson.ip || 0;
    // Normalize the main in-point to 0
    if (originalIp !== 0) {
        newJson.ip = 0;
        console.log(`[LOG] Single Lottie JSON: Original ip was ${originalIp}, set to 0.`);
    }

    // Ensure the markers array exists
    if (!newJson.markers) {
        newJson.markers = [];
    }

    // Add or update the 'Full Animation' marker, then validate the rest.
    addOrUpdateFullAnimationMarker(newJson, originalIp);
    validateAndAdjustMarkers(newJson);
    return newJson;
}

/**
 * Validates and adjusts markers in a Lottie JSON to ensure a minimum duration.
 * - Ensures every marker (except "Full Animation") has a duration of at least 2 frames.
 * - Handles the edge case where a 1-frame marker is at the very end of the animation
 *   by shifting its start time back to accommodate the 2-frame duration.
 * @param {object} animationJson - The parsed Lottie JSON object.
 * @returns {object} The Lottie JSON object with validated markers.
 */
function validateAndAdjustMarkers(animationJson) {
    if (!animationJson || !animationJson.markers || !Array.isArray(animationJson.markers)) {
        return animationJson; // Nothing to do if markers don't exist
    }

    const animationOutPoint = animationJson.op;

    animationJson.markers.forEach(marker => {
        // Skip the special "Full Animation" marker from this validation logic
        if (marker.cm === 'Full Animation') return;

        if (marker.dr < 2) {
            // Edge case: If a 1-frame marker is at the very end, shift its start time back.
            if (marker.dr === 1 && (marker.tm + marker.dr) >= animationOutPoint) {
                marker.tm = Math.max(0, marker.tm - 1);
            }
            marker.dr = 2; // Enforce minimum duration of 2 frames
        }
    });
    return animationJson;
}

/**
 * Intelligently adds or updates the "Full Animation" marker for a Lottie JSON.
 * - If a "Full Animation" marker with the exact full frame range already exists, it does nothing.
 * - If a "Full Animation" marker exists but has different timing, it's renamed to "Full Animation - [User]".
 * - It then adds the correct, programmatically generated "Full Animation" marker.
 * @param {object} animationJson - The parsed Lottie JSON object (will be mutated).
 * @param {number} originalIp - The original in-point of the animation before normalization.
 */
function addOrUpdateFullAnimationMarker(animationJson, originalIp) {
    if (!animationJson.markers) {
        animationJson.markers = [];
    }

    const fullDuration = animationJson.op - originalIp;
    const existingMarker = animationJson.markers.find(m => m.cm === 'Full Animation');

    if (existingMarker) {
        // Check if the existing marker has the exact same timing
        if (existingMarker.tm === originalIp && existingMarker.dr === fullDuration) {
            console.log("[LOG] Exact 'Full Animation' marker already exists. Skipping addition.");
            return; // It's a perfect match, do nothing.
        } else {
            // It has the same name but different timing, so rename it.
            console.log("[LOG] Renaming user-defined 'Full Animation' marker.");
            existingMarker.cm = 'Full Animation - [User]';
        }
    }

    // Add the new, correct "Full Animation" marker to the front.
    const fullAnimationMarker = {
        cm: "Full Animation",
        tm: originalIp,
        dr: fullDuration
    };
    animationJson.markers.unshift(fullAnimationMarker);
}

// --- NEW: Central function to set the global animation and update all nodes ---
function setGlobalAnimation(newAnimationId, showAlert = true) {
    globalAnimationId = newAnimationId;
    populateLeftPanelMarkers(newAnimationId); // Ensure markers are populated when global animation changes

    // --- NEW: Destroy old marker card players to prevent memory leaks ---
    if (markerCardPlayers.length > 0) {
        console.log(`[Cleanup] Destroying ${markerCardPlayers.length} old marker card players.`);
        markerCardPlayers.forEach(player => player.destroy());
        markerCardPlayers = []; // Clear the array
    }
    // --- END NEW ---

    // Update all existing nodes
    nodes.forEach(node => {
        // --- FIX: Only reset the marker if the animation ID is actually changing ---
        if (node.type === 'action') {
            return; // Skip action nodes, they don't have animations
        }
        if (node.animationId !== newAnimationId) {
            node.marker = ''; // Reset marker as it belongs to the old animation
        }
        node.animationId = newAnimationId;

        const nodeElement = document.getElementById(node.id);
        if (nodeElement) {
            updateNodeDetailsChips(nodeElement.querySelector('.node'), node);
        }
    });

    // --- NEW: Populate the left panel with the new animation's markers ---
    populateLeftPanelMarkers(newAnimationId);

    // If the properties panel is open, refresh it
    if (selectedNodeForEdit) {
        openNodePropertiesModal(selectedNodeForEdit);
    }

    // Optionally notify the user
    if (showAlert) {
        const animName = availableAnimations.find(a => a.id === newAnimationId)?.name || 'the selected animation';
        showCustomAlert(`All states now use: ${animName}`);
    }
}

// --- NEW: Function to populate the left panel with marker cards (MODIFIED) ---
/*function populateLeftPanelMarkers(animationId) {
    console.log(`[Left Panel] Populating markers for animation ID: ${animationId}`);
    const leftPanelTitle = document.getElementById('left-panel-title');
  const leftPanelScrollArea = document.getElementById('left-panel-scroll-area');
    if (!leftPanelScrollArea) {
        console.error("Left panel scroll area not found!");
        return;
    }
    leftPanelScrollArea.innerHTML = ''; // Clear previous content

    const animation = availableAnimations.find(anim => anim.id === animationId);
    

     // --- NEW: Add a header for the marker list ---
    // This header is now part of the scrollable content, so it moves with the list.
    // The toggle button is outside this scrollable area.
    // ---
    const markerInteractionCounts = {};
    if (animation.jsonContent) {
        try {
            const lottieJson = JSON.parse(animation.jsonContent);
            const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
            const nameToNodeIdMap = new Map(nodes.map(node => [node.name, node.id]));
            const interactiveLayerRegex = /.+_(click|pointerenter|pointerexit|pointerdown|pointerup|pointermove)_to_.+/;
            const interactiveLayers = lottieJson.layers.filter(layer => layer.nm && interactiveLayerRegex.test(layer.nm));

            animation.markers.forEach(marker => {
                let count = 0;
                const markerStart = marker.start;
                const markerEnd = marker.end;

                interactiveLayers.forEach(layer => {
                    // Condition 1: The layer's frame range must overlap with the marker's frame range.
                    if (layer.ip < markerEnd && layer.op > markerStart) {
                        // --- MODIFIED: More robust parsing logic for layer names ---
                        const toSeparator = '_to_';
                        const toIndex = layer.nm.lastIndexOf(toSeparator);

                        if (toIndex !== -1) {
                            const destStateName = layer.nm.substring(toIndex + toSeparator.length);
                            const beforePart = layer.nm.substring(0, toIndex);
                            const lastUnderscoreIndex = beforePart.lastIndexOf('_');
                            const sourceStateName = beforePart.substring(0, lastUnderscoreIndex);
                            const interactionNameInLayer = beforePart.substring(lastUnderscoreIndex + 1);

                            // Condition 2: A corresponding transition must exist in the state machine.
                            const sourceNodeId = nameToNodeIdMap.get(sourceStateName);
                            const destNodeId = nameToNodeIdMap.get(destStateName);

                            const transitionExists = connections.some(conn => {
                                const connInteractionName = conn.interactionType.replace('on', '').toLowerCase();
                                return conn.fromNodeId === sourceNodeId && conn.toNodeId === destNodeId && connInteractionName === interactionNameInLayer;
                            });

                            if (transitionExists && sourceNodeId && destNodeId) {
                                console.log(`[Interaction Count] Marker '${marker.name}' includes VALID interactive layer: '${layer.nm}'`);
                                count++;
                            }
                        }
                    }
                });
                markerInteractionCounts[marker.name] = count;
            });
        } catch (e) {
            console.error("Failed to parse Lottie JSON for interaction counting:", e);
        }
    }

    

   if (!animation || !leftPanelTitle) return;

    // Update the header title
    //leftPanelTitle.textContent = `${truncateText(animation.name, 20)} Segments`;
    leftPanelTitle.textContent = `Available Segments`;
    leftPanelTitle.style.fontSize = '20px';
    leftPanelTitle.style.paddingBottom = '2px';
    
    
    const markerList = document.createElement('div');
    markerList.id = 'marker-list';
     leftPanelScrollArea.appendChild(markerList);

    // --- NEW: Add the "Add a Segment" button to the top of the list ---
    const addSegmentCard = document.createElement('div');
    addSegmentCard.className = 'add-segment-card';
    addSegmentCard.innerHTML = '<i class="fas fa-plus" style="margin-right: 8px;"></i> Add/Edit a Segment';
    addSegmentCard.addEventListener('click', () => {
        // Simulate a click on the main "add segments" button to reuse its logic
        document.getElementById('add-segments-button').click();
    });
    markerList.appendChild(addSegmentCard);
    // --- END NEW ---

    if (animation.markers && animation.markers.length > 0) {
        animation.markers.forEach(marker => {
            const card = document.createElement('div');
            const canvasId = `marker-canvas-${marker.name.replace(/[^a-zA-Z0-9]/g, '-')}`;
            card.className = 'marker-card';
            card.draggable = true;
            // --- MODIFIED: Add preview window and info container ---
            const interactionCount = markerInteractionCounts[marker.name] || 0;
            const interactionClass = interactionCount > 0 ? '' : 'hidden';
            const interactionText = interactionCount > 0 ? `${interactionCount} Click Area${interactionCount > 1 ? 's' : ''}` : '';

            card.innerHTML = `
                <div class="marker-preview">
                    <canvas id="${canvasId}"></canvas>
                </div>
                <div class="marker-info">
                    <div class="marker-info-left">
                        <span class="marker-name">${marker.name}</span>
                        <span class="marker-frames">Frames: ${Math.round(marker.start)} - ${Math.round(marker.end)}</span>
                    </div>
                    <div class="marker-interactions ${interactionClass}">${interactionText}</div>
                </div>`;
            
            // --- NEW: Add click listener to the interactions pill for viewing ---
            const interactionsPill = card.querySelector('.marker-interactions');
            if (interactionsPill && interactionCount > 0) {
                interactionsPill.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent card drag from firing
                    openClickAreaViewer(animation.id, marker.name);
                });
            }

            card.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', marker.name);
                e.dataTransfer.effectAllowed = 'copy';
            });
            markerList.appendChild(card);

            // --- NEW: Instantiate a Lottie player for this card ---
            const canvas = document.getElementById(canvasId);
            if (canvas && animation.jsonContent) {
                const player = new DotLottie({
                    canvas: canvas,
                    autoplay: true,
                    loop: true,
                    data: JSON.parse(animation.jsonContent),
                    segment: [marker.start, marker.end]
                });
                //player.setSegment(marker.start, marker.end);
                markerCardPlayers.push(player); // Add to array for later cleanup
            }
            // --- END NEW ---
        });
    }
}  
commenting this becuase there might be update issues with the markers set for each state with the new fucntion    
*/



function populateLeftPanelMarkers(animationId) {
console.log(`[Left Panel] Populating markers for animation ID: ${animationId} with Hover-to-Play.`);
const leftPanelTitle = document.getElementById('left-panel-title');
const leftPanelScrollArea = document.getElementById('left-panel-scroll-area');
if (!leftPanelScrollArea) {
console.error("Left panel scroll area not found!");
return;
}
leftPanelScrollArea.innerHTML = ''; // Clear previous content// Clear previous content

    const animation = availableAnimations.find(anim => anim.id === animationId);
if (!animation || !leftPanelTitle) return;

// --- OPTIMIZATION 1: CLEANUP EXISTING PLAYERS ---
// Destroy all previous players to prevent memory leaks and stop background playback.
if (markerCardPlayers.length > 0) {
    markerCardPlayers.forEach(player => {
        if (player && typeof player.destroy === 'function') {
            player.destroy();
        }
    });
    markerCardPlayers = [];
    console.log(`[Cleanup] Destroyed ${markerCardPlayers.length} old marker card players.`);
}
// ------------------------------------------------

// Update the header title
leftPanelTitle.textContent = `Available Segments`;
leftPanelTitle.style.fontSize = '20px';
leftPanelTitle.style.paddingBottom = '2px';

// Calculate interaction counts before rendering
const markerInteractionCounts = {};
if (animation.jsonContent) {
    try {
        const lottieJson = JSON.parse(animation.jsonContent);
        const nameToNodeIdMap = new Map(nodes.map(node => [node.name, node.id]));
        const interactiveLayerRegex = /.+_(click|pointerenter|pointerexit|pointerdown|pointerup|pointermove)_to_.+/;
        const interactiveLayers = lottieJson.layers.filter(layer => layer.nm && interactiveLayerRegex.test(layer.nm));

        animation.markers.forEach(marker => {
            let count = 0;
            const markerStart = marker.start;
            const markerEnd = marker.end;

            interactiveLayers.forEach(layer => {
                if (layer.ip < markerEnd && layer.op > markerStart) {
                    const toSeparator = '_to_';
                    const toIndex = layer.nm.lastIndexOf(toSeparator);

                    if (toIndex !== -1) {
                        const destStateName = layer.nm.substring(toIndex + toSeparator.length);
                        const beforePart = layer.nm.substring(0, toIndex);
                        const lastUnderscoreIndex = beforePart.lastIndexOf('_');
                        const sourceStateName = beforePart.substring(0, lastUnderscoreIndex);
                        const interactionNameInLayer = beforePart.substring(lastUnderscoreIndex + 1);

                        const sourceNodeId = nameToNodeIdMap.get(sourceStateName);
                        const destNodeId = nameToNodeIdMap.get(destStateName);

                        const transitionExists = connections.some(conn => {
                            const connInteractionName = conn.interactionType.replace('on', '').toLowerCase();
                            return conn.fromNodeId === sourceNodeId && conn.toNodeId === destNodeId && connInteractionName === interactionNameInLayer;
                        });

                        if (transitionExists && sourceNodeId && destNodeId) {
                            count++;
                        }
                    }
                }
            });
            markerInteractionCounts[marker.name] = count;
        });
    } catch (e) {
        console.error("Failed to parse Lottie JSON for interaction counting:", e);
    }
}


const markerList = document.createElement('div');
markerList.id = 'marker-list';
leftPanelScrollArea.appendChild(markerList);

// Add the "Add a Segment" button
const addSegmentCard = document.createElement('div');
addSegmentCard.className = 'add-segment-card';
addSegmentCard.innerHTML = '<i class="fas fa-plus" style="margin-right: 8px;"></i> Add/Edit a Segment';
addSegmentCard.addEventListener('click', () => {
    document.getElementById('add-segments-button').click();
});
markerList.appendChild(addSegmentCard);

if (animation.markers && animation.markers.length > 0) {
    animation.markers.forEach(marker => {
        const card = document.createElement('div');
        const canvasId = `marker-canvas-${marker.name.replace(/[^a-zA-Z0-9]/g, '-')}`;
        card.className = 'marker-card';
        card.draggable = true;

        const interactionCount = markerInteractionCounts[marker.name] || 0;
        const interactionClass = interactionCount > 0 ? '' : 'hidden';
        const interactionText = interactionCount > 0 ? `${interactionCount} Click Area${interactionCount > 1 ? 's' : ''}` : '';
        
        // --- MODIFIED HTML to include the edit button ---
        card.innerHTML = `
            <div class="marker-preview">
                <canvas id="${canvasId}"></canvas>
            </div>
            <div class="marker-info">
                <div class="marker-info-left">
                    <span class="marker-name">${marker.name}</span>
                    <span class="marker-frames">Frames: ${Math.round(marker.start)} - ${Math.round(marker.end)}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div class="marker-interactions ${interactionClass}">${interactionText}</div>
                    <button class="edit-segment-btn" title="Edit Segment"><i class="fas fa-pencil-alt"></i></button>
                </div>
            </div>`;
        
        const interactionsPill = card.querySelector('.marker-interactions');
        if (interactionsPill && interactionCount > 0) {
            interactionsPill.addEventListener('click', (e) => {
                e.stopPropagation();
                openClickAreaViewer(animation.id, marker.name);
            });
        }

        card.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', marker.name);
            e.dataTransfer.effectAllowed = 'copy';
        });
        markerList.appendChild(card);

        // --- ADD THIS: Event listener for the new edit button ---
        const editButton = card.querySelector('.edit-segment-btn');
        if (editButton) {
            editButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent card drag from firing
                
                const animationData = availableAnimations.find(anim => anim.id === animationId);
                if (!animationData || !animationData.jsonContent) {
                    alert("Could not find the JSON data for this animation.");
                    return;
                }

                const cropToolModal = document.getElementById('crop-tool-modal');
                const cropToolIframe = document.getElementById('crop-tool-iframe');
                const header = cropToolModal.querySelector('.modal-header');
                const iframe = cropToolModal.querySelector('#crop-tool-iframe');
                
                cropToolModal.style.opacity = '0';
                if (header) { header.style.opacity = '0'; header.style.transform = 'translateY(-20px)'; }
                if (iframe) { iframe.style.opacity = '0'; iframe.style.transform = 'translateY(20px)'; }

                cropToolModal.style.display = 'flex';
                cropToolIframe.src = 'overlay.html';

                setTimeout(() => {
                    cropToolModal.style.opacity = '1';
                    if (header) { header.style.opacity = '1'; header.style.transform = 'translateY(0)'; }
                    if (iframe) { iframe.style.opacity = '1'; iframe.style.transform = 'translateY(0)'; }
                }, 10);

                // Post both messages once the iframe is loaded
                cropToolIframe.onload = () => {
                    // 1. Send the main animation data
                    cropToolIframe.contentWindow.postMessage({
                        type: 'lottieData',
                        data: JSON.parse(animationData.jsonContent),
                        filename: `${animationData.id}.json`
                    }, '*');

                    // 2. Send the command to edit the specific segment
                    cropToolIframe.contentWindow.postMessage({
                        type: 'editSegment',
                        segmentName: marker.name
                    }, '*');
                };
            });
        }
        // --- END ADD ---


        // --- HOVER-TO-PLAY LOGIC ---
        const canvas = document.getElementById(canvasId);
        if (canvas && animation.jsonContent) {
            const player = new DotLottie({
                canvas: canvas,
                autoplay: false,
                loop: true,
                data: JSON.parse(animation.jsonContent),
                segment: [marker.start, marker.end]
            });
            
            player.setSpeed(1.0);
            markerCardPlayers.push(player);

            card.addEventListener('mouseenter', () => {
                player.play();
            });

            card.addEventListener('mouseleave', () => {
                player.pause();
                player.setFrame(marker.start); 
            });
        }
    });
}
}

/**
 * Cleans a Lottie JSON object by removing interactive layers that no longer have a corresponding transition in the state machine.
 * @param {object} lottieJson - The parsed Lottie JSON data.
 * @param {string} sourceStateName - The name of the state from which transitions originate.
 * @param {Array<object>} allConnections - The global `connections` array of the flowchart.
 * @param {Array<object>} allNodes - The global `nodes` array of the flowchart.
 * @returns {{cleanedJson: object, removedCount: number}} - An object containing the cleaned JSON and the count of removed layers.
 */
function cleanOrphanedInteractiveLayers(lottieJson, allConnections, allNodes) {
    console.log('[GC] Starting cleanup of orphaned interactive layers.');

    if (!lottieJson || !lottieJson.layers) {
        return { cleanedJson: lottieJson, removedCount: 0 };
    }

    const nodeIdToNameMap = new Map(allNodes.map(node => [node.id, node.name]));
    const nameToNodeIdMap = new Map(allNodes.map(node => [node.name, node.id]));
    let removedCount = 0;

    const validLayerNames = new Set();
    const pointerInteractionTypesForLog = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
    allConnections.forEach(conn => {
        if (pointerInteractionTypesForLog.includes(conn.interactionType)) {
            const sourceStateName = nodeIdToNameMap.get(conn.fromNodeId);
            const destStateName = nodeIdToNameMap.get(conn.toNodeId);
            if (sourceStateName && destStateName) {
                const interactionName = conn.interactionType.replace('on', '').toLowerCase();
                const layerName = `${sourceStateName}_${interactionName}_to_${destStateName}`;
                validLayerNames.add(layerName);
            }
        }
    });
    console.log(`[GC] Found ${validLayerNames.size} valid interactive layer names from ${allConnections.length} connections.`, validLayerNames.size > 0 ? Array.from(validLayerNames) : '');

    const originalLayers = lottieJson.layers;
    const cleanedLayers = originalLayers.filter(layer => {
        const layerName = layer.nm;
        if (!layerName) return true; // Keep layers without a name

        // --- MODIFIED: Use the more robust parsing logic ---
        const toSeparator = '_to_';
        const toIndex = layerName.lastIndexOf(toSeparator);
        const interactiveLayerRegex = /.+_(click|pointerenter|pointerexit|pointerdown|pointerup|pointermove)_to_.+/;

        // Check if the layer name matches the interactive layer pattern
        if (interactiveLayerRegex.test(layerName)) {
            // If the layer name is in the valid set, keep it.
            if (validLayerNames.has(layerName)) {
                return true;
            } else {
                // If it's not in the valid set, it's an orphan. Remove it.
                console.log(`[GC] Removing orphaned interactive layer: '${layerName}' as no matching transition was found.`);
                removedCount++;
                return false; // Filter out (remove) this layer
            }
        }
        return true; // Keep the layer
    });

    lottieJson.layers = cleanedLayers;
    return { cleanedJson: lottieJson, removedCount };
}


// --- NEW: Function to open the click area editor (refactored from button listener) ---
function openClickAreaEditor() {
    // --- FIX: Use tempConnectionData for generating the layer name ---
    if (!tempConnectionData) {
        showCustomAlert("No connection is selected for editing.");
        return;
    }

    const fromNode = nodes.find(n => n.id === tempConnectionData.fromNodeId);
    if (!fromNode) {
        showCustomAlert("Could not find the source node for this connection.");
        return;
    }

    const animationData = availableAnimations.find(anim => anim.id === fromNode.animationId);
    if (!animationData || !animationData.jsonContent) {
        showCustomAlert("Could not find the Lottie JSON for the source node's animation.");
        return;
    }

    // --- NEW: Generate transition-specific layer name ---
    const toNode = nodes.find(n => n.id === tempConnectionData.toNodeId);
    const interactionName = tempConnectionData.interactionType.replace('on', '').toLowerCase();
    const layerName = `${fromNode.name}_${interactionName}_to_${toNode.name}`;

    // --- NEW: Detect if interaction type changed and find the old layer name ---
    let oldLayerNameToExclude = null;
    if (selectedConnectionForEdit && selectedConnectionForEdit.interactionType !== tempConnectionData.interactionType) {
        const oldInteractionName = selectedConnectionForEdit.interactionType.replace('on', '').toLowerCase();
        const oldFromNodeName = nodes.find(n => n.id === selectedConnectionForEdit.fromNodeId)?.name;
        const oldToNodeName = nodes.find(n => n.id === selectedConnectionForEdit.toNodeId)?.name;

        if (oldFromNodeName && oldToNodeName) {
            oldLayerNameToExclude = `${oldFromNodeName}_${oldInteractionName}_to_${oldToNodeName}`;
            console.log(`[LOG] Interaction type changed. Will exclude old layer from guides: '${oldLayerNameToExclude}'`);
        }
    }
    // --- END NEW ---

    const markerName = fromNode.marker || 'Full Animation'; // Use marker name or default

    // --- NEW: Animate the connection editor modal OUT ---
    const connEditorContent = connectionEditorModal.querySelector('.connection-editor-content');
    if (connEditorContent) {
        connEditorContent.style.transform = 'scale(0.82)';
    }
    // --- END NEW ---
    // --- FIX: Ensure save button is visible for edit mode ---
    document.getElementById('save-click-area-button').style.display = 'flex';
    // --- END FIX ---

    // Show the modal and set the iframe source
    // --- MODIFIED: Entrance Animation Logic ---
    // 1. Set initial animated-out state
    const header = clickAreaModal.querySelector('.modal-header');
    const iframe = clickAreaModal.querySelector('#click-area-iframe');
    clickAreaModal.style.opacity = '0';
    if (header) { header.style.opacity = '0'; header.style.transform = 'translateY(-20px)'; }
    if (iframe) { iframe.style.opacity = '0'; iframe.style.transform = 'translateY(120px)'; }

    clickAreaModal.style.display = 'flex';
    // --- FIX: Reset pointer-events on open ---
    // This ensures the modal is interactive every time it's opened.
    clickAreaModal.style.pointerEvents = 'auto';
    // --- END FIX ---
    clickAreaIframe.src = 'clickAreaEditor/clickAreaEditor.html';
    
    // 2. In the next frame, transition to the final state
    setTimeout(() => {
        clickAreaModal.style.opacity = '1';
        if (header) { header.style.opacity = '1'; header.style.transform = 'translateY(0)'; }
        if (iframe) { iframe.style.opacity = '1'; iframe.style.transform = 'translateY(0)'; }
    }, 10);


    // Wait for the iframe to load before sending data
    clickAreaIframe.onload = () => {
        // --- NEW: Clean orphaned layers before sending data ---
        let lottieJson = JSON.parse(animationData.jsonContent);
        const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, connections, nodes);

        if (removedCount > 0) {
            console.log(`[LOG] Cleaned ${removedCount} orphaned interactive layer(s) from the Lottie data before opening the editor.`);
            // Update the master animation data with the cleaned version
            animationData.jsonContent = JSON.stringify(cleanedJson);
        }

        const messageData = {
            type: 'lottieDataForMarker',
            animationData: cleanedJson, // Send the cleaned JSON
            markerName: markerName,
            layerName: layerName,
            animationId: animationData.id, // Pass the unique ID
            oldLayerName: oldLayerNameToExclude // --- NEW: Pass the old layer name ---
        };

        console.log('[LOG] Sending data to Click Area Editor iframe:', messageData);

        clickAreaIframe.contentWindow.postMessage(messageData, '*');
    };
}

// --- MODIFIED: Function to apply a pop animation and text change to the 'Change Target Area' button ---
function animateClickAreaButtonOnSave() {
    const button = document.getElementById('edit-click-area-button'); // This is the target button
    if (!button) return;

    const icon = button.querySelector('i');
    if (!icon) return;

    // --- NEW: Animation Logic ---
    // 1. Store original icon and apply shockwave
    const originalIconClass = icon.className;
    button.classList.add('button-shockwave-effect');

    // 2. Change to checkmark and animate it in
    icon.className = 'fas fa-check';
    icon.classList.add('icon-saved');

    // 3. After a delay, revert everything back to the original state
    setTimeout(() => {
        // Remove animation classes to allow them to be re-triggered
        button.classList.remove('button-shockwave-effect');
        icon.classList.remove('icon-saved');
        
        // Restore the original crosshairs icon
        icon.className = originalIconClass;
    }, 1500); // Keep the checkmark visible for 1.5 seconds
}





    // --- NEW: Function to open the click area editor in VIEW-ONLY mode ---
function openClickAreaViewer(animationId, markerName) {
    const animationData = availableAnimations.find(anim => anim.id === animationId);
    if (!animationData || !animationData.jsonContent) {
        showCustomAlert("Could not find the Lottie JSON for this animation.");
        return;
    }

    // 1. Animate the connection editor modal OUT (if it's open)
    const connEditorContent = connectionEditorModal.querySelector('.connection-editor-content');
    if (connEditorContent && connectionEditorModal.classList.contains('open')) {
        connEditorContent.style.transform = 'scale(0.82)';
    }

    // 2. Configure and show the click area modal for viewing
    const header = clickAreaModal.querySelector('.modal-header');
    const iframe = clickAreaModal.querySelector('#click-area-iframe');
    clickAreaModal.style.opacity = '0';
    if (header) { header.style.opacity = '0'; header.style.transform = 'translateY(-20px)'; }
    if (iframe) { iframe.style.opacity = '0'; iframe.style.transform = 'translateY(20px)'; }

    // Hide the save button for view-only mode
    document.getElementById('save-click-area-button').style.display = 'none';

    clickAreaModal.style.display = 'flex';
    clickAreaModal.style.pointerEvents = 'auto';
    clickAreaIframe.src = 'clickAreaEditor/clickAreaEditor.html';

    // 3. Animate the modal in
    setTimeout(() => {
        clickAreaModal.style.opacity = '1';
        if (header) { header.style.opacity = '1'; header.style.transform = 'translateY(0)'; }
        if (iframe) { iframe.style.opacity = '1'; iframe.style.transform = 'translateY(0)'; }
    }, 10);

    // 4. Send the view-only message to the iframe once it loads
    clickAreaIframe.onload = () => {
        const messageData = { type: 'lottieDataForViewer', animationData: JSON.parse(animationData.jsonContent), markerName: markerName, animationId: animationData.id };
        console.log('[Viewer] Sending data to Click Area Viewer iframe:', messageData);
        clickAreaIframe.contentWindow.postMessage(messageData, '*');
    };
}

// --- NEW: Attach the new function to the button's click event ---
editClickAreaButton.addEventListener('click', openClickAreaEditor);

// --- FIX: Correctly trigger the save action in the click area iframe ---
document.getElementById('save-click-area-button').addEventListener('click', () => {
    const iframe = document.getElementById('click-area-iframe');
    if (iframe && iframe.contentWindow) {
        // The click-marker tool's save button is now the primary one, so we just click it.
        iframe.contentWindow.document.getElementById('download-button')?.click();
    }
});
// --- END FIX ---

        // --- NEW: State Machine Player Logic ---
        const playStateMachineButton = document.getElementById('play-state-machine-button');
        const stateMachinePlayerModal = document.getElementById('state-machine-player-modal');
        const stateMachinePlayerIframe = document.getElementById('state-machine-player-iframe');
        const closePlayerButton = document.getElementById('close-state-machine-player-button');

        async function openStateMachinePlayer() {
    // 1. Ensure current properties are saved
    saveNodePropertiesButton.click();

    // --- OPTIMIZATION: PAUSE MAIN PREVIEW PLAYER ---
    if (modalDotLottiePlayer) {
        console.log("Pausing main modal preview player...");
        modalDotLottiePlayer.pause();
    }
    // --- END OPTIMIZATION ---

    // 2. Get necessary data for export
    const initialNodeName = findInitialNodeId();
    const selectedAnimation = availableAnimations.find(anim => anim.id === globalAnimationId);

    if (!selectedAnimation) {
        showCustomAlert("Cannot play: The globally selected animation could not be found.");
        return;
    }

    // 3. Generate the .lottie file data in memory (as a Blob)
    const lottieBlob = await exportLottieFile(nodes, connections, initialNodeName, globalState, guardConnections, [selectedAnimation], true);

    if (!lottieBlob) {
        showCustomAlert("Failed to generate state machine data for the player.");
        return;
    }
    
    // 4. Modal animation and iframe loading setup
    const playerContent = stateMachinePlayerModal.querySelector('.modal-content');

    // Set initial animated-out state
    stateMachinePlayerModal.style.opacity = '0';
    playerContent.style.opacity = '0';
    playerContent.style.transform = 'translateY(80px) scale(0.98)';

    stateMachinePlayerModal.style.display = 'flex';
    stateMachinePlayerIframe.src = 'runStateMachine.html';

    // In the next frame, transition to the final state
    setTimeout(() => {
        stateMachinePlayerModal.style.opacity = '1';
        playerContent.style.opacity = '1';
        playerContent.style.transform = 'translateY(0) scale(1)';
    }, 10);
    
    // 5. Wait for the iframe to load, then post the data
    stateMachinePlayerIframe.onload = () => {
        const animationJson = JSON.parse(selectedAnimation.jsonContent);
        const stateMachineJson = convertNodesAndConnectionsToJson(nodes, connections, initialNodeName, globalState, guardConnections);

        const reader = new FileReader();
        reader.onload = (e) => {
            stateMachinePlayerIframe.contentWindow.postMessage({
                type: 'lottieData',
                dataUrl: e.target.result,
                animationJson: animationJson,         
                stateMachineJson: stateMachineJson  
            }, '*');
        };
        reader.readAsDataURL(lottieBlob);
    };
}
        
        function closeStateMachinePlayer() {
    // Modal animation logic
    const playerContent = stateMachinePlayerModal.querySelector('.modal-content');

    // 1. Animate the content window up and out
    playerContent.style.opacity = '0';
    playerContent.style.transform = 'translateY(80px) scale(0.98)';

    // 2. Start fading out the backdrop after a short delay
    setTimeout(() => {
        stateMachinePlayerModal.style.opacity = '0';
    }, 100);

    // 3. After all animations complete, hide the modal and reset states
    setTimeout(() => {
        stateMachinePlayerModal.style.display = 'none';
        stateMachinePlayerIframe.src = 'about:blank'; // Clear the iframe content

        // --- OPTIMIZATION: RESUME MAIN PREVIEW PLAYER ---
        if (modalDotLottiePlayer && selectedNodeForEdit) {
            console.log("Resuming main modal preview player...");
            // Resume only if the node is configured for continuous playback (autoplay=true)
            if (selectedNodeForEdit.autoplay) {
                modalDotLottiePlayer.play();
            }
        }
        // --- END OPTIMIZATION ---

    }, 500); // Duration matches the CSS transition
}

        playStateMachineButton.addEventListener('click', openStateMachinePlayer);
        closePlayerButton.addEventListener('click', closeStateMachinePlayer);

    const sharePlayerJsonButton = document.getElementById('share-player-json-button');
        const shareTutorialModal = document.getElementById('share-tutorial-modal');
        const closeShareModalButton = document.getElementById('close-share-modal-button');
        const shareModalCopyButton = document.getElementById('share-modal-copy-button');
        const shareModalLinkInput = document.getElementById('share-modal-link-input');
        const shareModalGenerateButton = document.getElementById('share-modal-generate-button');
        const shareModalGenerateContainer = document.getElementById('share-modal-generate-container');
        const shareModalResultContainer = document.getElementById('share-modal-result-container');
        const shareModalFinalLinkInput = document.getElementById('share-modal-final-link');
        const shareModalCopyFinalLinkButton = document.getElementById('share-modal-copy-final-link-button');



        // --- NEW: Logic for copying player JSON to clipboard ---
        const copyPlayerJsonButton = document.getElementById('copy-player-json-button');

      async function copyPlayerJsonToClipboard() {
            const iframe = document.getElementById('state-machine-player-iframe');
            if (!iframe || !iframe.contentWindow) {
                showCustomAlert("Error: Player is not loaded.");
                return;
            }
            console.log("Requesting layout JSON from iframe...");
            iframe.contentWindow.postMessage({ type: 'requestLayoutJson' }, '*');
        }

        // --- NEW: Share Modal Listeners ---
        if (sharePlayerJsonButton) {
            sharePlayerJsonButton.addEventListener('click', () => {
                // Reset modal state
                shareModalLinkInput.value = '';
                shareModalCopyButton.innerHTML = `<i class="fas fa-copy"></i> <span>Copy Data</span>`;
                shareModalCopyButton.disabled = false;
                shareModalGenerateContainer.style.display = 'block';
                shareModalResultContainer.style.display = 'none';
                shareModalFinalLinkInput.value = '';
                
                // Open the modal
                shareTutorialModal.style.display = 'flex';
            });
        }

        if (closeShareModalButton) {
            closeShareModalButton.addEventListener('click', () => {
                shareTutorialModal.style.display = 'none';
            });
        }

        if (shareModalCopyButton) {
            shareModalCopyButton.addEventListener('click', copyPlayerJsonToClipboard);
        }

        if (shareModalGenerateButton) {
            shareModalGenerateButton.addEventListener('click', async () => {
                const url = shareModalLinkInput.value.trim();
                const button = shareModalGenerateButton;
                const buttonText = button.querySelector('span');
                const loader = button.querySelector('.button-loader');

                // 1. Show loader
                buttonText.style.display = 'none';
                loader.style.display = 'block';
                button.disabled = true;

                // 2. Validate Link Format
                if (!isValidJsonKeeperLink(url)) {
                    showCustomAlert("Invalid Link. Must be from jsonkeeper.com and in the format /b/ID");
                    buttonText.style.display = 'inline';
                    loader.style.display = 'none';
                    button.disabled = false;
                    return;
                }

                // 3. Validate JSON Content
                try {
                    const isValid = await isValidJsonContent(url);
                    if (!isValid) {
                        throw new Error("Content is not valid state machine JSON.");
                    }

                    // 4. Success! Generate final link
                    const id = url.split('/').pop();
                    const finalLink = `https://ishantperiwal.github.io/lottiemonbeta?dotLottie=${id}`;
                    
                    // --- MODIFIED: Truncate the displayed link but store the full link for copying ---
                    const displayLink = `ishantperiwal.github.io/.../${id}`;
                    shareModalFinalLinkInput.value = displayLink;
                    shareModalFinalLinkInput.dataset.fullLink = finalLink; // Store full link in a data attribute
                    // --- END MODIFICATION ---

                    shareModalGenerateContainer.style.display = 'none';
                    shareModalResultContainer.style.display = 'block';

                } catch (error) {
                    showCustomAlert(`Validation Failed: ${error.message}`);
                } finally {
                    // 5. Hide loader
                    buttonText.style.display = 'inline';
                    loader.style.display = 'none';
                    button.disabled = false;
                }
            });
        }

        if (shareModalCopyFinalLinkButton) {
            shareModalCopyFinalLinkButton.addEventListener('click', async () => {
                const fullLink = shareModalFinalLinkInput.dataset.fullLink;
                if (!fullLink) return;

                // --- NEW: Use modern clipboard API for reliability ---
                try {
                    await navigator.clipboard.writeText(fullLink);
                } catch (err) {
                    // Fallback for older browsers
                    const textarea = document.getElementById('hidden-copy-textarea');
                    textarea.value = fullLink;
                    textarea.select();
                    document.execCommand('copy');
                }
                // --- END NEW ---

                shareModalCopyFinalLinkButton.innerHTML = `<i class="fas fa-check"></i> <span>Copied!</span>`;
                setTimeout(() => {
                    shareModalCopyFinalLinkButton.innerHTML = `<i class="fas fa-copy"></i> <span>Copy</span>`;
                }, 2000);
            });
        }
        // --- NEW: Logic for the download button inside the player modal ---
        const downloadPlayerLottieButton = document.getElementById('download-player-lottie-button');
        downloadPlayerLottieButton.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent the click from bubbling up and closing the modal

            // This logic is copied from the main `export-lottie-button` listener
            saveNodePropertiesButton.click(); 
            const initialNodeName = findInitialNodeId();
            const selectedAnimation = availableAnimations.find(anim => anim.id === globalAnimationId);

            if (!selectedAnimation) {
                showCustomAlert("Cannot export: The globally selected animation could not be found.");
                return;
            }

            await exportLottieFile(nodes, connections, initialNodeName, globalState, guardConnections, [selectedAnimation]);
        });

       


    </script>
</body>
</html>
    
