<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottie State Machine Flowchart Creator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@400;500;600;700&display=swap">
    <script type="module" src="https://cdn.skypack.dev/@dotlottie/player-component@2.4.1"></script>

    <style>
    body {
  font-family: 'Hanken Grotesk', sans-serif;
  margin: auto;

  background-color: #f0f2f5;
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100vh;
  width: 100%;
  overflow: hidden;
  color: #333;
}
      .error{
        display: none !important;
      }
      #add-segments-button,
      #connect-nodes-button { 
        display: none !important;
      }

      /* --- NEW: Hide the individual animation dropdown in the side panel --- */
      #animation-dropdown-group {
          display: none !important;
      }

      /* --- NEW: Style for the global animation dropdown --- */
      #global-animation-controls {
          position: absolute;
          top: 20px;
          left: 20px;
          z-index: 101; /* Above controls */
          width: 280px;
          background-color: #ffffff;
          border-radius: 16px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
          padding: 0; /* The dropdown-group inside will have padding */
      }

      /* --- MODIFIED: Style changes for global animation dropdown --- */
      #global-animation-controls .dropdown-group {
          background-color: #ffffff; /* Make background white */
          border: none; /* Remove border */
          align-items: center; /* Vertically align icon and text */
          gap: 12px; /* Adjust gap */
          padding-left: 12px; /* Add padding for the icon */
      }

      #global-animation-controls .dropdown-group label {
          display: none; /* Hide the "GLOBAL ANIMATION" label */
      }

      /* Remove the column layout for the label/dropdown container */
      #global-animation-controls .dropdown-group > div:first-of-type {
         gap: 0; /* Remove gap between hidden label and dropdown */
      }

      /* --- NEW: Modern Vertical Floating Bar for Controls --- */
      #controls {
          position: absolute;
          top: 50%;
          left: 20px;
          transform: translateY(-50%);
          display: flex;
          flex-direction: column;
          gap: 8px; /* Tighter gap for a unified look */
          z-index: 100;
          background-color: #ffffff;
          padding: 10px;
          border-radius: 999px; /* Pill shape */
          box-shadow: 0 8px 24px rgba(0,0,0,0.12); /* Softer, modern shadow */
          transition: box-shadow 0.2s ease-in-out;
      }

      #controls button {
          width: 44px; /* Slightly smaller for a tighter bar */
          height: 44px;
          padding: 0;
          font-size: 18px; /* Slightly smaller icons */
          cursor: pointer;
          background-color: transparent; /* Buttons are transparent */
          color: #555; /* Dark grey icon color */
          border: none;
          border-radius: 50%; /* Keep them circular within the bar */
          display: flex;
          justify-content: center;
          align-items: center;
          transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
          box-shadow: none; /* Remove individual button shadows */
      }

      #controls button:hover {
          background-color: #f0f2f5; /* Light grey background on hover */
          color: #333; /* Slightly darker icon on hover */
      }

      #controls button:active {
          background-color: #e4e6e9; /* Slightly darker for active state */
      }
      /* --- END NEW --- */

        #flowchart-area {
            width: 100%;

            height: 100%; /* Fixed viewport size */
            
            background-color: #f5f5f5; /* Lighter background to distinguish from canvas-container */
            position: relative;
            overflow: hidden; /* Clip canvas content to this viewport */
            border-radius: 12px;

            cursor: default; /* Default cursor for the grey area */
        }

        #canvas-container {
            position: absolute;
            left: 0;
            top: 0;
            /* width and height will be dynamically set by JavaScript */
            background-color: #f5f5f5; /* Actual canvas background */
            cursor: grab; /* Specific cursor for the pannable white canvas */
        }

        .node {
            width: 180px; /* Corresponds to NODE_WIDTH in JS */
            min-height: 100px; /* Corresponds to NODE_HEIGHT in JS */
            background-color: #ffffff; /* Cleaner white background */
            border: 1px solid #e0e0e0; /* Softer border */
            border-radius: 16px; /* More rounded corners */
            position: absolute; /* Position relative to canvas-container */
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 16px; /* Slightly adjusted padding */
            box-sizing: border-box;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* Softer, more modern shadow */
            font-size: 14px;
            text-align: left;
            transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out; /* Smooth transitions */
            user-select: none;
            z-index: 20;
        }

        /* NEW: Invisible hover area around the node */
        .node::before {
            content: '';
            position: absolute;
            /* Use CSS variable for dynamic hover area. calc() is used to make it negative. */
            top: calc(-1 * var(--node-hover-padding, 8%)); /* Fallback to 8% */
            left: calc(-1 * var(--node-hover-padding, 8%));
            right: calc(-1 * var(--node-hover-padding, 8%));
            bottom: calc(-1 * var(--node-hover-padding, 8%));
            /* Make the area invisible */
            background-color: transparent;
            /* Ensure the hover area has rounded corners to match the node */
            border-radius: 24px; /* Slightly more than the node's 16px */
            z-index: -1; /* Position it behind the node's content */
        }

        /* NEW: Global State Node */
        .global-state-node {
            width: 120px;
            height: 120px;
            background-color: #fffbe6; /* Light yellow */
            border: 2px solid #ffd600; /* Amber solid border */
            border-radius: 50%; /* Circular */
            position: absolute;
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center; /* This will center the text horizontally */
            justify-content: center;
            padding: 15px;
            box-sizing: border-box;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            text-align: center;
            user-select: none;
            z-index: 25; /* Higher than regular nodes */
        }
        .global-state-node:hover {
            box-shadow: 4px 4px 12px rgba(0,0,0,0.25);
            border-color: #ffc107;
        }
        .global-state-node.selected-for-connection {
            border-color: #ff9800; /* Amber, to match the other selection */
            box-shadow: 0 0 0 4px #ff9800; /* Amber glow */
        }
        .global-state-node.active {
            border-color: #D2691E; /* Brownish-orange border */
            box-shadow: 0 0 0 4px #F4A460, 3px 3px 8px rgba(0,0,0,0.2); /* Lighter brownish-orange glow */
        }

        /* NEW: Port for the Global State Node */
        .global-state-node .node-port {
            opacity: 0.8; /* Make it visible by default */
            transform: scale(1);
            transition: opacity 0.2s, transform 0.2s;
            background-color: #ff9800; /* Orange to match guard connections */
        }

        /* NEW: Action Node Styles */
        .action-node {
            background-color: #e8eaf6; /* Indigo light */
            border-color: #9fa8da; /* Indigo lighter */
            width: 140px; /* Wider to fit text */
            height: 100px; /* Keep height */
            padding: 10px;
            justify-content: center;
            align-items: center;
            text-align: center;
            transform: translateY(5px);
        }
        .action-node .edit-node-icon,
        .action-node .node-title,
        .action-node .node-details {
            display: none; /* Hide text and edit icon */
        }
        .action-node.no-action::before {
            content: ''; /* The circle is now only a fallback */
            display: none;
            width: 40px;
            height: 40px;
            border: 4px solid #5c6bc0; /* Indigo */
            border-radius: 50%;
            background-color: #c5cae9;
        }

        /* NEW: Styles for text inside the action node */
        .action-node-display {
            font-size: 18px;
            font-weight: bold;
            color: #3f51b5; /* Indigo */
        }
        .action-node-display .action-target {
            display: block;
            font-size: 12px;
            font-weight: normal;
            color: #5c6bc0;
        }

        .node:hover {
            border-color: #c0c0c0; /* Slightly darker border on hover */
            box-shadow: 0 6px 16px rgba(0,0,0,0.12); /* Lift up on hover */
        }

        .node.active {
            border-color: #2196f3; /* Blue border for active node */
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.3), 0 4px 12px rgba(0,0,0,0.1); /* Softer blue glow */
        }

        .node.selected-for-connection {
            border-color: #ff9800;
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.4); /* Softer orange glow */
        }

        .node-title {
            font-weight: bold;
            margin-bottom: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            width: 100%;
            color: #1a237e;
        }
        .node-details {
            font-size: 12px;
            color: #555;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Increased gap for better spacing between items */
            width: 100%;
            margin-top: 8px; /* Increased margin for more space from the title */
            pointer-events: none;
        }
        .node-details i {
            font-size: 12px;
            color: #666;
        }

        .node-detail-chip {
            display: inline-flex;
            align-items: center;
            font-size: 12px; /* Match parent font-size */
            font-weight: 500; /* Made the text a bit bolder */
            color: #555; /* Match parent color */
            white-space: nowrap;
            gap: 8px;
        }

        .chip-animation,
        .chip-loop,
        .chip-speed { background-color: transparent; }

        .edit-node-icon {
            display: none; /* Removed as requested */
        }
        .edit-node-icon:hover {
            background-color: #455a64;
        }

        /* Updated node port styles */
        .node-port {
            position: absolute;
            width: 16px; /* Original size */
            height: 16px; /* Original size */
            border-radius: 50%; /* Circle shape */
            border: 4px solid white; /* Original border */
            background-color: #28a745; /* Green for all ports */
            z-index: 15;
            cursor: crosshair;
            opacity: 0; /* Hidden by default */
            transform: scale(0); /* Scaled down by default */
            /* Faster appearance, delayed disappearance */
            transition: opacity 0.15s ease-in, transform 0.15s ease-in;
            transition-delay: 0.2s; /* Delay for disappearing */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Show and animate ports on node hover */
        .node-wrapper:hover .node-port {
            opacity: 1;
            transform: scale(1); /* Original scale up */
            transition-delay: 0s; /* No delay on appearance */
        }

        /* --- NEW: Translate animation for ports on node hover --- */
        .node-wrapper:hover .node-port.right-port {
            transform: scale(1.1) translateX(6px); /* Move right port outwards */
        }
        .node-wrapper:hover .node-port.left-port {
            transform: scale(1.1) translateX(-6px); /* Move left port outwards */
        }
        /* --- END NEW --- */

        .node-port:hover {
            opacity: 1;
            transform: scale(1.2); /* Slightly larger on direct port hover */
            transition-delay: 0s; /* No delay on appearance */
        }
        /* Positioning for each port */
        .node-port.top-port {
            top: -10px; /* Original offset */
            left: calc(50% - 10px); /* Original offset */
           
            display: none !important; /* Still disable top/bottom for now */
            pointer-events: none !important;
        }
        .node-port.right-port {
            right: -10px; /* Original offset */
            top: calc(50% - 10px); /* Original offset */
            /* FIX: Center port vertically (16px height / 2) */
        }
        .node-port.bottom-port {
            bottom: -10px; /* Original offset */
            left: calc(50% - 10px); /* Original offset */
           
            display: none !important; /* Still disable top/bottom for now */
            pointer-events: none !important;
        }
        .node-port.left-port {
            left: -10px; /* Original offset */
            top: calc(50% - 10px); /* Original offset */
        }

        /* Class to force immediate hiding by JS */
        .node-port.hidden-by-js {
            opacity: 0 !important;
            transform: scale(0) !important;
            transition-delay: 0s !important; /* No delay for immediate hiding */
        }

        /* Highlighted destination port in connection mode */
        .node-port.highlighted-destination-port {
            opacity: 1 !important;
            transform: scale(1.2) !important;
            pointer-events: none !important; /* Ensure node click passes through */
            transition-delay: 0s !important; /* No delay for highlighting */
        }
        /* NEW: Hide ports on action nodes completely */
        .action-node .node-port {
            display: none !important;
        }


        /* Modal Dialog Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000; /* Default z-index for modals */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        /* Update modal-content to use flexbox */
        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 32px;
            width: 90%;
            max-width: 800px; /* Increased max-width to accommodate preview */
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            animation-name: animatetop;
            animation-duration: 0s;
            position: relative;
            display: flex; /* Make it a flex container */
            gap: 30px; /* Space between preview and content */
            flex-direction: column;
        }

        .preview-container {
             /* Prevent it from shrinking */
            width: 200px; /* Fixed width for the preview area */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0; /* Light background for the preview area */
            border-radius: 12px;
            overflow: hidden; /* Ensure content stays within bounds */
            padding: 15px; /* Add some padding inside the preview container */
            box-shadow: inset 0 0 8px rgba(0,0,0,0.1); /* Subtle inner shadow */
        }

        /* NEW: Wrapper for the main content area of the modal */
        .modal-main-content {
            flex: 1.3; /* Allows this wrapper to take up available space */
            display: flex; /* Makes its children (header, body, footer) stack vertically */
            flex-direction: column;
        }

        @keyframes animatetop {
            from {transform: translateY(-100px); opacity: 0}
            to {transform: translateY(0); opacity: 1}
        }
        .modal-header {
            display: flex;
            justify-content: space-between; /* To push close button to right */
            align-items: center; /* Vertically align input and close button */
            padding-bottom: 15px; /* Keep some padding if needed for other elements */
            margin-bottom: 10px; /* Keep margin bottom for spacing below header */

            margin-left: 20px; /* Remove previous margin-left */
            /* Add a subtle separator */
            margin-left: 14px;
        }

        /* Style for the node name input field in the header */
        .modal-header #node-name {
            flex-grow: 1; /* Allow input to take available space */
            width: auto; /* Override modal-body width */
            padding: 0; /* Remove default padding */
            margin-bottom: 0; /* Remove default margin-bottom from modal-body rule */
            font-size: 28px; /* Bigger text */
            font-weight: bold;
            color: #333;
            background-color: transparent; /* No background */
            border: none; /* No border in unselected state */
            box-shadow: none; /* No shadow */
            border-radius: 0; /* No border radius */
            box-sizing: content-box; /* Ensures padding/border doesn't add to width */
            outline: none; /* Remove default focus outline */
        }

        /* On selection (focus), only have bottom border */
        .modal-header #node-name:focus {
            border: none; /* Ensure no border on other sides */
            border-bottom: 2px solid #2196f3; /* Blue bottom border */
            /* Add some padding for visual separation */
            transition: border-bottom 0.2s ease-in-out; /* Smooth transition for border */
        }

        /* Adjust the close button if needed to align better after input changes */


        .modal-header h2 {
            margin: 0;
            font-size: 24px;
            color: #333;
        }

        .close-button {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: none;
            padding-bottom: 6px; /* Keep close button transition instant */
        }

        .close-button:hover,
        .close-button:focus {
            color: #666;
        }



        .modal-body input[type="range"],
        .modal-body input[type="checkbox"],
        .modal-body input[type="text"],
        .modal-body input[type="number"] { /* Added number type */
            margin-bottom: 20px;
            width: calc(100% - 16px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 15px;
        }



        /* Hide native select element */
        .modal-body select {
            display: none;
        }

        .modal-body label {
            margin-bottom: 0; /* Remove default margin from label to let gap handle it */
            font-weight: bold; /* Keep bold if desired */
            color: #555; /* Keep color if desired */
            font-size: 12px; /* Keep font-size if desired */
            letter-spacing: 1px;
        }

        .dropdown-group {
            background-color: #e6f6ff7a; /* Softer, light grey background */
            border: 2px solid #b8cde329; /* Subtle border */
            border-radius: 16px; /* Modern, less pronounced rounding */
            padding: 12px 16px; /* Adjusted padding */
            margin-bottom: 8px; /* Space between dropdown groups */
            display: flex; /* Use flexbox for label and select alignment */
            gap: 8px; /* Space between label and select */
            width: auto; /* Allow dropdown groups to size based on content or flex */
            flex: 1; /* Distribute space equally among dropdowns */
            position: relative; /* Needed for absolute positioning of custom dropdown options */
            cursor: pointer; /* Indicate clickable area */
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out; /* Smooth transitions */
        }

        /* Custom Dropdown Styles */
        .custom-dropdown-container {
            position: relative;
            flex-grow: 1; /* Allows the container to take available space */
        }

        .custom-dropdown-display {
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            color: #333;
            padding-right: 20px; /* Space for the arrow icon */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            width: 100%; /* Ensure it takes full width of its flex item */
            box-sizing: border-box; /* Include padding in width */
        }

        .custom-dropdown-options {
            display: none; /* Hidden by default */
            position: absolute;
            background-color: #ffffff;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1050; /* Ensure it's above other elements */
            border-radius: 12px; /* Match parent rounding */
            
            overflow-y: auto;
            width: 250px; /* Set a minimum width for better readability */
            left: 0;
            top: calc(100% + 18px); /* Increased vertical space */
            border: 1px solid #e0e0e0; /* Softer border */
            padding: 6px; /* Padding inside the options box */
        }

        .custom-dropdown-options.open {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #global-animation-options.open {
            display: flex;
            flex-direction: column;
            gap: 4px;
            transform: translateX(-32px);
        }

        .custom-dropdown-option {
            padding: 10px 14px; /* Increased padding for more spacious items */
            cursor: pointer;
            font-size: 15px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 8px; /* Rounded corners for each option */
            transition: background-color 0.15s ease-in-out; /* Smooth hover effect */
        }

        .custom-dropdown-option:hover {
            background-color: #f1f3f5; /* Light grey for hover */
        }

        .custom-dropdown-option.selected {
            background-color: #e9ecef; /* Darker grey for selected option */
            font-weight: 600; /* Semi-bold for selected option */
        }


        .modal-body input[type="range"] {
            width: 100%;
            padding: 0;
        }
        .modal-body .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-body .checkbox-group label {
            margin-bottom: 0;
            margin-left: 8px;
        }


        /* Styles for the toggle switch */
        .toggle-group {
            display: flex;
             gap: 10px;
            justify-content: space-between; /* Pushes label and switch to ends */
            align-items: center;
            flex-direction: row;
            border-radius: 8px;
            padding: 15px;
        }

        .toggle-group label {
           margin: auto;
            font-weight: bold;
            color: #555;
            font-size: 12px;
            text-transform: uppercase;
            flex-grow: 1; /* Allow label to take available space */
        }

        /* The switch - the box around the slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 52px; /* Width of the toggle */
            height: 32px; /* Height of the toggle */
        }

        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 24px; /* Height of the draggable circle/thumb */
            width: 24px;  /* Width of the draggable circle/thumb */
            left: 4px; /* Initial position of the thumb */
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: #2196F3; /* Color when toggle is ON */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(20px); /* Move thumb to the right when ON */
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%; /* Make the thumb circular */
        }


        .modal-footer {

            padding-top: 20px;
            margin-top: 25px;
            text-align: right;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* General button styles within modal-footer */
  .modal-footer button {
      padding: 12px 25px; /* Default padding for other buttons like Cancel */
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 8px; /* Default border-radius for other buttons */
      transition: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  /* Specific styles for the circular Save button */
  .modal-footer button.save {
      background-color: #28a745;
      color: white;
      width: 50px;   /* Fixed width for circular shape */
      height: 50px;  /* Fixed height for circular shape */
      padding: 0;    /* Remove padding to center icon */
      border-radius: 50%; /* Make it circular */
      display: flex; /* Use flexbox to center content (icon) */
      justify-content: center; /* Center horizontally */
      align-items: center; /* Center vertically */
      font-size: 20px; /* Adjust icon size */
      margin-left: 10px; /* Adjust spacing from Cancel button if needed */
  }

  .modal-footer button.save:hover {
      background-color: #218838;
  }

  /* Specific styles for the circular Delete button */
  .modal-footer button.delete {
      background-color: #dc3545;
      color: white;
      width: 50px;   /* Fixed width for circular shape */
      height: 50px;  /* Fixed height for circular shape */
      padding: 0;    /* Remove padding to center icon */
      border-radius: 50%; /* Make it circular */
      display: flex; /* Use flexbox to center content (icon) */
      justify-content: center; /* Center horizontally */
      align-items: center; /* Center vertically */
      font-size: 20px; /* Adjust icon size */
  }

  .modal-footer button.delete:hover {
      background-color: #c82333;
  }

  /* Ensure other buttons (like Cancel) retain their original look */
  .modal-footer button.cancel {
      background-color: #6c757d;
      color: white;
      margin-right: 10px; /* Keep margin for spacing */
      padding: 12px 25px; /* Reapply specific padding for cancel button */
      font-size: 16px; /* Reapply specific font-size for cancel button */
      border-radius: 8px; /* Reapply specific border-radius for cancel button */
      width: 50px;   /* Fixed width for circular shape */
      height: 50px; /* Fixed height for circular shape */
      border-radius: 50%; /* Make it circular */
  }
  .modal-footer button.cancel:hover {
      background-color: #5a6268;
  }

        /* Connection SVG Styling */
        #connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            cursor: grab;
            transform: translateY(5px);
        }

        .connection-line { /* This class will now apply to SVG <path> elements */
            stroke: #3498db;
            stroke-width: 2;
            fill: none;
            pointer-events: none;
            cursor: pointer;
            transition: none;
            opacity: 1.0; /* Make lines fully opaque */
        }
        .connection-line:hover {
            stroke: #2980b9;
            stroke-width: 3.5;
        }
        /* NEW: Guard Connection Line */
        .guard-connection-line {
            stroke: #dc3545; /* Solid Red */
            stroke-width: 2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
            opacity: 0.7;
        }
        .guard-connection-line:hover {
            stroke: #2980b9;
            stroke-width: 3.5;
        }
        /* NEW: Styles for Guard Connection Text Pills */
        .guard-connection-text-bg {
            fill: #ffebee; /* Light Red */
            stroke: #ef9a9a; /* Lighter Red */
            stroke-width: 1;
            rx: 8;
            ry: 8;
            pointer-events: all;
            cursor: pointer;
            transition: fill 0.2s ease-in-out;
        }
        .guard-connection-text-bg:hover {
            fill: #ffcdd2; /* Slightly darker light red on hover */
        }
        .guard-connection-text {
            font-size: 12px;
            fill: #c62828; /* Darker Red for text */
            text-anchor: middle;
            dominant-baseline: middle;
            font-weight: bold;
            user-select: none;
            pointer-events: none;
        }
        .connection-line.selected-connection {
            stroke: #ff5722;
            stroke-width: 5;
        }
        .connection-line.active-connection {
            opacity: 1.0; /* Full opacity for active connections */
        }
        .connection-line-arrow {
            fill: #3498db; /* Match the line color */
            pointer-events: none;
        }

        .connection-text-bg {
            fill: #e0f2f7;
            stroke: #a7d9ed;
            stroke-width: 1;
            rx: 8;
            ry: 8;
            pointer-events: all;
            cursor: pointer;
            transition: none;
        }
        .connection-text-bg:hover {
            fill: #cce9f2;
            stroke: #8cc2da;
        }

        .connection-text {
            font-size: 12px;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: middle; /* Better vertical centering for text */
            font-weight: bold;
            user-select: none;
            pointer-events: none;
        }

        /* Ghost line styles */
        #ghost-connection-line {
            stroke: #999;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5; /* Dotted line */
            pointer-events: none;
            display: none; /* Hidden by default */
        }
        #ghost-connection-arrow {
            fill: #999;
            pointer-events: none;
            display: none; /* Hidden by default */
        }


        /* Connection Editor Dialog */
        .connection-editor-modal {
            display: none;
            position: fixed;
            z-index: 1002; /* Z-index for connection editor */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }

        .connection-editor-content {
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #ddd;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            animation-name: animatetop;
            animation-duration: 0s; /* Keep animation instant */
        }
        /* Dynamic fields container */
        #dynamic-interaction-fields {
            margin-top: 20px;
            padding-top: 15px;

        }
        .dynamic-field-group {
            margin-bottom: 15px;
        }
        .dynamic-field-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #333;
        }
        .dynamic-field-group input[type="text"],
        .dynamic-field-group input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ccc;
            border-radius: 16px;
            font-size: 15px;
            box-sizing: border-box;
            background-color: #e6f6ff7a;
        }

        /* NEW: Style for the full-width pill button */
        .full-width-pill-button {
            width: 100%;
            padding: 12px;
            font-size: 15px;
            font-weight: bold;
            color: #333;
            background-color: #d4edda; /* Pastel green background */
            color: #155724; /* Dark green text for contrast */
            border: 1px solid #c3e6cb; /* Matching pastel green border */
            border-radius: 999px; /* Pill shape */
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .full-width-pill-button:hover {
            background-color: #c3e6cb; /* Slightly darker green on hover */
            border-color: #b1dfbb;
        }

        .connection-editor-content .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px; /* Adjust margin for spacing */
        }
        /* Specific styles for connection editor buttons */
        .connection-editor-content .modal-footer button.cancel {
            background-color: #6c757d;
            color: white;
            padding: 12px 25px; /* Reapply specific padding for cancel button */
            font-size: 16px; /* Reapply specific font-size for cancel button */
            border-radius: 8px; /* Reapply specific border-radius for cancel button */
            transition: none; /* Keep button transitions instant */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-right: 10px; /* Add some margin for spacing */
        }
        .connection-editor-content .modal-footer button.cancel:hover {
            background-color: #5a6268;
        }


        .mode-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            z-index: 1001;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        #connect-mode-indicator {
            background-color: #ff9800;
            color: white;
        }
        /* NEW: Guard Mode Indicator */
        #guard-mode-indicator {
            background-color: #fbc02d; /* Yellow */
            color: #333;
        }

        #connection-exists-indicator { /* New style for connection exists message */
            background-color: #dc3545; /* Red background */
            color: white;
        }

        /* Custom alert styling */
        .custom-alert-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Ensure it's on top of other modals */
        }
        .custom-alert-box {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 350px;
            width: 90%;
        }
        .custom-alert-box p {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        .custom-alert-box button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
        }
        .custom-alert-box button:hover {
            background-color: #0056b3;
        }

        .chip-marker{
          display: none;
        }


        /* Styles for the State Preview Window */
      #state-preview-window {
          position: fixed;
          top: 0; /* Flush with the top of the viewport */
          right: 0; /* Flush with the right of the viewport */
          width: 350px; /* Adjust as needed */
          height: 100%; /* Full viewport height */
          background-color: #ffffff;
          border-radius: 0; /* Remove border-radius for a sidebar look */
          box-shadow: -6px 0 20px rgba(0, 0, 0, 0.1); /* Adjusted shadow for sidebar */
          z-index: 1000; /* Ensure it's above other content but below modals */
          transform: translateX(0); /* Initial state: fully visible */
          transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Smooth slide animation */
          display: flex;
          flex-direction: row; /* Content and toggle button side-by-side */
      }

      #state-preview-window.hidden {
          transform: translateX(calc(100% - 30px)); /* Hide, leaving only the 30px button visible */
          box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1); /* Lighter shadow when tucked away */
      }

      #preview-content {
          flex-grow: 1; /* Takes up most of the space */
          padding: 0; /* Remove padding to allow content to be flush */
          overflow-y: auto; /* Enable scrolling for the entire panel if content overflows */
          height: 100%; /* Ensure it takes full height to manage scrolling correctly */
      }

      #preview-toggle-button {
          width: 30px; /* Width of the button 'knotch' */
          height: 60px; /* Height of the button 'knotch' */
          background-color: #4a90e2; /* Blue, matching other controls */
          color: white;
          display: flex;
          justify-content: center;
          align-items: center;
          cursor: pointer;
          font-size: 18px;
          position: absolute; /* Position relative to #state-preview-window */
          left: -30px; /* Protrude by its own width */
          top: 50%; /* Center vertically */
          transform: translateY(-50%);
          border-top-left-radius: 8px; /* Rounded corners for the knotch */
          border-bottom-left-radius: 8px;
          box-shadow: -2px 0 5px rgba(0, 0, 0, 0.15); /* Shadow for the button */
          transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Add transition for button */
      }

      #preview-toggle-button:hover {
          background-color: #357bd8;
          box-shadow: -3px 0 8px rgba(0, 0, 0, 0.2);
      }

      /* Icon rotation for hide/show */
      #preview-toggle-button i {
          transition: transform 0.3s ease-in-out;
      }

      /* Arrow points right when window is visible (initial state) and then rotates to point left when window is hidden */
      #state-preview-window:not(.hidden) #preview-toggle-button i {
          transform: rotate(0deg); /* Arrow points right (inwards from the perspective of the *tucked* window) */
      }

      #state-preview-window.hidden #preview-toggle-button i {
          transform: rotate(180deg); /* Arrow points left (outwards from the perspective of the *tucked* window) */
      }

      /* NEW: Styles for the global state properties when inside the preview window */
      #global-state-properties-container {
          display: none; /* Hidden by default */
          flex-direction: column;
          height: 100%;
          width: 100%;
          padding: 0px 20px;
          box-sizing: border-box;
          overflow-y: auto;
      }

      #global-state-properties-container .modal-header h2 {
          font-size: 24px;
          color: #333;
      }

      #global-state-properties-container .modal-body {
          padding-top: 6px;
      }

      #global-state-properties-container .modal-footer {
          margin-top: auto; /* Pushes footer to the bottom */
          padding-top: 20px;
      }
      /* NEW: Match the input style of the node properties panel */
      #global-state-properties-container .modal-body #global-state-name-input {
          width: 100%;
          padding: 0;
          margin-bottom: 0;
          font-size: 24px; /* Match node name font size */
          font-weight: bold;
          color: #333;
          background-color: transparent;
          border: none;
          box-shadow: none;
          border-radius: 0;
          outline: none;
          border-bottom: 2px solid transparent; /* Transparent border to prevent layout shift on focus */
          transition: border-bottom 0.2s ease-in-out;
      }
      #global-state-properties-container .modal-body #global-state-name-input:focus {
          border-bottom: 2px solid #2196f3; /* Blue bottom border on focus */
      }
      #global-state-properties-container .dynamic-field-group label[for="global-state-name-input"] {
          display: none; /* Hide the "Variable Name" label as it's now implied */
      }


      /* Specific styles for the node-properties-modal */
              #node-properties-modal.modal { /* Target specifically the node properties modal */
                  background-color: transparent; /* Remove the black overlay for this modal only */
                  justify-content: stretch; /* Stretch horizontally */
                  align-items: stretch;     /* Stretch vertically */
                  padding: 0; /* Remove any padding that might prevent it from taking full space */
              }

              /* Update modal-content specifically for node-properties-modal */
              #node-properties-modal .modal-content {
                  background-color: #ffffff; /* Keep background white */
                  padding: 0; /* Remove padding for full-screen effect */
                  border: 1px solid #ddd; /* Keep border if desired, or remove */
                  border-radius: 0; /* Remove border-radius for sharp edges */
                  width: 100%; /* Make it take full width */
                  max-width: none; /* Remove max-width constraint */
                  height: 100%; /* Make it take full height */
                  box-shadow: none; /* Remove box shadow */
                  animation-name: none; /* Remove animation for instant appearance */
                  gap: 0; /* Remove gap between preview and main content */
                  flex-direction: column; /* Keep column direction for modal-content */
              }

              /* Adjust preview-container and modal-main-content for the specific node-properties-modal */
              #node-properties-modal .preview-container {
                  position: relative; /* Needed for absolute positioning of the overlay */
                  flex-shrink: 0; /* Prevent the preview from shrinking */
                  width: auto;
                  padding: 20px; /* Add back desired padding inside the preview */
                  border-radius: 0;
                  background-color: #f0f0f0;
                  box-shadow: none;
                  display: flex;
                  flex-direction: column;
                  justify-content: flex-start;
                  align-items: center;
              }

              /* NEW: Wrapper for canvas to handle overlay clipping */
              #canvas-wrapper {
                  position: relative; /* Full width of its container */
                  width: 99.1%; /* Full width of its container */
                  flex-grow: 1; /* Allow it to take up available vertical space */
                  border-radius: 12px 12px 0 0; /* Only round the top corners */
                  overflow: hidden; /* This is crucial for clipping */
                  border: 1px solid #ccc;
                  border-bottom: none; /* Remove bottom border as it will be on the slider */
              }


              /* NEW: Speed Control Overlay */
              #speed-control-overlay {
                  width: 100%; /* Take full width of parent */
                  background: rgba(255, 255, 255, 0.65); /* Light, semi-transparent background */
                  backdrop-filter: blur(8px); /* Frosted glass effect */
                  -webkit-backdrop-filter: blur(10px);
                  padding: 12px 15px; /* Slightly more vertical padding */
                  border-radius: 0 0 12px 12px; /* Round the bottom corners */
                  display: flex;
                  align-items: center;
                  gap: 12px;
                  color: #333; /* Dark text for readability on light background */
                  border: 1px solid #ccc;
                  border-top: none; /* Top border is handled by the canvas wrapper */
                  box-sizing: border-box; /* Ensure padding/border are included in width */
              }

              /* Style the slider within the overlay */
              #speed-control-overlay #speed-slider {
                  flex-grow: 1;
                  margin: 0;
                  width: auto; /* Override any other width settings */
                  padding: 0; /* Remove default padding */
                  background: #e5e5e5; /* Make track transparent */
              }

              /* NEW: White Theme Slider Styles */
              #speed-slider {
                  -webkit-appearance: none;
                  appearance: none;
                  height: 6px; /* Thinner bar for a lighter feel */
                  background: rgba(0, 0, 0, 0.1); /* Light grey track */
                  border-radius: 3px;
                  outline: none;
                  transition: opacity .2s;
              }

              /* Webkit (Chrome, Safari) Thumb */
              #speed-slider::-webkit-slider-thumb {
                  -webkit-appearance: none;
                  appearance: none;
                  width: 18px;
                  height: 18px;
                  background: #4a90e2; /* Primary blue color for visibility */
                  border: 2px solid white; /* Keep white border for contrast */
                  border-radius: 50%;
                  cursor: pointer;
                  margin-top: -3px; /* Center thumb on the 6px track */ /* FIX: Center thumb on the 6px track */
                  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
              }

              /* Mozilla (Firefox) Thumb */
              #speed-slider::-moz-range-thumb {
                  width: 18px;
                  height: 18px;
                  background: #4a90e2; /* Primary blue color for visibility */
                  border: 2px solid white; /* Keep white border for contrast */
                  border-radius: 50%;
                  cursor: pointer;
                  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
              }

              /* Remove default track styles for Firefox */
              #speed-slider::-moz-range-track {
                  width: 100%;
                  height: 6px; /* Thinner bar for a lighter feel */
                  background: rgba(0, 0, 0, 0.1); /* Light grey track */
                  border-radius: 3px;
                  border: none;
              }

              /* Style the speed value text */
              #speed-control-overlay #speed-value {
                  font-weight: 600;
                  font-size: 13px;
                  min-width: 40px; /* Reserve space to prevent layout shift */
                  text-align: center;
              }

              #node-properties-modal .modal-main-content {
                  flex: 1;
                  overflow-y: auto; /* Allow this section to scroll if content overflows */
                  display: flex; /* Make it a flex container to manage children */
                  flex-direction: column; /* Stack children vertically */
              }

              /* Hide the scrollbar but keep it scrollable */
              #node-properties-modal .modal-main-content::-webkit-scrollbar {
                  display: none; /* For Chrome, Safari, and Opera */
              }
              #node-properties-modal .modal-main-content {
                  -ms-overflow-style: none;  /* For Internet Explorer and Edge */
                  scrollbar-width: none;  /* For Firefox */
              }

              #node-properties-modal .modal-header {
                  margin-bottom: 16px;
                  padding: 20px 20px 0 20px; /* Apply padding here */
              }

              /* Minor adjustment for input in modal header specific to node properties modal */
              #node-properties-modal .modal-header #node-name {
                  font-size: 24px;
                  padding-left: 0;
                  padding-right: 0;
                  margin-left: 0;
                  margin-right: 0;
                  margin-top: 10px;
                  width: 100%;
              }

              #node-properties-modal .modal-body {
                  padding: 0 20px; /* Apply horizontal padding here */
                  flex-grow: 1;
                  display: flex;
                  flex-direction: column;
              }

              #node-properties-modal .modal-footer {
                  position: sticky;
                  bottom: 0;
                  background-color: #ffffff;
                  padding: 15px 20px; /* Apply padding here */
                  margin-top: auto; /* Pushes footer to bottom in flex container */
                  border-top: 1px solid #e0e0e0; /* Separator line */
                  /* Ensure it's above the scrolling content if z-index issues arise */
                  z-index: 10;
              }

              /* Ensure generic modal styles for other modals remain unchanged */
              .modal { /* This will still apply to other modals like connection-editor-modal */
                  /* The original styles for .modal */
                  display: none;
                  position: fixed;
                  z-index: 1000;
                  left: 0;
                  top: 0;
                  width: 100%;
                  height: 100%;
                  overflow: auto;
                  background-color: rgba(0,0,0,0.5); /* Keep semi-transparent background for other modals */
                  justify-content: center;
                  align-items: center;
              }

              /* And other .modal-content styles not overridden by #node-properties-modal .modal-content */
              .modal-content {
                  background-color: #ffffff;
                  padding: 30px; /* Original padding for other modals */
                  border: 1px solid #ddd;
                  border-radius: 32px;
                  width: 90%;
                  max-width: 800px;
                  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
                  animation-name: animatetop;
                  animation-duration: 0s;
                  position: relative;
                  display: flex;
                  gap: 30px;
                  flex-direction: column;
              }

        .node.initial-node {
            background-color: #ffffff; /* Keep the node background white, same as other nodes. */
        }
        /* Style for the 'Initial' pill */
        .node.initial-node::after {
            content: 'Initial';
            position: absolute;
            top: 12px;
            right: 12px;
            background-color: #28a745; /* Green pill background */
            color: #ffffff; /* White text */
            padding: 3px 8px;
            border-radius: 999px; /* Pill shape */
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Green text for the title of the initial node */
        .node.initial-node .node-title {
            color: #2e7d32; /* Dark green */
        }

        /* NEW: Global State Description Text */
        .global-state-description {
            width: 100%;
            background-color: #fffbe6; /* Light yellow */
            color: #854d0e; /* Dark amber text */
            text-align: left;
            border-radius: 8px;
            padding: 10px 14px;
            border: 1px solid #fde68a; /* Yellow border */
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 32px; /* Space between description and input */
            box-sizing: border-box;
        }
        
        /* NEW: Prompt for creating a global node from the action panel */
        .action-node-prompt {
            background-color: #fffbe6; /* Light yellow */
            color: #854d0e; /* Dark amber text */
            border: 1px solid #fde68a; /* Yellow border */
            border-radius: 16px;
            padding: 25px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: auto; /* This will vertically center the box in the flex container */
            max-width: 300px;
        }

        .action-node-prompt p {
            margin: 0;
            font-size: 15px;
            font-weight: 500;
            line-height: 1.5;
        }

        .action-node-prompt button {
            background-color: #f59e0b; /* Amber */
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        /* END NEW */

        /* Lighter green text for the details of the initial node */
        .node.initial-node .node-details,
        .node.initial-node .node-details i {
            color: #4caf50; /* Lighter green */
        }

        /* NEW: Styles for the combined input group in the guard modal */
        .combined-input-group {
            display: flex;
            align-items: stretch; /* Make children fill the height */
            background-color: #e6f6ff7a;
            border: 2px solid #b8cde329;
            border-radius: 16px;
        }
        .combined-input-separator {
            width: 1px;
            background-color: #d0e0f0; /* A slightly darker separator line */
            margin: 8px 0; /* Vertical margin to not touch the top/bottom */
        }

    </style>
</head>
<body>
  <div id="state-preview-window">

          <div id="preview-toggle-button">
              <i class="fas fa-chevron-right"></i> </div>          


              <div id="node-properties-modal" class="modal" style="display: flex;overflow: hidden;">
                  <div class="modal-content" style=" justify-content: space-between;">
                     <div class="preview-container">
                         <div class="panel-type-indicator" style="
                                            margin: 0 auto;
                                            margin-bottom: 12px;
                                            font-size: 14px;
                                            letter-spacing: 1.4px;
                                            font-weight: bold;
                                            text-transform: uppercase;
                                            opacity: 0.5;
                                        ">State Node</div>
                         <div id="canvas-wrapper">
                             <canvas id="modal-lottie-canvas" style="width: 100%; height: 100%; background-color: white;"></canvas>
                         </div>
                         <div id="speed-control-overlay">
                             <i class="fas fa-tachometer-alt"></i>
                             <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="1.0">
                             <span id="speed-value">1.0x</span>
                         </div>
                     </div>
                      <div class="modal-main-content">
                          <div class="modal-header">
                               <input type="text" id="node-name" value="New Node" placeholder="Node Name">
                              <span class="close-button" style="display: none;">&times;</span>
                          </div>
                          <div class="modal-body">
                            <div style="display: flex; flex-direction:column; justify-content: space-between; gap: 16px;">
                            <div class="dropdown-group" id="animation-dropdown-group">
                              <div style="
              display: flex;
              flex-direction: column;
              gap: 0.3rem;
          ">
                                  <label for="animation-select">ANIMATION</label>
                                  <div class="custom-dropdown-container">
                                      <div class="custom-dropdown-display" data-target-select="animation-select"></div>
                                      <div class="custom-dropdown-options" id="animation-options"></div>
                                      <select id="animation-select" style="display: none;"></select> </div>
                              </div>
                              <i class="fas fa-chevron-down dropdown-indicator" style = "margin: auto; margin-right: 1rem;"></i>
                            </div>
                              <div class="dropdown-group" id="marker-dropdown-group">
                                <div style="
              display: flex;
              flex-direction: column;
              gap: 0.3rem;
          ">
                                  <label for="marker-select">MARKER</label>
                                  <div class="custom-dropdown-container">
                                      <div class="custom-dropdown-display" data-target-select="marker-select"></div>
                                      <div class="custom-dropdown-options" id="marker-options"></div>
                                      <select id="marker-select" style="display: none;"></select> </div>
                                </div>
                              <i class="fas fa-chevron-down dropdown-indicator" style = "margin: auto; margin-right: 1rem;"></i>
                            </div>
                          </div>
                          <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 16px;">
              <div class="toggle-group" id="broadcast-entry-toggle-group" style="display:none;">
                  <div style=" flex-direction: column; gap:3px; flex:1; pointer-events: none;">
                  <label for="broadcast-entry-checkbox" style = "font-weight: 400;">Broadcast on entry:</label><span id="broadcast-entry-node-name" style =  "font-weight: 700; font-size: 14px;">nodeName_entry</span></div>
                  <div class="switch">
                      <input type="checkbox" id="broadcast-entry-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
              <div class="toggle-group">
                  <div style=" flex-direction: column; gap:3px; flex:1">
                  <label for="loop-checkbox" style="pointer-events:none; font-size: 12px;">LOOP ANIMATION</label></div>
                  <div class="switch">
                      <input type="checkbox" id="loop-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
              <div class="toggle-group" id="freeze-on-first-frame-toggle-group">
                  <div style="flex-direction: column; gap:3px; flex:1">
                    <label for="freeze-on-first-frame-checkbox" style="font-weight: 400;">Freeze On First Frame</label>
                  </div>
                    <div class="switch">
                        <input type="checkbox" id="freeze-on-first-frame-checkbox">
                        <span class="slider round"></span>
                    </div>
                </div>
              <div class="toggle-group" id="initial-node-toggle-group">
                          <div style="flex-direction: column; gap:3px; flex:1">
                            <label for="initial-node-checkbox" style="font-weight: 400;">Make this initial node</label>
                          </div>
                            <div class="switch">
                                <input type="checkbox" id="initial-node-checkbox">
                                <span class="slider round"></span>
                            </div>
                        </div>

              <div class="toggle-group" id="broadcast-exit-toggle-group"  style="display:none;">
                <div style="flex-direction: column; gap:3px; flex:1">
                  <label for="broadcast-exit-checkbox" style = "font-weight: 400;">Broadcast on exit:</label> <span id="broadcast-exit-node-name" style = "font-weight: 700; font-size: 14px;">nodeName_exit</span></div>
                  <div class="switch">
                      <input type="checkbox" id="broadcast-exit-checkbox">
                      <span class="slider round"></span>
                  </div>
              </div>
          </div>

                          </div>
                          <div class="modal-footer">
                            <button id="delete-node-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                            <button id="save-node-properties" class="save"><i class="fas fa-check"></i></button>
                          </div>
                      </div>
                      </div>
              </div>
      </div>

      <!-- NEW: Container for Action Node Properties -->
    <div id="action-node-properties-container" style="display: none;">
        <!-- The content inside will be laid out vertically by default,
             but we'll ensure it's a flex column for consistency. -->
        <div class="panel-type-indicator" style="
                            margin: 0 auto;
                            margin-bottom: 10px;
                            margin-top: 20px;
                            font-size: 14px;
                            letter-spacing: 1.4px;
                            font-weight: bold;
                            text-transform: uppercase;
                            opacity: 0.5;
                        ">Action Node</div>
        <div class="modal-body" style="padding: 0px 20px;">
            <p class="global-state-description">When this node is reached, it will perform the selected action on the global variable.</p>
            <!-- This section will be populated by JS, reusing the action editor structure -->
            <div id="action-node-editor-content"></div>
        </div>
        <div class="modal-footer" style="justify-content: space-between; padding: 20px 30px 30px 30px; margin-top: auto;">
             <button id="delete-action-node-button" class="delete"><i class="fas fa-trash-alt"></i></button>
             <button id="save-action-node-properties" class="save"><i class="fas fa-check"></i></button>
        </div>
    </div>

    <!-- NEW: Template for the Action Editor (to be cloned) -->
    <template id="action-editor-template">
        <div class="dropdown-group">
            <!-- Dropdown structure will be generated here -->
        </div>
        <div class="dynamic-field-group" style="margin-top: 15px;">
            <!-- Value input will be generated here -->
        </div>
    </template>

    <div id="controls">
      <button id="add-segments-button" title="Crop/Expand Lottie (Add Segments)">
          <i class="fas fa-crop-alt"></i>
        </button>
        <button id="add-node-button" title="Add State"><i class="fas fa-plus"></i></button>
        <button id="add-action-node-button" title="Add Action Node"><i class="fas fa-bolt"></i></button>
        <button id="connect-nodes-button" title="Connect States"><i class="fas fa-link"></i></button>
        <button id="add-animation-json-button" title="Add Lottie Animation from JSON"><i class="fas fa-file-import"></i></button>
        <button id="add-global-state-button" title="Add Global Variable"><i class="fas fa-cogs"></i></button>
        <button id="load-json-button" title="Load State Machine from JSON"><i class="fas fa-upload"></i></button>
        <button id="export-json-button" title="Export State Machine to JSON"><i class="fas fa-download"></i></button>
        <button id="load-lottie-button" title="Load State Machine from .lottie"><i class="fas fa-file-archive"></i></button>
        <button id="export-lottie-button" title="Export State Machine to .lottie"><i class="fas fa-file-export"></i></button> </div>
    </div>
    
    <!-- NEW: Container for Global State Properties (Moved outside #flowchart-area) -->
    <div id="global-state-properties-container" style="display: none;">
        <div class="panel-type-indicator" style="
                            margin: 0 auto;
                            margin-top: 20px;
                            font-size: 14px;
                            letter-spacing: 1.4px;
                            font-weight: bold;
                            text-transform: uppercase;
                            opacity: 0.5;
                        ">Global Node</div>
        <div class="modal-body">
            <p class="global-state-description">A Global Variable can be used to create conditional transitions between states.</p>
            <input type="text" id="global-state-name-input" placeholder="Variable Name" style="margin-bottom: 12px; margin-left: 12px;">
            <div id="global-state-type-dropdown-group" class="dropdown-group" style="margin-top: 15px;">
                <!-- Dropdown structure will be generated by JS -->
            </div>
            <!-- NEW: Container for the initial value controls -->
            <div id="global-state-initial-value-container" class="toggle-group" style="margin-top: 15px; padding: 15px; display: flex; align-items: center;">
                <label for="global-state-value-input" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555;">Starting Value</label>
                <!-- Input for Numeric/String -->
                <input type="text" id="global-state-value-input" placeholder="e.g., 0" style="width: 70px; text-align: center; background: #f0f2f5; border: none; border-radius: 999px; padding: 8px 12px; font-weight: 600; font-size: 14px; color: #333; margin: auto;">
                <!-- Toggle for Boolean -->
                <div class="switch" id="global-state-value-toggle-switch" style="display: none; margin: auto;">
                    <input type="checkbox" id="global-state-value-toggle">
                    <span class="slider round"></span>
                </div>
            </div>

        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="delete-global-state-button" class="delete"><i class="fas fa-trash-alt"></i></button>
            <button id="save-global-state" class="save" title="Save and Close Panel"><i class="fas fa-check"></i></button>
        </div>
    </div>

    <input type="file" id="json-file-input" accept=".json" style="display: none;">
    <input type="file" id="lottie-file-input" accept=".lottie" style="display: none;">
    <input type="file" id="animation-json-file-input" accept=".json" style="display: none;">

    <!-- NEW: Global Animation Dropdown -->
    <div id="global-animation-controls">
        <div class="dropdown-group" style="margin-bottom: 0;">
            <!-- Add animation icon -->
            <i class="fas fa-film" style="color: #555; font-size: 16px;"></i>
            <div style="display: flex; flex-direction: column; gap: 0.3rem; flex: 1;"> <!-- Add flex:1 to take up space -->
                <label for="global-animation-select">GLOBAL ANIMATION</label>
                <div class="custom-dropdown-container">
                    <div class="custom-dropdown-display" id="global-animation-display" data-target-select="global-animation-select"></div>
                    <div class="custom-dropdown-options" id="global-animation-options"></div>
                    <select id="global-animation-select" style="display: none;"></select>
                </div>
            </div>
            <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
        </div>
    </div>


    <div id="flowchart-area">
        <div id="canvas-container">
            <svg id="connection-svg">
                <path id="ghost-connection-line"></path>
                <polygon id="ghost-connection-arrow"></polygon>
            </svg>
        </div>
    </div>

    <span id="connect-mode-indicator" class="mode-indicator">Click first node, then second node.</span>
    <span id="guard-mode-indicator" class="mode-indicator" style="display: none;">Click the Global Variable, then the target State.</span>
    <span id="connection-exists-indicator" class="mode-indicator" style="display: none;">Connection already exists!</span>



    <div id="crop-tool-modal" class="modal">
          <div class="modal-content" style="width: 95%; height: 90%; padding: 10px; flex-direction: column;">
              <div class="modal-header" style="padding-bottom: 5px; margin-bottom: 5px;">
                  <h2>Lottie Segment Editor</h2>
                  <div>
                      <button id="save-crop-changes-button" class="save" title="Save and Apply Changes">
                          <i class="fas fa-save"></i>
                      </button>
                      <span id="close-crop-modal-button" class="close-button" title="Close without saving">&times;</span>
                  </div>
              </div>
              <iframe id="crop-tool-iframe" style="width: 100%; height: 100%; border: none;"></iframe>
          </div>
      </div>

    <!-- NEW: Modal for the Click Area Editor -->
    <div id="click-area-modal" class="modal" style="z-index: 1003;">
        <div class="modal-content" style="width: 95%; height: 75%; max-height: 900px; padding: 10px; flex-direction: column;">
            <div class="modal-header" style="padding-bottom: 5px; margin-bottom: 5px;">
                <h2>Click Area Editor</h2>
                <div>
                    <button id="save-click-area-button" class="save" title="Save Click Area" style="width: auto; height: 40px; font-size: 16px; margin-right: 15px; box-shadow: none; border-radius: 999px; padding: 0 20px; background-color: #28a745; border: none; color:white;" onmouseover="this.style.backgroundColor='#218838'" onmouseout="this.style.backgroundColor='#28a745'">
                        <i class="fas fa-check" style="margin-right: 8px;"></i> Save
                    </button>
                    <span id="close-click-area-modal-button" class="close-button" title="Close" style="position: relative; top: -2px;">&times;</span>
                </div>
            </div>
            <iframe id="click-area-iframe" style="width: 100%; border: none; flex: 1;"></iframe>
        </div>
    </div>

    <div id="connection-editor-modal" class="connection-editor-modal">
        <div class="connection-editor-content">
            <div class="modal-header">
                <h2 id="connection-modal-title">Transition Settings</h2>
                <span class="close-button">&times;</span>
            </div>
            <div class="modal-body">
                <div class="dropdown-group" id="transition-type-dropdown-group">
                    <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                        <label for="transition-type-select">TRANSITION TYPE</label>
                        <div class="custom-dropdown-container">
                            <div class="custom-dropdown-display" data-target-select="transition-type-select"></div>
                            <div class="custom-dropdown-options" id="transition-type-options"></div>
                            <select id="transition-type-select" style="display: none;"></select> </div>
                    </div>
                    <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i> </div>

                <div class="dropdown-group" id="interaction-preset-dropdown-group">
                    <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                        <label for="interaction-preset-select">TRIGGER INTERACTION</label>
                        <div class="custom-dropdown-container">
                            <div class="custom-dropdown-display" data-target-select="interaction-preset-select"></div>
                            <div class="custom-dropdown-options" id="interaction-preset-options"></div>
                            <select id="interaction-preset-select" style="display: none;"></select>
                        </div>
                    </div>
                    <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
                </div>

                <div id="dynamic-interaction-fields">
                    <div class="dynamic-field-group" id="loop-count-field" style="display: none;">
                        <label for="loop-count-input">Number of Loops:</label>
                        <input type="number" id="loop-count-input" min="1" value="1">
                    </div>
                    <div class="dynamic-field-group" id="layer-name-field" style="display: none;">
                        <!-- <input type="text" id="layer-name-input" readonly> -->
                        <button id="edit-click-area-button" class="full-width-pill-button">Change Target Area</button>
                    </div>
                    <div class="dynamic-field-group" id="custom-event-name-field" style="display: none;">
                        <label for="custom-event-name-input">Custom Event Name:</label>
                        <input type="text" id="custom-event-name-input" placeholder="e.g., user_action_event">
                    </div>
                    <!-- NEW: Tweened Transition Fields -->
                    <div class="dynamic-field-group" id="tweened-duration-field" style="display: none;">
                        <label for="tweened-duration-input">Duration (seconds):</label>
                        <input type="number" id="tweened-duration-input" min="0" step="0.1" value="0.5">
                    </div>
                    <div class="dynamic-field-group" id="tweened-easing-field" style="display: none;">
                        <label for="tweened-easing-input">Easing (Cubic Bezier):</label>
                        <input type="text" id="tweened-easing-input" placeholder="e.g., 0.42, 0, 0.58, 1">
                    </div>
                </div>

                <!-- NEW: Actions Section -->
                <div id="actions-section" style="display: none; margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee;">
                    <h3 style="margin-top: 0; margin-left: 12px; font-size: 16px; color: #333;">ACTIONS</h3>
                    <div class="dropdown-group" id="action-type-dropdown-group">
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <label for="action-type-select">ACTION ON TRANSITION</label>
                            <div class="custom-dropdown-container">
                                <div class="custom-dropdown-display" data-target-select="action-type-select"></div>
                                <div class="custom-dropdown-options" id="action-type-options"></div>
                                <select id="action-type-select" style="display: none;"></select>
                            </div>
                        </div>
                        <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
                    </div>
                    <div id="dynamic-action-fields" style="margin-top: 15px;">
                        <div class="dynamic-field-group" id="action-value-field" style="display: none;">
                            <label for="action-value-input">Value:</label>
                            <input type="text" id="action-value-input" placeholder="e.g., 10 or true">
                        </div>
                    </div>
                </div>

            </div>
            <div class="modal-footer">
                <button id="delete-connection-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                <div>
                    <button id="save-connection-editor" class="save"><i class="fas fa-check"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Guard Condition Editor Modal -->
    <div id="guard-condition-modal" class="connection-editor-modal">
        <div class="connection-editor-content">
            <div class="modal-header">
                <h2>Condition Settings</h2>
                <span class="close-button">&times;</span>
            </div>

            <div class="modal-body">
                <div class="combined-input-group">
                    <div class="dropdown-group" id="guard-condition-type-dropdown-group" style="flex: 3.5; margin-bottom: 0; border: none; background: transparent;">
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <label for="guard-condition-type-select" id="guard-condition-label" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">CONDITION</label>
                            <div class="custom-dropdown-container">
                                <div class="custom-dropdown-display" data-target-select="guard-condition-type-select"></div>
                                <div class="custom-dropdown-options" id="guard-condition-type-options"></div>
                                <select id="guard-condition-type-select" style="display: none;"></select>
                            </div>
                        </div>
                        <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto 1rem auto auto;"></i>
                    </div>
                    <div class="combined-input-separator"></div>
                    <input type="text" id="guard-value-input" placeholder="Value" style="text-align: center; flex: 1; border: none; background: transparent; padding: 10px 16px; font-size: 16px; margin: 0; border-radius: 0;">
                </div>
            </div>
            <!-- Transition Type Dropdown for Guards (Moved) -->
            <div class="dropdown-group" id="guard-transition-type-dropdown-group" style="margin-top: 15px;">
                <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                    <label for="guard-transition-type-select" style="font-weight: bold; font-size: 12px; text-transform: uppercase; color: #555; letter-spacing: 1px;">TRANSITION TYPE</label>
                    <div class="custom-dropdown-container">
                        <div class="custom-dropdown-display" data-target-select="guard-transition-type-select"></div>
                        <div class="custom-dropdown-options" id="guard-transition-type-options"></div>
                        <select id="guard-transition-type-select" style="display: none;"></select>
                    </div>
                </div>
                <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>
            </div>
            <div id="guard-dynamic-fields" style="margin-top: 15px;">
                <!-- Tweened fields will be dynamically added here by JS -->
            </div>
            <div class="modal-footer">
                <button id="delete-guard-connection-button" class="delete"><i class="fas fa-trash-alt"></i></button>
                <button id="save-guard-condition" class="save"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div id="custom-alert-overlay" class="custom-alert-overlay">
        <div class="custom-alert-box">
            <p id="custom-alert-message"></p>
            <button id="custom-alert-ok-button">OK</button>
        </div>
    </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // --- State Machine Converter Library ---
        // This code is now embedded directly in the HTML to prevent loading errors.
        
        // -- SECTION 1: EXPORT LOGIC (UI Data -> New JSON Schema) --
        
        /**
         * A collection of helper functions to ensure Inputs and Interactions exist, preventing duplicates.
         */
         const ensure = {
             eventInputExists: (eventName, globalInputs) => {
                if (!globalInputs.some(input => input.name === eventName)) {
                    globalInputs.push({ type: 'Event', name: eventName });
                }
             },
             interactionExists: (type, eventName, details, actions, globalInteractions) => {
                // NEW: Check for actions as well for uniqueness
                const actionsString = JSON.stringify(actions.sort((a, b) => a.type.localeCompare(b.type)));

                 const interactionExists = globalInteractions.some(i =>
                     i.type === type &&
                     // Check if at least one action is a 'Fire' action with the correct eventName
                     i.actions?.some(a => a.type === 'Fire' && a.inputName === eventName) &&
                     (details.layerName === undefined || i.layerName === details.layerName) &&
                     (details.stateName === undefined || i.stateName === details.stateName) &&
                     // Compare actions
                     JSON.stringify(i.actions.sort((a, b) => a.type.localeCompare(b.type))) === actionsString
                 );

                 if (!interactionExists) {
                     globalInteractions.push({
                         type: type,
                         ...details,
                         actions: actions
                     });
                 }
             }
         };
        
         /**
          * Builds the array of Guards for a given transition based on the UI's simple trigger.
          */
         function buildGuardsForTransition(connection, globalInputs, globalInteractions, nodeIdToNameMap, globalState, nodes) {
             const fromStateName = nodeIdToNameMap.get(connection.fromNodeId);
             const interactionType = connection.interactionType; // e.g., 'onClick'
             let eventName, interactionSchemaType, details;
        
             switch (interactionType) {
                 // --- NEW: Granular layer naming for each pointer event ---
                 case 'onPointerEnter':
                 case 'onPointerExit':
                 case 'onPointerDown':
                 case 'onPointerUp':
                 case 'onPointerMove':
                 case 'onClick':
                     const toStateName = nodeIdToNameMap.get(connection.toNodeId);
                     const interactionName = interactionType.replace('on', '').toLowerCase(); // e.g., 'click', 'pointerenter'
                     const layerName = `${fromStateName}_${interactionName}_to_${toStateName}`;

                     interactionSchemaType = interactionType === 'onClick' ? 'Click' : interactionType.charAt(2).toUpperCase() + interactionType.slice(3);
                     details = { layerName: layerName };
                     eventName = `${interactionType}_${layerName}_Event`;
                     break;
                 case 'onComplete':
                    interactionSchemaType = 'OnComplete';
                    details = { stateName: fromStateName };
                    eventName = `${interactionType}_${fromStateName}_Event`;
                    break;
                 case 'onLoopComplete':
                     // This is the key change: A UI "onLoopComplete" with a loop count becomes an "OnComplete" interaction in the schema.
                     // The loop count itself is a property of the state, not the interaction.
                     interactionSchemaType = 'OnComplete';
                     details = { stateName: fromStateName };
                     eventName = `${interactionType}_${fromStateName}_Event`;

                     // --- NEW: Handle connections to Action Nodes ---
                     const toNode = nodes.find(n => n.id === connection.toNodeId);
                     if (toNode && toNode.type === 'action') {
                         // This is a fire-and-forget action, no state transition.
                         eventName = null; // Explicitly nullify eventName
                     }
                     break;
                     // --- END NEW ---
        
                 default:
                     return []; // No recognized interaction
             }
        
             // NEW: Build actions array
             const actions = [];
             if (eventName) {
                actions.push({ type: 'Fire', inputName: eventName });
             }

             if (connection.action && globalState) {
                 const action = connection.action;
                 let actionObject = { type: action.type, inputName: globalState.name };
                 if (action.hasOwnProperty('value')) {
                     // Convert value based on global state type
                     if (globalState.type === 'Numeric') {
                         actionObject.value = parseFloat(action.value) || 0;
                     } else if (globalState.type === 'Boolean') {
                         actionObject.value = (action.value === 'true' || action.value === true);
                     } else {
                         actionObject.value = action.value;
                     }
                 }
                 actions.push(actionObject);
             }


             // --- MODIFIED: Only create event-related objects if there's an eventName ---
             if (eventName) {
                 ensure.eventInputExists(eventName, globalInputs);
             }
             // The interaction will be created with or without a FireAction
             ensure.interactionExists(interactionSchemaType, eventName, details, actions, globalInteractions);
        
             // Return the guard that listens for our unique event
             return [{ type: 'Event', inputName: eventName }];
         }
        
        /**
         * EXPORT FUNCTION: Converts UI data into the new, advanced state machine JSON.
         */
function convertNodesAndConnectionsToJson(nodes, connections, initialNodeName, globalState, guardConnections, availableAnimations) {
            const nodeIdToNameMap = new Map(nodes.map(node => [node.id, node.name]));
            const globalInputs = [];
            const globalInteractions = [];
        
            // 1. Create the main Input from the globalState node
            if (globalState) {
                globalInputs.push({
                    type: globalState.type,
                    name: globalState.name,
                    // Convert initialValue to the correct type for JSON
                    value: globalState.type === 'Numeric' 
                        ? parseFloat(globalState.initialValue) || 0
                        : globalState.type === 'Boolean'
                        ? (globalState.initialValue === 'true' || globalState.initialValue === true)
                        : globalState.initialValue,
                });
            }

            const statesArray = nodes.filter(node => node.type !== 'action').map(node => {

                const isLoopANumber = typeof node.loop === 'number' && node.loop > 0;
                const transitionsForThisNode = connections.filter(c => c.fromNodeId === node.id);
                return {
                    name: node.name,
                    type: "PlaybackState",
                    animation: node.animationId,
                    // Schema Compliance: 'loop' is boolean, 'loopCount' is a separate number.
                    loop: node.loop === true || isLoopANumber,
                    // FIX: Ensure loopCount is added if node.loop is a number.
                    ...(isLoopANumber && { loopCount: node.loop }),
                    speed: node.speed,
                    designer: { // Custom property for editor layout
                        x: node.x,
                        y: node.y
                    },
                    segment: node.marker || undefined,
                    autoplay: node.autoplay,
                    transitions: transitionsForThisNode.map(conn => {
                        // Regular transitions from normal states no longer check for global guards
                        const guards = buildGuardsForTransition(conn, globalInputs, globalInteractions, nodeIdToNameMap, globalState, nodes);
                        const toNode = nodes.find(n => n.id === conn.toNodeId);
                        if (toNode && toNode.type === 'action') {
                            return null; // This connection does not result in a transition object.
                        }

                        // NEW: Handle Tweened Transitions
                        if (conn.transitionType === 'Tweened') {
                            return {
                                type: "Tweened",
                                toState: nodeIdToNameMap.get(conn.toNodeId),
                                duration: conn.duration || 0.5, // Default duration
                                easing: conn.easing || [0.42, 0, 0.58, 1], // Default ease-in-out
                                guards: guards
                            };
                        }
                        return { type: "Transition", toState: nodeIdToNameMap.get(conn.toNodeId), guards: guards };
                    }).filter(t => t !== null),
                    entryActions: [],
                    exitActions: [],
                };
            });

            // Conditionally add the GlobalState object to the statesArray
            if (globalState) {
                statesArray.push({
                    name: globalState.name, // The state is named after the variable for clarity
                    type: "GlobalState",
                    designer: { // Custom property for editor layout
                        x: globalState.x,
                        y: globalState.y
                    },
                    transitions: guardConnections.map(gc => {
                        // --- FIX: Convert compareTo value to the correct type ---
                        let compareToValue = gc.value;
                        if (globalState.type === 'Numeric') {
                            compareToValue = parseFloat(gc.value) || 0;
                        } else if (globalState.type === 'Boolean') {
                            compareToValue = (gc.value === 'true' || gc.value === true);
                        }
                        // --- END FIX ---

                        const guard = {
                                type: globalState.type,
                                inputName: globalState.name,
                                conditionType: gc.condition,
                                compareTo: compareToValue, // Use the correctly typed value
                            };
                        if (gc.transitionType === 'Tweened') {
                            return {
                                type: "Tweened",
                                toState: nodeIdToNameMap.get(gc.toNodeId),
                                duration: gc.duration || 0.5,
                                easing: gc.easing || [0.42, 0, 0.58, 1],
                                guards: [guard]
                            };
                        }
                        return { type: "Transition", toState: nodeIdToNameMap.get(gc.toNodeId), guards: [guard] };
                    })
                });
            }

            return {
                initial: initialNodeName,
                inputs: globalInputs,
                states: statesArray,
                interactions: globalInteractions,
            };
        }
        
        
        // -- SECTION 2: IMPORT LOGIC (New JSON Schema -> UI Data) --
        
        /**
         * IMPORT FUNCTION: Converts an advanced state machine JSON into the UI's simple data format.
         */
        function convertJsonToNodesAndConnections(jsonStateMachine, availableAnimations) {
            if (!jsonStateMachine.states) return { nodes: [], connections: [], initialNodeId: null, globalState: null, guardConnections: [] };
        
            const nodes = [];
            const connections = [];
            const stateNameToIdMap = new Map();
            let globalState = null;
            const guardConnections = [];

            const mainInput = jsonStateMachine.inputs?.find(i => i.type === 'Numeric' || i.type === 'String' || i.type === 'Boolean');
        
            // Step 1: Create all nodes
            jsonStateMachine.states.forEach((state, index) => {
                // Skip creating UI nodes for GlobalState objects from the JSON
                if (state.type === 'GlobalState') return;

                const nodeId = `id_${Math.random().toString(36).substr(2, 9)}`;
                stateNameToIdMap.set(state.name, nodeId);
                
                // Check for custom layout data
                const hasDesignerData = state.designer && typeof state.designer.x === 'number' && typeof state.designer.y === 'number';

                nodes.push({
                    id: nodeId,
                    name: state.name,
                    // Use designer data if it exists, otherwise fall back to grid
                    x: hasDesignerData ? state.designer.x : (50 + (index % 4) * 250),
                    y: hasDesignerData ? state.designer.y : (50 + Math.floor(index / 4) * 150),
                    animationId: state.animation,
                    marker: state.segment || "",
                    loop: state.loop || false,
                    speed: state.speed || 1.0,
                    autoplay: state.autoplay !== false,
                    isActive: state.name === jsonStateMachine.initial,
                });
            });
        
            // Step 2: Create Global State Node from main input
            if (mainInput) {
                // Find the corresponding GlobalState object to get designer data
                const globalStateFromStates = jsonStateMachine.states.find(s => s.type === 'GlobalState' && s.name === mainInput.name);
                const hasDesignerData = globalStateFromStates && globalStateFromStates.designer;

                globalState = {
                    id: 'global_state_node',
                    name: mainInput.name,
                    type: mainInput.type,
                    initialValue: mainInput.value,
                    // Use designer data if it exists, otherwise fall back to a default top position
                    x: hasDesignerData ? globalStateFromStates.designer.x : 50,
                    y: hasDesignerData ? globalStateFromStates.designer.y : 50,
                };
            }

            // Step 3: Reverse-engineer connections and guard connections
            jsonStateMachine.states.forEach(state => {
                const fromNodeId = stateNameToIdMap.get(state.name);
                if (!state.transitions) return;
        
                state.transitions.forEach(transition => {
                    const eventGuard = transition.guards?.find(g => g.type === 'Event');
                    const conditionalGuard = mainInput ? transition.guards?.find(g => g.inputName === mainInput.name) : null;
                    const toNodeId = stateNameToIdMap.get(transition.toState);

                    // Create Guard Connection if a conditional guard exists for this transition's target
                    if (conditionalGuard && toNodeId && !guardConnections.some(gc => gc.toNodeId === toNodeId)) {
                        guardConnections.push({
                            id: `guard_${Math.random().toString(36).substr(2, 9)}`,
                            fromNodeId: 'global_state_node',
                            toNodeId: toNodeId,
                            condition: conditionalGuard.conditionType,
                            value: conditionalGuard.compareTo,
                            // NEW: Import tweening properties for guard connections
                            transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                            duration: transition.duration,
                            easing: transition.easing,
                        });
                    }

                    // Continue with regular connection logic
                    if (!eventGuard) return;

                    const triggeringInteraction = jsonStateMachine.interactions?.find(
                        i => i.actions?.some(a => a.type === 'Fire' && a.inputName === eventGuard.inputName)
                    );
                    if (!triggeringInteraction) return;
        
                    if (!fromNodeId || !toNodeId) return; // toNodeId is already declared above

                    // Find the action that modifies the global state, if any
                    const stateChangeAction = mainInput ? triggeringInteraction.actions?.find(a => a.inputName === mainInput.name && a.type !== 'Fire') : null;

                    // --- FIX: Correctly map schema interaction types to UI interaction IDs ---
                    let interactionType;
                    const schemaType = triggeringInteraction.type; // e.g., "Click", "OnComplete"

                    if (schemaType.startsWith('On')) {
                        // Handles "OnComplete", "OnLoopComplete"
                        interactionType = 'on' + schemaType.substring(2);
                    } else {
                        // Handles "Click", "PointerEnter", etc.
                        interactionType = 'on' + schemaType;
                    }
                    // --- END FIX ---


                    let actionForConnection = null;
                    if (stateChangeAction) {
                        actionForConnection = {
                            type: stateChangeAction.type,
                            value: stateChangeAction.value,
                        };
                    }

                    connections.push({
                        id: `conn_${Math.random().toString(36).substr(2, 9)}`,
                        fromNodeId: fromNodeId,
                        toNodeId: toNodeId,
                        fromPortType: 'right',
                        toPortType: 'left',
                        interactionType: interactionType,
                        interactionDetails: { layerName: triggeringInteraction.layerName || '' },
                        // NEW: Add properties for tweened transitions from JSON
                        transitionType: transition.type === 'Tweened' ? 'Tweened' : 'Transition',
                        duration: transition.duration,
                        easing: transition.easing,
                        // ---
                        forceCShape: false,
                        action: actionForConnection, // Add the action
                    });
                });
            });
        
            // --- NEW: Step 4: Handle Action-Only Interactions by creating Blank Nodes ---
            if (jsonStateMachine.interactions) {
                let blankNodeCounter = 0;
                const existingBlankNodes = {}; // To reuse blank nodes

                jsonStateMachine.interactions.forEach(interaction => {
                    const hasFireAction = interaction.actions?.some(a => a.type === 'Fire');
                    const variableAction = interaction.actions?.find(a => a.type !== 'Fire' && a.inputName === mainInput?.name);

                    if (!hasFireAction && variableAction) {
                        // This is an action-only interaction. It needs a blank node.
                        let sourceNodeId = null;
                        let interactionType = interaction.type.charAt(0).toLowerCase() + interaction.type.slice(1);

                        if (interaction.type === 'OnComplete' || interaction.type === 'OnLoopComplete') {
                            sourceNodeId = stateNameToIdMap.get(interaction.stateName);
                            if(interaction.type === 'OnComplete') interactionType = 'onComplete';
                        } else {
                            // For global interactions like 'Click', we can't determine a single source from the JSON.
                            // This logic assumes such actions are tied to a state in the UI, which is a limitation of the import.
                            // For now, we'll skip creating blank nodes for ambiguous global interactions.
                            console.warn(`Skipping blank node creation for ambiguous global interaction: ${interaction.type}`);
                            return;
                        }

                        if (sourceNodeId) {
                            // Create or reuse a blank node
                            let blankNodeId = `action_node_${blankNodeCounter}`;
                            if (!existingBlankNodes[blankNodeId]) {
                                const newBlankNode = { id: blankNodeId, type: 'action', x: 50 + (blankNodeCounter * 150), y: 400 };
                                nodes.push(newBlankNode);
                                existingBlankNodes[blankNodeId] = newBlankNode;
                                blankNodeCounter++;
                            }

                            // Create the connection to the blank node
                            connections.push({
                                id: `conn_${Math.random().toString(36).substr(2, 9)}`,
                                fromNodeId: sourceNodeId,
                                toNodeId: blankNodeId,
                                fromPortType: 'right', toPortType: 'left',
                                interactionType: interactionType,
                                interactionDetails: { loopCount: interaction.loopCount, layerName: interaction.layerName },
                                action: { type: variableAction.type, value: variableAction.value }
                            });
                        }
                    }
                });
            }

            const initialNode = nodes.find(n => n.name === jsonStateMachine.initial);
        
            return {
                nodes: nodes,
                connections: connections,
                initialNodeId: initialNode ? initialNode.id : null,
                globalState: globalState,
                guardConnections: guardConnections,
            };
        }
        
        
        // -- SECTION 3: HELPER FUNCTIONS --
        
        /**
         * Helper function for parsing "Frame A to B" strings.
         */
        function generateFrameRangeMarker(markerString, existingMarkers) {
            const frameRangeMatch = markerString.match(/^Frame (\d+) to (\d+)$/);
            if (frameRangeMatch) {
                const frameStart = parseInt(frameRangeMatch[1], 10);
                const frameEnd = parseInt(frameRangeMatch[2], 10);
                const exists = existingMarkers.some(m => m.name === markerString);
                if (!exists) {
                    return { name: markerString, start: frameStart, end: frameEnd };
                }
            }
            return null;
        }

        /**
         * IMPORT HELPER: Extracts "10-20" style segments from a state machine JSON
         * and structures them for the animation library.
         */
        function extractFrameRangeMarkersFromJson(jsonStateMachine) {
            const animationMarkersMap = new Map();

            if (!jsonStateMachine || !jsonStateMachine.states) {
                return [];
            }

            jsonStateMachine.states.forEach(state => {
                const animId = state.animation;
                const segmentName = state.segment;

                if (animId && segmentName && /^\d+-\d+$/.test(segmentName)) {
                    const parts = segmentName.split('-');
                    const startFrame = parseInt(parts[0], 10);
                    const endFrame = parseInt(parts[1], 10);

                    if (!isNaN(startFrame) && !isNaN(endFrame)) {
                        if (!animationMarkersMap.has(animId)) {
                            animationMarkersMap.set(animId, {
                                id: animId,
                                name: animId,
                                markers: []
                            });
                        }
                        const animData = animationMarkersMap.get(animId);
                        if (!animData.markers.some(m => m.name === segmentName)) {
                            animData.markers.push({
                                name: segmentName,
                                start: startFrame,
                                end: endFrame
                            });
                        }
                    }
                }
            });

            return Array.from(animationMarkersMap.values());
        }
    </script>
    <script type="module">
import { DotLottie } from "https://esm.sh/@lottiefiles/dotlottie-web";



// --- Logic for Crop Tool Iframe (Now inside the main script) ---

// Get DOM elements
const addSegmentsButton = document.getElementById('add-segments-button');
const cropToolModal = document.getElementById('crop-tool-modal');
const cropToolIframe = document.getElementById('crop-tool-iframe');
const saveCropChangesButton = document.getElementById('save-crop-changes-button');
const closeCropModalButton = document.getElementById('close-crop-modal-button');

// --- NEW: Logic for Click Area Editor Iframe ---
const clickAreaModal = document.getElementById('click-area-modal');
const clickAreaIframe = document.getElementById('click-area-iframe');
const closeClickAreaModalButton = document.getElementById('close-click-area-modal-button');

// Listener to open the modal
addSegmentsButton.addEventListener('click', () => {
    // Find the active node and its animation data
    // No "window." needed here as we are in the same script scope
    const activeNode = nodes.find(n => n.isActive);
    if (!activeNode || !activeNode.animationId) {
        alert("Please select a node with an assigned animation first.");
        return;
    }

    const animationData = availableAnimations.find(anim => anim.id === activeNode.animationId);
    if (!animationData || !animationData.jsonContent) {
        alert("Could not find the JSON data for the selected animation.");
        return;
    }

    // Show the modal and set the iframe source
    cropToolModal.style.display = 'flex';
    cropToolIframe.src = 'overlay.html';

    // Wait for the iframe to load before sending data
    cropToolIframe.onload = () => {
        cropToolIframe.contentWindow.postMessage({
            type: 'lottieData',
            data: JSON.parse(animationData.jsonContent),
            filename: `${animationData.id}.json`
        }, '*');
    };
});

// Listener for the remote "Save" button
saveCropChangesButton.addEventListener('click', () => {
    cropToolIframe.contentWindow.postMessage({
        type: 'triggerSaveAndCloseCrop'
    }, '*');
});

// Listener to receive data back from the iframe
window.addEventListener('message', (event) => {
    // --- NEW: Handle message from the main application ---
    if (event.data && event.data.type === 'lottieData') {
        console.log('Received Lottie data from main app:', event.data.filename);
        const { data, filename } = event.data;
        const animationId = filename.replace(/\.json$/i, '').replace(/[^a-z0-9]/gi, '_');
        const newAnimation = {
            id: animationId,
            name: animationId,
            markers: extractMarkersFromLogic(JSON.stringify(data)).markers,
            jsonContent: JSON.stringify(data),
            clickLayers: new Set()
        };
        availableAnimations = [newAnimation];
        setGlobalAnimation(newAnimation.id, false); // Set as global without alert
    }
    // --- NEW: Handle message from the Click Area tool ---
    if (event.data && event.data.type === 'clickAreaDataFromMarkerTool') {
        const { modifiedAnimationData, originalAnimationId } = event.data;
        handleUpdatedAnimationData(modifiedAnimationData, originalAnimationId);
        clickAreaModal.style.display = 'none'; // Close the modal on success
    }

    // --- NEW: Handle message from the Click Area tool's "Cancel" button ---
    if (event.data && event.data.type === 'closeClickAreaTool') {
        clickAreaModal.style.display = 'none';
    }
    // --- END NEW ---

    if (event.data && (event.data.type === 'dataFromCropTool' || event.data.type === 'dataFromTrimTool')) {
        const receivedData = event.data;
        console.log('Received updated Lottie data:', receivedData);

        const animationToUpdate = availableAnimations.find(
            anim => `${anim.id}.json` === receivedData.originalFilename
        );
        handleUpdatedAnimationData(receivedData.lottieData, animationToUpdate.id);
        
        cropToolModal.style.display = 'none';
    }

    // --- NEW: Handle message from the overlay's close button ---
    if (event.data && event.data.type === 'closeTrimTool') {
        cropToolModal.style.display = 'none';
    }
});

// --- NEW: Centralized function to handle updated animation data from any tool ---
function handleUpdatedAnimationData(lottieData, animationId) {
    const animationToUpdate = availableAnimations.find(anim => anim.id === animationId);

    if (animationToUpdate) {
        // 1. Update the raw JSON content
        animationToUpdate.jsonContent = JSON.stringify(lottieData);

        // 2. Re-parse and update the markers array
        if (lottieData.markers && Array.isArray(lottieData.markers)) {
            // Convert Lottie marker format {cm, tm, dr} to our internal format {name, start, end}
            animationToUpdate.markers = lottieData.markers.map(marker => ({
                name: marker.cm,
                start: marker.tm,
                end: marker.tm + marker.dr
            }));
        } else {
            animationToUpdate.markers = []; // Clear markers if none exist
        }

        // 3. Refresh the UI if the node properties modal is open for the affected animation
        if (selectedNodeForEdit && selectedNodeForEdit.animationId === animationToUpdate.id) {
            populateAnimationAndMarkerDropdowns(selectedNodeForEdit.animationId, selectedNodeForEdit.marker);
            // Refresh the preview player using a callback to ensure actions happen after loading.
            modalDotLottiePlayer.load(
                { data: lottieData, loop: true },
                () => { // This is the onComplete callback
                    // After loading, play the correct segment for the node being edited.
                    const markerName = selectedNodeForEdit.marker;
                    const marker = animationToUpdate.markers.find(m => m.name === markerName);
    
                    if (marker) {
                        modalDotLottiePlayer.setSegment(marker.start, marker.end);
                    }
                    // Always call play, which will respect the segment if set.
                    modalDotLottiePlayer.setLoop(true);
                    modalDotLottiePlayer.play();
                    
                }
            );
            
        }

        // --- NEW: If the properties panel is open, refresh it to reflect the new data ---
        if (selectedNodeForEdit && selectedNodeForEdit.animationId === animationToUpdate.id) {
            console.log("[LOG] Re-opening node properties to refresh player with updated animation data.");
            openNodePropertiesModal(selectedNodeForEdit);
        }

        alert(`Animation data for "${animationToUpdate.name}" has been updated.`);
    } else {
        console.error(`Could not find animation with ID "${animationId}" to update.`);
    }
}

// Listener to close the modal
closeCropModalButton.addEventListener('click', () => {
    cropToolModal.style.display = 'none';
});

// --- NEW: Listener to close the click area modal ---
closeClickAreaModalButton.addEventListener('click', () => {
    clickAreaModal.style.display = 'none';
});

const modalLottieCanvas = document.getElementById('modal-lottie-canvas');
let modalDotLottiePlayer;

let currentLoadedLottieSrc = '';
const initialNodeCheckbox = document.getElementById('initial-node-checkbox');
const initialNodeToggleGroup = document.getElementById('initial-node-toggle-group');


const freezeOnFirstFrameCheckbox = document.getElementById('freeze-on-first-frame-checkbox'); // NEW
        const freezeOnFirstFrameToggleGroup = document.getElementById('freeze-on-first-frame-toggle-group'); // NEW
    // --- DOM Elements (add these with your other DOM variable declarations) ---
        const statePreviewWindow = document.getElementById('state-preview-window');
        const previewToggleButton = document.getElementById('preview-toggle-button');
        const previewToggleIcon = previewToggleButton.querySelector('i'); // Get the icon within the button

        // --- Event Listener (add this inside window.addEventListener('load', ...) ) ---
        previewToggleButton.addEventListener('click', () => {
            statePreviewWindow.classList.toggle('hidden');
            // The icon rotation is handled purely by CSS now based on the 'hidden' class
        });

        // Initially hide the window (optional, depends on desired default state)
        // statePreviewWindow.classList.add('hidden');



        // --- Constants ---
        const NODE_WIDTH = 180;
        const NODE_HEIGHT = 100;
        const MINIMAL_CANVAS_EDGE_PADDING = 260; // Increased padding
        const DEFAULT_MIN_CANVAS_WIDTH = 300;
        const DEFAULT_MIN_CANVAS_HEIGHT = 200;
        const PORT_SIZE = 16; /* Increased size */
        const PORT_OFFSET = 10; /* Adjusted offset based on new PORT_SIZE */
        const ROUTING_STUB = 45;
        const ARROW_Y_OFFSET = 0;
        const ConnectionPortOffset = 12;
        const ConnectionLineLengthPercentage = 99;
        const ConnectionCornerRadius = 32;
        const ConnectionTextPositionPercentage = 54;

        // --- NEW: Global variable to control the node hover area size ---
        let globalAnimationId = ''; // NEW: To store the ID of the single animation for the whole machine
        const NODE_HOVER_AREA_PERCENTAGE = 14; // The percentage to expand the hover area by

        // --- Data Models ---
        let nodes = [];
        let connections = [];
        // NEW: Data models for new features
        let globalState = null; // { id, name, type, initialValue, x, y }
        let guardConnections = []; // { id, fromNodeId, toNodeId, condition, value }
        let selectedGuardConnectionForEdit = null;

        let selectedNodeForEdit = null;
        let selectedConnectionForEdit = null;
        let tempConnectionData = null; // NEW: For editing in the modal without modifying the original
        let currentHoveredDestinationNode = null; // Track the node currently highlighted as a potential destination

        let availableAnimations = [
            { id: 'animation_1', name: 'Main App Flow', markers: [{ name: 'intro_segment', start: 0, end: 50 }, { name: 'idle_loop', start: 51, end: 150 }, { name: 'success_burst', start: 151, end: 200 }, { name: 'error_shake', start: 201, end: 250 }], jsonContent: null, clickLayers: new Set() },
            { id: 'animation_2', name: 'pigeon', markers: [{ name: 'spin_loop', start: 0, end: 60 }, { name: 'fade_out', start: 61, end: 80 }], jsonContent: null, clickLayers: new Set() },
            { id: 'toggle', name: 'toggle', markers: [{ name: 'default_state', start: 0, end: 1 }, { name: 'hover_in', start: 1, end: 15 }, { name: 'hover_out', start: 15, end: 1 }], jsonContent: null, clickLayers: new Set() }
        ];

        const TRANSITION_TYPES = [
            { id: 'Transition', name: 'Transition' },
            { id: 'Tweened', name: 'Tweened' }
        ];

      const INTERACTION_PRESETS = [
    { id: 'onComplete', name: 'On Complete' },
    { id: 'onLoopComplete', name: 'On Loop Complete' },
    { id: 'onClick', name: 'Click' },
    { id: 'onPointerEnter', name: 'Hover On (Pointer Enter)', shortName: 'hover on' },
    { id: 'onPointerExit', name: 'Hover Off (Pointer Exit)', shortName: 'hover off' },
    { id: 'onPointerDown', name: 'Pointer Down' },
    { id: 'onPointerUp', name: 'Pointer Up' },
    { id: 'onPointerMove', name: 'Pointer Move' }
];;


        // --- DOM Elements ---

        const loadLottieButton = document.getElementById('load-lottie-button');
        const lottieFileInput = document.getElementById('lottie-file-input');



        const flowchartArea = document.getElementById('flowchart-area');
        const canvasContainer = document.getElementById('canvas-container');
        const addNodeButton = document.getElementById('add-node-button');
        const addActionNodeButton = document.getElementById('add-action-node-button'); // NEW
        const connectNodesButton = document.getElementById('connect-nodes-button');
        const loadJsonButton = document.getElementById('load-json-button'); // New
        // NEW: Button and input for single animation JSON upload
        const addAnimationJsonButton = document.getElementById('add-animation-json-button');
        const animationJsonFileInput = document.getElementById('animation-json-file-input');
        const exportJsonButton = document.getElementById('export-json-button'); // New
        const addGlobalStateButton = document.getElementById('add-global-state-button'); // NEW
        const addGuardButton = document.getElementById('add-guard-button'); // NEW
        const jsonFileInput = document.getElementById('json-file-input'); // New

        const connectModeIndicator = document.getElementById('connect-mode-indicator');
        const guardModeIndicator = document.getElementById('guard-mode-indicator'); // NEW
        const connectionExistsIndicator = document.getElementById('connection-exists-indicator'); // New element
        const connectionSvg = document.getElementById('connection-svg');
        const nodePropertiesModal = document.getElementById('node-properties-modal');
        

        const nodeNameInput = document.getElementById('node-name');
        const loopCheckbox = document.getElementById('loop-checkbox');
        const speedSlider = document.getElementById('speed-slider');
        const speedValueSpan = document.getElementById('speed-value');
        const saveNodePropertiesButton = document.getElementById('save-node-properties');

        const deleteNodeButton = document.getElementById('delete-node-button');
        const closeNodeModalButtons = nodePropertiesModal.querySelectorAll('.close-button');

        // NEW: Action Node Properties Elements
        const actionNodePropertiesContainer = document.getElementById('action-node-properties-container');
        const deleteActionNodeButton = document.getElementById('delete-action-node-button');
        const saveActionNodeProperties = document.getElementById('save-action-node-properties');

        // Connection Editor Modal Elements (New/Modified)
        const connectionEditorModal = document.getElementById('connection-editor-modal');
        const connectionModalTitle = document.getElementById('connection-modal-title');
        const saveConnectionEditorButton = document.getElementById('save-connection-editor');
        const deleteConnectionButton = document.getElementById('delete-connection-button');
        const closeConnectionEditorButtons = connectionEditorModal.querySelectorAll('.close-button');
            // New DOM element for preview
        const lottiePreviewImage = document.getElementById('lottie-preview-image');

        // Custom Dropdown DOM elements (Node Properties Modal)
        // --- NEW: Global Animation Dropdown Elements ---
        const globalAnimationControls = document.getElementById('global-animation-controls');
        const globalAnimationDisplay = document.getElementById('global-animation-display');
        const globalAnimationOptionsContainer = document.getElementById('global-animation-options');
        const globalAnimationNativeSelect = document.getElementById('global-animation-select');

        const animationDropdownGroup = document.getElementById('animation-dropdown-group');
        const animationDisplay = animationDropdownGroup.querySelector('.custom-dropdown-display');
        const animationOptionsContainer = document.getElementById('animation-options');
        const animationNativeSelect = document.getElementById('animation-select'); // Reference to the hidden native select

        const markerDropdownGroup = document.getElementById('marker-dropdown-group');
        const markerDisplay = markerDropdownGroup.querySelector('.custom-dropdown-display');
        // FIX: Corrected typo in assignment
        const markerOptionsContainer = document.getElementById('marker-options');
        const markerNativeSelect = document.getElementById('marker-select'); // Reference to the hidden native select

        // Custom Dropdown DOM elements (Connection Editor Modal)
        const transitionTypeDropdownGroup = document.getElementById('transition-type-dropdown-group');
        const transitionTypeDisplay = transitionTypeDropdownGroup.querySelector('.custom-dropdown-display');
        const transitionTypeOptionsContainer = document.getElementById('transition-type-options');
        const transitionTypeNativeSelect = document.getElementById('transition-type-select');

        const interactionPresetDropdownGroup = document.getElementById('interaction-preset-dropdown-group');
        const interactionPresetDisplay = interactionPresetDropdownGroup.querySelector('.custom-dropdown-display');
        const interactionPresetOptionsContainer = document.getElementById('interaction-preset-options');
        const interactionPresetNativeSelect = document.getElementById('interaction-preset-select');

        // Dynamic Interaction Fields
        const dynamicInteractionFields = document.getElementById('dynamic-interaction-fields');
        const loopCountField = document.getElementById('loop-count-field');
        const loopCountInput = document.getElementById('loop-count-input');
        const layerNameField = document.getElementById('layer-name-field');
        const layerNameInput = document.getElementById('layer-name-input');
        const customEventNameField = document.getElementById('custom-event-name-field');
        const editClickAreaButton = document.getElementById('edit-click-area-button');
        const customEventNameInput = document.getElementById('custom-event-name-input');

        // NEW: Tweened Transition Fields
        const tweenedDurationField = document.getElementById('tweened-duration-field');
        const tweenedDurationInput = document.getElementById('tweened-duration-input');
        const tweenedEasingField = document.getElementById('tweened-easing-field');
        const tweenedEasingInput = document.getElementById('tweened-easing-input');

        // NEW: Action Editor Elements
        const actionsSection = document.getElementById('actions-section');
        const actionTypeDropdownGroup = document.getElementById('action-type-dropdown-group');
        const actionTypeDisplay = actionTypeDropdownGroup.querySelector('.custom-dropdown-display');
        const actionTypeOptionsContainer = document.getElementById('action-type-options');
        const actionTypeNativeSelect = document.getElementById('action-type-select');
        const actionValueField = document.getElementById('action-value-field');
        const actionValueInput = document.getElementById('action-value-input');

        // NEW: Guard Condition Modal Elements
        const guardConditionModal = document.getElementById('guard-condition-modal');
        const guardConditionTypeDropdownGroup = document.getElementById('guard-condition-type-dropdown-group');
        //const guardConditionTypeDisplay = guardConditionTypeDropdownGroup.querySelector('.custom-dropdown-display');
        const guardConditionTypeOptionsContainer = document.getElementById('guard-condition-type-options');
        const guardConditionTypeNativeSelect = document.getElementById('guard-condition-type-select');
        const guardValueInput = document.getElementById('guard-value-input');
        const saveGuardConditionButton = document.getElementById('save-guard-condition');
        const deleteGuardConnectionButton = document.getElementById('delete-guard-connection-button');

        // NEW: Global State Modal Elements
        const globalStatePropertiesContainer = document.getElementById('global-state-properties-container');
        const globalStateNameInput = document.getElementById('global-state-name-input');
        const globalStateTypeDropdownGroup = document.getElementById('global-state-type-dropdown-group');
        const globalStateValueInput = document.getElementById('global-state-value-input');
        const saveGlobalStateButton = document.getElementById('save-global-state');
        const deleteGlobalStateButton = document.getElementById('delete-global-state-button'); // NEW
        const globalStateValueToggle = document.getElementById('global-state-value-toggle'); // NEW
        const globalStateValueToggleSwitch = document.getElementById('global-state-value-toggle-switch'); // NEW
        const globalStateValueInputContainer = document.getElementById('global-state-value-input'); // NEW


        // Ghost line elements
        const ghostConnectionLine = document.getElementById('ghost-connection-line');
        const ghostConnectionArrow = document.getElementById('ghost-connection-arrow');

        // Custom Alert Elements
        const customAlertOverlay = document.getElementById('custom-alert-overlay');
        const customAlertMessage = document.getElementById('custom-alert-message');
        const customAlertOkButton = document.getElementById('custom-alert-ok-button');


        let isConnecting = false;
        let isAddingGuard = false; // NEW
        let isRedrawQueued = false; // NEW: Flag to throttle redraws
        let firstNodeSelected = null;
        let firstPortType = null;
        let isCreatingGuardConnection = false; // NEW: Dedicated flag for the new segregated logic
        let panOffsetX = 0, panOffsetY = 0;
        let isPanningCanvas = false;
        let lastMouseX = 0, lastMouseY = 0;

        function generateId() { return 'id_' + Math.random().toString(36).substr(2, 9); }

        // --- MODIFIED: Moved updateModeUI to the top for proper scope ---
        function updateModeUI() {
            connectModeIndicator.style.display = isConnecting ? 'block' : 'none';
            guardModeIndicator.style.display = 'none'; // This mode is now implicit
            // Hide connection exists indicator when mode changes or connection is established
            connectionExistsIndicator.style.display = 'none';

            connectNodesButton.querySelector('i').className = isConnecting ? 'fas fa-times' : 'fas fa-link';
            connectNodesButton.style.backgroundColor = isConnecting ? '#dc3545' : '#4a90e2';
            connectNodesButton.title = isConnecting ? 'Cancel Connection Mode' : 'Connect Nodes';

            // Ghost line is now only for regular connections
            ghostConnectionLine.style.display = isConnecting ? 'block' : 'none';
            ghostConnectionArrow.style.display = isConnecting ? 'block' : 'none';
            ghostConnectionLine.style.strokeDasharray = '5, 5'; // Dotted for regular connection
            ghostConnectionLine.style.stroke = '#999'; // Default ghost line color

            nodes.forEach(node => {
                const el = document.getElementById(node.id);
                if (el) {
                    const ports = el.querySelectorAll('.node-port');
                    ports.forEach(port => {
                        if (isConnecting) {
                            // In connection mode, ports on all nodes (except the one being hovered for destination highlighting) should be hidden
                            port.style.opacity = '0';
                            port.style.transform = 'scale(0)'; // Reset transform to base scale
                            port.style.pointerEvents = 'none'; // Ensure clicks go to the node itself
                            port.classList.remove('highlighted-destination-port'); // Remove any lingering highlight
                        } else {
                            // Not in connection mode, clear inline styles to let CSS :hover take over
                            port.style.opacity = ''; // Clear inline opacity
                            port.style.transform = ''; // Clear inline transform
                            port.style.pointerEvents = 'all'; // Allow hover to show them
                            port.classList.remove('highlighted-destination-port'); // Ensure no highlight remains
                        }
                    });
                    if (isConnecting) {
                        if (el === firstNodeSelected) {
                            el.classList.add('selected-for-connection');
                        } else {
                            el.classList.remove('selected-for-connection');
                        }
                    } else {
                        el.classList.remove('selected-for-connection');
                    }
                }
            }); // Also handle global state node if it exists
            const globalNodeEl = document.getElementById('global_state_node');

            if (!isConnecting) {
                firstNodeSelected = null;
                firstPortType = null;
                // Ensure any leftover highlighted destination node is cleared
                if (currentHoveredDestinationNode) {
                    currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port');
                    currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port');
                    currentHoveredDestinationNode = null;
                }
            }
        }
        // --- END MODIFIED ---

        function getPortCoordinates(node, portType, offsetIndex = 0, totalConnectionsOnThisSide = 1) {
            let x, y;
            const portHalfSize = PORT_SIZE / 2;
            const edgeOffset = PORT_OFFSET + portHalfSize;
            let baseEdgeX, baseEdgeY;

            // --- NEW: Use node-specific dimensions ---
            const nodeWidth = (node.type === 'action') ? 100 : NODE_WIDTH;
            const nodeHeight = (node.type === 'action') ? 100 : NODE_HEIGHT;
            // Action nodes should not have the vertical offset.
            const verticalOffset = (node.type === 'action') ? 0 : ConnectionPortOffset;
            // --- END NEW ---

            switch (portType) {
                case 'top':
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y - edgeOffset;
                    break;
                case 'right':
                    baseEdgeX = node.x + nodeWidth + edgeOffset;
                    baseEdgeY = node.y + nodeHeight / 2;
                    break;
                case 'bottom':
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y + nodeHeight + edgeOffset;
                    break;
                case 'left':
                    baseEdgeX = node.x - edgeOffset;
                    baseEdgeY = node.y + nodeHeight / 2;
                    break;
                default:
                    baseEdgeX = node.x + nodeWidth / 2;
                    baseEdgeY = node.y + nodeHeight / 2;
            }

            if (totalConnectionsOnThisSide <= 1) return { x: baseEdgeX, y: baseEdgeY };

            const spacing = 20;
            const itemLength = PORT_SIZE;
            const totalGroupLength = (itemLength * totalConnectionsOnThisSide) + (spacing * (totalConnectionsOnThisSide - 1));
            let offsetFromCenter = -(totalGroupLength / 2) + (itemLength / 2) + (offsetIndex * (itemLength + spacing));

            if (portType === 'top' || portType === 'bottom') {
                x = baseEdgeX + offsetFromCenter;
                y = baseEdgeY;
            } else { // 'left' or 'right'
                x = baseEdgeX;
                y = baseEdgeY + offsetFromCenter; // This offset is for multiple connections, still apply ConnectionPortOffset above
            }
            return { x, y };
        }

        // Function to populate both native and custom dropdowns
        // Function to populate both native and custom dropdowns
        // Function to populate both native and custom dropdowns
        function populateDropdowns(nativeSelectElement, customDisplayElement, customOptionsContainer, optionsData, selectedValue, isDisabled = false) {
           // Clear existing options from native select
           nativeSelectElement.innerHTML = '';
           // Clear existing options from custom dropdown
           customOptionsContainer.innerHTML = '';

           nativeSelectElement.disabled = isDisabled;

           let displayValueFound = false; // Flag to track if the selected value was matched in options

           


           optionsData.forEach(option => {
               let optionValue = option.id || option.name;

               const optionElement = document.createElement('option');
               optionElement.value = optionValue;
               optionElement.textContent = option.name;
               nativeSelectElement.appendChild(optionElement);

               const customOptionElement = document.createElement('div');
               customOptionElement.classList.add('custom-dropdown-option');
               customOptionElement.dataset.value = optionValue;
               customOptionElement.textContent = option.name;
               customOptionsContainer.appendChild(customOptionElement);

               if (optionValue === selectedValue) { // This condition covers both marker (by name) and other (by id)
                   customDisplayElement.textContent = option.name;
                   customOptionElement.classList.add('selected');
                   // *** ADDED FIX: Set the native select's value here as well ***
                   nativeSelectElement.value = selectedValue;
                   displayValueFound = true;
               }
           });

           // NEW: Add special "Add/Edit Segments" option to marker dropdown
           if (nativeSelectElement.id === 'marker-select') {
               // NEW: Style the option as a pill-shaped green button
               const addSegmentOption = document.createElement('div');
               // We don't add 'custom-dropdown-option' to avoid default hover effects
               addSegmentOption.dataset.value = 'add_segment_action'; // Special value
               addSegmentOption.innerHTML = '<i class="fas fa-plus" style="margin-right: 8px;"></i> Add Segments';
               Object.assign(addSegmentOption.style, {
                   backgroundColor: '#d4edda', // Pastel green background
                   color: '#155724', // Dark green text for contrast
                   fontWeight: 'bold',
                   fontSize: '14px', // Make text slightly smaller
                   textAlign: 'center',
                   borderRadius: '999px', // Pill shape
                   padding: '10px 14px',
                   margin: '8px 4px 4px 4px', // Add some margin inside the dropdown, more on top
                   cursor: 'pointer',
                   transition: 'background-color 0.2s ease',
                   border: '1px solid #c3e6cb' // Matching pastel green border
               });
               addSegmentOption.onmouseover = () => { addSegmentOption.style.backgroundColor = '#c3e6cb'; };
               addSegmentOption.onmouseout = () => { addSegmentOption.style.backgroundColor = '#d4edda'; };
               customOptionsContainer.appendChild(addSegmentOption);
           }

           // Fallback logic if no matching option was found AND it wasn't handled by the 'Full Animation' logic above
           if (!displayValueFound) {
               if (nativeSelectElement.id === 'marker-select' && optionsData.some(o => o.name === 'Full Animation')) {
                   // If it's the marker select and still no match, default to "Full Animation"
                   customDisplayElement.textContent = 'Full Animation';
                   nativeSelectElement.value = 'Full Animation';
                   customOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                   const fullAnimOption = customOptionsContainer.querySelector('[data-value="Full Animation"]');
                   if (fullAnimOption) {
                       fullAnimOption.classList.add('selected');
                   }
               } else if (nativeSelectElement.options.length > 0) {
                   // For other dropdowns (or marker dropdown without 'Full Animation'), select the first option if no match
                   const firstOptionValue = nativeSelectElement.options[0].value;
                   const firstOptionText = nativeSelectElement.options[0].textContent;
                   nativeSelectElement.value = firstOptionValue;
                   customDisplayElement.textContent = firstOptionText;
                   const firstCustomOption = customOptionsContainer.querySelector(`[data-value="${firstOptionValue}"]`);
                   if (firstCustomOption) {
                       firstCustomOption.classList.add('selected');
                   }
               } else {
                   // If no options at all
                   customDisplayElement.textContent = 'No markers found';
                   nativeSelectElement.value = ''; // Ensure native select is also cleared or set to a default empty value
               }
           }
       }

function populateMarkerDropdown(selectedAnimationId, selectedMarkerName) {
    // Get the current animation object based on the selectedAnimationId.
    const currentAnimation = availableAnimations.find(anim => anim.id === selectedAnimationId);

    let markersForDropdown = currentAnimation ? [...currentAnimation.markers] : []; // Start with a copy of the correct animation's markers

    // Generate and add "Frame A to B" marker if selectedMarkerName matches the format
    const newFrameMarker = generateFrameRangeMarker(selectedMarkerName, markersForDropdown);
    if (newFrameMarker) {
        if (!markersForDropdown.some(m => m.name === newFrameMarker.name)) {
            markersForDropdown.push(newFrameMarker);
        }
    }

    markersForDropdown.sort((a, b) => {
        if (a.name === 'Full Animation') return -1;
        if (b.name === 'Full Animation') return 1;
        return a.name.localeCompare(b.name);
    });

    // 3. Populate the Marker Dropdown with the correct markers
    populateDropdowns(
        markerNativeSelect,
        markerDisplay,
        markerOptionsContainer,
        markersForDropdown,
        selectedMarkerName
    );
}

// --- NEW: Function to populate the global animation dropdown ---
function populateGlobalAnimationDropdown() {
    // Set the globalAnimationId to the first animation if it's not already set
    if (!globalAnimationId && availableAnimations.length > 0) {
        globalAnimationId = availableAnimations[0].id;
    }

    const animationOptions = availableAnimations.map(anim => ({ id: anim.id, name: anim.name }));

    populateDropdowns(
        globalAnimationNativeSelect,
        globalAnimationDisplay,
        globalAnimationOptionsContainer,
        animationOptions,
        globalAnimationId
    );

    // After populating, ensure all nodes are synced to the global animation ID
    setGlobalAnimation(globalAnimationId, false); // Don't show alert on initial load
}

    function populateAnimationAndMarkerDropdowns(selectedAnimationId, selectedMarkerName) {
           // 1. Populate Animation Dropdown first.
           // This will set the native select's value and the custom display.
           populateDropdowns(
               animationNativeSelect,
               animationDisplay,
               animationOptionsContainer,
               availableAnimations.map(anim => ({ id: anim.id, name: anim.name })),
               selectedAnimationId // Use the ID passed for the node
           );

           // 2. NOW, get the current animation object based on the selectedAnimationId.
           // This ensures we're looking up the markers for the correct animation of the node being edited.
           const currentAnimation = availableAnimations.find(anim => anim.id === selectedAnimationId);

           let markersForDropdown = currentAnimation ? [...currentAnimation.markers] : []; // Start with a copy of the correct animation's markers

           // Generate and add "Frame A to B" marker if selectedMarkerName matches the format
           const newFrameMarker = generateFrameRangeMarker(selectedMarkerName, markersForDropdown);
           if (newFrameMarker) {
               if (!markersForDropdown.some(m => m.name === newFrameMarker.name)) {
                   markersForDropdown.push(newFrameMarker);
               }
           }

           // 3. Populate the Marker Dropdown with the correct markers
           populateDropdowns(
               markerNativeSelect,
               markerDisplay,
               markerOptionsContainer,
               markersForDropdown,
               selectedMarkerName
           );
       }

        function getOppositePort(portType) {
            if (portType === 'left') return 'right';
            if (portType === 'right') return 'left';
            // Should not happen for current logic, but good to have a fallback
            console.warn("getOppositePort called with unexpected port type:", portType);
            return portType;
        }

        /**
         * Generates an SVG path data string ('d' attribute value) with rounded corners.
         * @param {Array<Object>} points - An array of {x, y} objects representing the path points.
         * @param {number} radius - The desired radius for the rounded corners.
         * @returns {string} The SVG path data string.
         */
        function getRoundedPathD(points, radius) {
            if (points.length < 2) {
                return `M ${points[0].x} ${points[0].y}`;
            }
            if (points.length === 2) {
                return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;
            }

            let d = `M ${points[0].x} ${points[0].y}`;

            for (let i = 1; i < points.length - 1; i++) {
                const p1 = points[i - 1]; // Previous point
                const p2 = points[i];     // Current point (corner)
                const p3 = points[i + 1]; // Next point

                // Calculate vectors from p2 to p1 and p2 to p3
                const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
                const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

                // Calculate lengths
                const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                // Normalize vectors
                const uv1 = { x: v1.x / len1, y: v1.y / len1 };
                const uv2 = { x: v2.x / len2, y: v2.y / len2 };

                // Determine the actual radius to use, limited by half the shortest segment length
                const currentRadius = Math.min(radius, len1 / 2, len2 / 2);

                // Points for the curve start and end
                const p1_curve_end = { x: p2.x + uv1.x * currentRadius, y: p2.y + uv1.y * currentRadius };
                const p3_curve_start = { x: p2.x + uv2.x * currentRadius, y: p2.y + uv2.y * currentRadius };

                // Add line to the start of the curve
                d += ` L ${p1_curve_end.x} ${p1_curve_end.y}`;
                // Add quadratic Bezier curve
                d += ` Q ${p2.x} ${p2.y} ${p3_curve_start.x} ${p3_curve_start.y}`;
            }

            // Add line to the very last point
            d += ` L ${points[points.length - 1].x} ${points[points.length - 1].y}`;

            return d;
        }

        function calculateOrthogonalPathPoints(conn, fromNode, toNode, nodePortConnectionsMap, forceCShape = false) {
            const fromPortData = nodePortConnectionsMap[conn.fromNodeId]?.[conn.fromPortType];
            let allConnectionsOnFromPortSide = fromPortData ? [...(fromPortData.outgoing || []), ...(fromPortData.incoming || [])] : [];
            // OPTIMIZATION: Sort connections by the Y-coordinate of the 'other' node for better visual spreading
            allConnectionsOnFromPortSide.sort((a, b) => {
                const otherNodeA = (a.fromNodeId === fromNode.id) ? nodes.find(n => n.id === a.toNodeId) : nodes.find(n => n.id === a.fromNodeId);
                const otherNodeB = (b.fromNodeId === fromNode.id) ? nodes.find(n => n.id === b.toNodeId) : nodes.find(n => n.id === b.fromNodeId);

                if (!otherNodeA || !otherNodeB) return 0; // Should not happen if data is consistent

                if (a.fromPortType === 'left' || a.fromPortType === 'right') {
                    return otherNodeA.y - otherNodeB.y; // Sort by Y-coordinate for horizontal ports
                } else { // 'top' or 'bottom' ports
                    return otherNodeA.x - otherNodeB.x; // Sort by X-coordinate for vertical ports
                }
            });
            const totalConnectionsForFromPort = allConnectionsOnFromPortSide.length;
            const fromIndex = allConnectionsOnFromPortSide.findIndex(c => c.id === conn.id);
            const p1_coord = getPortCoordinates(fromNode, conn.fromPortType, fromIndex, totalConnectionsForFromPort);

            const toPortData = nodePortConnectionsMap[conn.toNodeId]?.[conn.toPortType];
            let allConnectionsOnToPortSide = toPortData ? [...(toPortData.outgoing || []), ...(toPortData.incoming || [])] : [];
            // OPTIMIZATION: Sort connections by the Y-coordinate of the 'other' node for better visual spreading
            allConnectionsOnToPortSide.sort((a, b) => {
                const otherNodeA = (a.toNodeId === toNode.id) ? nodes.find(n => n.id === a.fromNodeId) : nodes.find(n => n.id === a.toNodeId);
                const otherNodeB = (b.toNodeId === toNode.id) ? nodes.find(n => n.id === b.fromNodeId) : nodes.find(n => n.id === b.toNodeId);

                if (!otherNodeA || !otherNodeB) return 0; // Should not happen if data is consistent

                if (a.toPortType === 'left' || a.toPortType === 'right') {
                    return otherNodeA.y - otherNodeB.y; // Sort by Y-coordinate for horizontal ports
                } else { // 'top' or 'bottom' ports
                    return otherNodeA.x - otherNodeB.x; // Sort by X-coordinate for vertical ports
                }
            });
            const totalConnectionsForToPort = allConnectionsOnToPortSide.length;
            const toIndex = allConnectionsOnToPortSide.findIndex(c => c.id === conn.id);
            const p4_coord = getPortCoordinates(toNode, conn.toPortType, toIndex, totalConnectionsForToPort);

            const pathPoints = [p1_coord]; // Path always starts at the source port coordinate
            const fromPortType = conn.fromPortType;
            const toPortType = conn.toPortType;
            const MIN_ALIGN_DIFF = NODE_WIDTH / 3;
            let pathFound = false;

            // --- MODIFICATION: Force C-Shape for specific loop-back scenarios (Opposite-facing ports) ---
            if (forceCShape &&
                ( (fromPortType === 'right' && toPortType === 'left') || (fromPortType === 'left' && toPortType === 'right') )
            ) {
                let detourY;
                const marginAboveBelow = NODE_HEIGHT / 2 + ROUTING_STUB;
                // New logic: wrap upwards if fromNode.y < toNode.y, else downwards
                if (fromNode.y < toNode.y) { // Origin is above destination, wrap upwards
                    detourY = Math.min(fromNode.y, toNode.y) - marginAboveBelow;
                } else { // Origin is below or at same level as destination, wrap downwards
                    detourY = Math.max(fromNode.y + NODE_HEIGHT, toNode.y + NODE_HEIGHT) + marginAboveBelow;
                }

                let p2_from_stub_end = { x: p1_coord.x, y: p1_coord.y };
                if (fromPortType === 'left') p2_from_stub_end.x -= ROUTING_STUB;
                else p2_from_stub_end.x += ROUTING_STUB;

                let p4_to_stub_start = { x: p4_coord.x, y: p4_coord.y };
                if (toPortType === 'left') p4_to_stub_start.x -= ROUTING_STUB;
                else p4_to_stub_start.x += ROUTING_STUB;


                pathPoints.length = 0;
                pathPoints.push(p1_coord);
                pathPoints.push(p2_from_stub_end);
                pathPoints.push({ x: p2_from_stub_end.x, y: detourY });
                pathPoints.push({ x: p4_to_stub_start.x, y: detourY });
                pathPoints.push(p4_to_stub_start);
                pathPoints.push(p4_coord);
                pathFound = true;
            }
            // --- END MODIFICATION ---


            if (!pathFound) {
                if ((fromPortType === 'right' && toPortType === 'left' && p4_coord.x > p1_coord.x) ||
                    (fromPortType === 'left' && toPortType === 'right' && p4_coord.x < p1_coord.x)) {
                    const midX = (p1_coord.x + p4_coord.x) / 2;
                    pathPoints.push({ x: midX, y: p1_coord.y });
                    pathPoints.push({ x: midX, y: p4_coord.y });
                    pathPoints.push(p4_coord);
                    pathFound = true;
                } else if ((fromPortType === 'bottom' && toPortType === 'top' && p4_coord.y < p1_coord.y) ||
                           (fromPortType === 'top' && toPortType === 'bottom' && p4_coord.y > p1_coord.y)) {
                    const midY = (p1_coord.y + p4_coord.y) / 2;
                    pathPoints.push({ x: p1_coord.x, y: midY });
                    pathPoints.push({ x: p4_coord.x, y: midY });
                    pathPoints.push(p4_coord);
                    pathFound = true;
                }
            }

            if (!pathFound) {
                let p_bend = null;
                if ((fromPortType === 'left' || fromPortType === 'right') && (toPortType === 'top' || toPortType === 'bottom')) {
                     p_bend = {x: p4_coord.x, y: p1_coord.y};
                } else if ((fromPortType === 'top' || fromPortType === 'bottom') && (toPortType === 'left' || toPortType === 'right')) {
                     p_bend = {x: p1_coord.x, y: p4_coord.y};
                }
                if (p_bend) {
                    pathPoints.push(p_bend);
                    pathPoints.push(p4_coord);
                    pathFound = true;
                }
            }

            if (!pathFound) {
                let p2 = { x: p1_coord.x, y: p1_coord.y };
                if (fromPortType === 'left') p2.x -= ROUTING_STUB;
                else if (fromPortType === 'right') p2.x += ROUTING_STUB;
                else if (fromPortType === 'top') p2.y -= ROUTING_STUB;
                else if (fromPortType === 'bottom') p2.y += ROUTING_STUB;
                pathPoints.push(p2);

                let p3_target_stub = { x: p4_coord.x, y: p4_coord.y };
                if (toPortType === 'left') p3_target_stub.x -= ROUTING_STUB;
                else if (toPortType === 'right') p3_target_stub.x += ROUTING_STUB;
                else if (toPortType === 'top') p3_target_stub.y -= ROUTING_STUB;
                else if (toPortType === 'bottom') p3_target_stub.y += ROUTING_STUB;

                const S_C_THRESHOLD = NODE_WIDTH;
                const C_DETOUR_OFFSET = ROUTING_STUB * 3 + NODE_HEIGHT / 2; // Increased multiplier for more space

                // New logic for detourDirection based on fromNode.y vs toNode.y
                let detourDirection = (fromNode.y < toNode.y) ? -1 : 1; // -1 for upwards, 1 for downwards

                if (fromPortType === 'left' || fromPortType === 'right') {
                    let midY;
                    const H_effective = Math.abs(p1_coord.y - p4_coord.y);
                    if (H_effective > S_C_THRESHOLD &&
                        !((fromPortType === 'left' && p2.x > p3_target_stub.x) || (fromPortType === 'right' && p2.x < p3_target_stub.x))
                       ) {
                        midY = (p2.y + p3_target_stub.y) / 2;
                    } else {
                        midY = (p2.y + p3_target_stub.y) / 2 + detourDirection * C_DETOUR_OFFSET;
                        if (fromPortType === 'left' && toPortType === 'right' && H_effective <= S_C_THRESHOLD) {
                             midY = p1_coord.y - (H_effective/2 + ROUTING_STUB * 2);
                        }
                    }
                    pathPoints.push({ x: p2.x, y: midY });
                    pathPoints.push({ x: p3_target_stub.x, y: midY });
                } else {
                    let midX;
                    const X_effective = Math.abs(p1_coord.x - p4_coord.x);
                    if (X_effective > S_C_THRESHOLD &&
                        !((fromPortType === 'top' && p2.y > p3_target_stub.y) || (fromPortType === 'bottom' && p2.y < p3_target_stub.y))
                        ) {
                        midX = (p2.x + p3_target_stub.x) / 2;
                    } else {
                        midX = (p2.x + p3_target_stub.x) / 2 + detourDirection * C_DETOUR_OFFSET;
                    }
                    pathPoints.push({ x: midX, y: p2.y });
                    pathPoints.push({ x: midX, y: p3_target_stub.y });
                }
                pathPoints.push(p3_target_stub);
                pathPoints.push(p4_coord);
            }

            // Filter out consecutive duplicate points, which can cause issues with path rendering
            return pathPoints.filter((point, i, arr) => {
                if (i === 0) return true;
                const prev = arr[i-1];
                if (point.x === prev.x && point.y === prev.y) return false;
                // Also filter out redundant intermediate points that are collinear
                if (i > 1) {
                    const prevPrev = arr[i-2];
                    // Check if prev is directly between prevPrev and current point (collinear)
                    // This is a simplified check for orthogonal lines
                    const isCollinearX = (point.x === prev.x && prev.x === prevPrev.x);
                    const isCollinearY = (point.y === prev.y && prev.y === prevPrev.y);
                    if (isCollinearX || isCollinearY) {
                        // Keep the point if it's the last one, to ensure the path reaches its destination
                        if (i === arr.length -1) return true;
                        return false;
                    }
                }
                return true;
            });
        }


        function fitCanvasToNodesMinimally() {
            let minOverallX = Infinity, minOverallY = Infinity;
            let maxOverallX = -Infinity, maxOverallY = -Infinity;

            if (nodes.length === 0 && connections.length === 0) {
                minOverallX = 0; minOverallY = 0;
                maxOverallX = DEFAULT_MIN_CANVAS_WIDTH; maxOverallY = DEFAULT_MIN_CANVAS_HEIGHT;
            } else {
                 if (nodes.length > 0) {
                    nodes.forEach(node => {
                        minOverallX = Math.min(minOverallX, node.x);
                        minOverallY = Math.min(minOverallY, node.y);
                        maxOverallX = Math.max(maxOverallX, node.x + NODE_WIDTH);
                        maxOverallY = Math.max(maxOverallY, node.y + NODE_HEIGHT);
                    });
                } else { // Only connections exist
                    minOverallX = 0; minOverallY = 0;
                    maxOverallX = 0; maxOverallY = 0; // Will be expanded by connection paths
                }

                // NEW: Include the global state node in the bounds calculation
                if (globalState) {
                    const GLOBAL_NODE_SIZE = 120; // As defined in CSS
                    minOverallX = Math.min(minOverallX, globalState.x);
                    minOverallY = Math.min(minOverallY, globalState.y);
                    maxOverallX = Math.max(maxOverallX, globalState.x + GLOBAL_NODE_SIZE);
                    maxOverallY = Math.max(maxOverallY, globalState.y + GLOBAL_NODE_SIZE);
                }


                const tempNodePortConnections = {};
                 connections.forEach(conn => {
                    if (!tempNodePortConnections[conn.fromNodeId]) tempNodePortConnections[conn.fromNodeId] = {};
                    if (!tempNodePortConnections[conn.fromNodeId][conn.fromPortType]) tempNodePortConnections[conn.fromNodeId][conn.fromPortType] = { outgoing: [], incoming: [] };
                    tempNodePortConnections[conn.fromNodeId][conn.fromPortType].outgoing.push(conn);

                    if (!tempNodePortConnections[conn.toNodeId]) tempNodePortConnections[conn.toNodeId] = {};
                    if (!tempNodePortConnections[conn.toNodeId][conn.toPortType]) tempNodePortConnections[conn.toNodeId][conn.toPortType] = { outgoing: [], incoming: [] };
                    tempNodePortConnections[conn.toNodeId][conn.toPortType].incoming.push(conn);
                });


                connections.forEach(conn => {
                    const fromNode = nodes.find(n => n.id === conn.fromNodeId);
                    const toNode = nodes.find(n => n.id === conn.toNodeId);
                    if (fromNode && toNode) {
                        // Determine actual forceCShape for bounding box calculation
                        let actualForceCShapeForBounds = conn.forceCShape;
                        const pairedConnection = connections.find(pConn =>
                            pConn.fromNodeId === conn.toNodeId && pConn.toNodeId === conn.fromNodeId
                        );
                        if (pairedConnection) {
                            if (conn.forceCShape === true) {
                                const pairedPathPointsForBounds = calculateOrthogonalPathPoints(
                                    pairedConnection, toNode, fromNode, tempNodePortConnections, false
                                );
                                if (isPathNaturallyCShape(pairedPathPointsForBounds, pairedConnection, toNode, fromNode)) {
                                    actualForceCShapeForBounds = false;
                                } else {
                                    actualForceCShapeForBounds = true;
                                }
                            } else {
                                actualForceCShapeForBounds = false;
                            }
                        }

                        const path = calculateOrthogonalPathPoints(conn, fromNode, toNode, tempNodePortConnections, actualForceCShapeForBounds);
                        path.forEach(point => {
                            minOverallX = Math.min(minOverallX, point.x);
                            minOverallY = Math.min(minOverallY, point.y);
                            maxOverallX = Math.max(maxOverallX, point.x);
                            maxOverallY = Math.max(maxOverallY, point.y);
                        });
                    }
                });
                if (nodes.length === 0 && connections.length > 0 && minOverallX === Infinity) { // No valid connections to draw, use defaults
                    minOverallX = 0; minOverallY = 0; maxOverallX = DEFAULT_MIN_CANVAS_WIDTH; maxOverallY = DEFAULT_MIN_CANVAS_HEIGHT;
                }
            }

            let shiftX = -minOverallX + MINIMAL_CANVAS_EDGE_PADDING;
            let shiftY = -minOverallY + MINIMAL_CANVAS_EDGE_PADDING;

            let targetPanX = panOffsetX - shiftX;
            let targetPanY = panOffsetY - shiftY;

            let contentWidth = (maxOverallX - minOverallX) + MINIMAL_CANVAS_EDGE_PADDING * 2;
            let contentHeight = (maxOverallY - minOverallY) + MINIMAL_CANVAS_EDGE_PADDING * 2;

            let targetCanvasWidth = Math.max(DEFAULT_MIN_CANVAS_WIDTH, contentWidth);
            let targetCanvasHeight = Math.max(DEFAULT_MIN_CANVAS_HEIGHT, contentHeight);

            const faWidth = flowchartArea.offsetWidth;
            const faHeight = flowchartArea.offsetHeight;

            if (targetCanvasWidth <= faWidth) targetPanX = Math.max(0, Math.min(targetPanX, faWidth - targetCanvasWidth));
            else targetPanX = Math.max(faWidth - targetCanvasWidth, Math.min(targetPanX, 0));
            if (targetCanvasHeight <= faHeight) targetPanY = Math.max(0, Math.min(targetPanY, faHeight - targetCanvasHeight));
            else targetPanY = Math.max(faHeight - targetCanvasHeight, Math.min(targetPanY, 0));

            canvasContainer.style.transition = 'none';
            canvasContainer.style.left = `${targetPanX}px`; canvasContainer.style.top = `${targetPanY}px`;
            canvasContainer.style.width = `${targetCanvasWidth}px`; canvasContainer.style.height = `${targetCanvasHeight}px`;

            panOffsetX = targetPanX; panOffsetY = targetPanY;

            if (nodes.length > 0) {
                nodes.forEach(node => {
                    node.x += shiftX; node.y += shiftY;
                    const el = document.getElementById(node.id);
                    if (el) { el.style.transition = 'none'; el.style.left = `${node.x}px`; el.style.top = `${node.y}px`; }
                });
            }
            // --- FIX START: Apply the same shift to the global state node ---
            if (globalState) {
                globalState.x += shiftX;
                globalState.y += shiftY;
                const el = document.getElementById(globalState.id);
                if (el) {
                    el.style.transition = 'none';
                    el.style.left = `${globalState.x}px`;
                    el.style.top = `${globalState.y}px`;
                }
            }
            // --- FIX END ---
            redrawAll();
        }

        function updateNodeStyles() {
            nodes.forEach(node => {
                const nodeElement = document.getElementById(node.id)?.querySelector('.node');
                if (nodeElement) {
                    // Remove both active and initial classes first
                    nodeElement.classList.remove('active', 'initial-node');

                    // Apply 'active' class if node.isActive is true
                    if (node.isActive) {
                        nodeElement.classList.add('active');
                    }
                    // Apply 'initial-node' class if node.isInitial is true
                    if (node.isInitial) {
                        nodeElement.classList.add('initial-node');
                    }
                }
            });
        }


        function createNodeElement(nodeData) {
            // --- NEW: Create a wrapper for the node and its hover area ---
            const nodeWrapper = document.createElement('div');
            nodeWrapper.id = nodeData.id; // The ID now goes on the wrapper
            nodeWrapper.classList.add('node-wrapper'); // A class for potential future styling
            nodeWrapper.style.position = 'absolute';

            const nodeElement = document.createElement('div');
            // --- NEW: Handle Action Node type ---
            if (nodeData.type === 'action') {
                // Add a display div for the action text/icon
                const actionDisplay = document.createElement('div');
                actionDisplay.classList.add('action-node-display');
                nodeElement.appendChild(actionDisplay);
                // Call a function to update its content
                updateActionNodeVisual(nodeElement, nodeData);

                nodeElement.classList.add('action-node');
            }
            // --- END NEW ---
            nodeElement.classList.add('node');

            // Apply initial-node class if it's the initial node
                        if (nodeData.isInitial) {
                            nodeElement.classList.add('initial-node');
                        }

            if (nodeData.isActive) {
                nodeElement.classList.add('active');
            }
            // --- MODIFIED: Positioning is now on the wrapper ---
            nodeWrapper.style.left = `${nodeData.x}px`;
            nodeWrapper.style.top = `${nodeData.y}px`;
            nodeWrapper.style.transition = 'none';
            // The node itself is positioned relative to the wrapper
            nodeElement.style.position = 'relative';

            const titleSpan = document.createElement('div'); titleSpan.classList.add('node-title'); titleSpan.textContent = nodeData.name; nodeElement.appendChild(titleSpan);
            const detailsSpan = document.createElement('div'); detailsSpan.classList.add('node-details'); nodeElement.appendChild(detailsSpan);
            updateNodeDetailsChips(nodeElement, nodeData);
            const editIcon = document.createElement('div'); editIcon.classList.add('edit-node-icon'); editIcon.innerHTML = '<i class="fas fa-cog"></i>'; nodeElement.appendChild(editIcon);
            const portTypes = ['top', 'right', 'bottom', 'left'];
            portTypes.forEach(type => {
                const port = document.createElement('div');
                port.classList.add('node-port', `${type}-port`); port.dataset.nodeId = nodeWrapper.id; port.dataset.portType = type;
                nodeElement.appendChild(port);                

                // --- NEW: Drag-to-connect logic ---
                if (nodeData.type !== 'action' && (type === 'left' || type === 'right')) {
                    port.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        // Start connection mode
                        isConnecting = true;
                        firstNodeSelected = nodeWrapper;
                        firstPortType = type;
                        updateModeUI();
                        connectModeIndicator.textContent = `Drag to a target node to connect.`;

                        // Immediately draw the ghost line to the current cursor position
                        const canvasRect = canvasContainer.getBoundingClientRect();
                        const initialSvgMouseX = e.clientX - canvasRect.left; 
                        const initialSvgMouseY = e.clientY - canvasRect.top; 
                        drawGhostLine(firstNodeSelected.id, firstPortType, initialSvgMouseX, initialSvgMouseY); 

                        const onDragEnd = (upEvent) => {
                            // Check if the mouse is released over a valid target node
                            const targetNodeWrapper = upEvent.target.closest('.node-wrapper');
                            if (targetNodeWrapper && targetNodeWrapper !== firstNodeSelected) {
                                const clickXRelativeToNode = upEvent.clientX - targetNodeWrapper.getBoundingClientRect().left;
                                const toPortType = (clickXRelativeToNode < NODE_WIDTH / 2) ? 'left' : 'right';
                                addConnection(firstNodeSelected.id, firstPortType, targetNodeWrapper.id, toPortType);
                            }

                            // Cleanup: End connection mode and remove listeners
                            isConnecting = false;
                            updateModeUI();
                            document.removeEventListener('mouseup', onDragEnd);
                        }

                        // Add a one-time mouseup listener to the document to handle release
                        document.addEventListener('mouseup', onDragEnd, { once: true });
                    });
                }
            });
            let isDraggingNode = false, offsetX, offsetY;
            nodeWrapper.addEventListener('mousedown', (e) => {
                // Prevent dragging if clicking edit icon, port, or detail chip
                if (e.target.closest('.edit-node-icon, .node-port, .node-detail-chip')) return;
                if (isConnecting) return;

                isDraggingNode = true; canvasContainer.style.transition = 'none'; nodeWrapper.style.transition = 'none';
                offsetX = e.clientX - nodeWrapper.getBoundingClientRect().left; offsetY = e.clientY - nodeWrapper.getBoundingClientRect().top;
                nodeWrapper.style.cursor = 'grabbing'; e.preventDefault(); e.stopPropagation();
            });
            document.addEventListener('mousemove', (e) => {
                if (!isDraggingNode || !nodeWrapper.parentNode) return;
                let newX = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX;
                let newY = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY;
                nodeWrapper.style.left = `${newX}px`;
                nodeWrapper.style.top = `${newY}px`;
                nodeData.x = newX;
                nodeData.y = newY;
                // Throttled redraw using requestAnimationFrame
                if (!isRedrawQueued) {
                    isRedrawQueued = true;
                    requestAnimationFrame(() => {
                        redrawAll();
                        isRedrawQueued = false;
                    });
                }
            });
            document.addEventListener('mouseup', () => {
                if (isDraggingNode) { isDraggingNode = false; nodeWrapper.style.cursor = 'grab'; fitCanvasToNodesMinimally(); }
            });
            nodeWrapper.addEventListener('click', (e) => {
                e.stopPropagation();
                if (nodeData.type !== 'action' && !isCreatingGuardConnection) {
          openNodePropertiesModal(nodeData);
      } else if (nodeData.type === 'action' && !isCreatingGuardConnection) {
          openActionNodePropertiesModal(nodeData);
      }
            });
            nodeWrapper.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      openNodePropertiesModal(nodeData);
      isConnecting = false;
      updateModeUI();

      // ADDED LOGIC: Check if state preview window is hidden and simulate click
      if (statePreviewWindow.classList.contains('hidden')) {
          previewToggleButton.click(); // Simulate a click on the toggle button
      }
  });
            editIcon.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (nodeData.type === 'action') {
                    openActionNodePropertiesModal(nodeData);
                } else {
                    openNodePropertiesModal(nodeData);
                }
                isConnecting = false; updateModeUI(); 
            });
            nodeWrapper.appendChild(nodeElement);
            nodeWrapper.click();

            return nodeWrapper;


        }

        function addNode(nodeData = null) {
            let newNodeName = nodeData ? nodeData.name : (nodes.length === 0 ? 'Idle' : 'New State');
            let counter = 1;
            const baseName = newNodeName;
            // Ensure initial name is unique if it's a default one
            if (!nodeData || (nodeData && nodeData.name === 'New State')) { // Only check for default "New State" or if no data
                 while (nodes.some(n => n.name === newNodeName)) {
                    newNodeName = `${baseName} ${counter++}`;
                }
            }


            const initialX = -panOffsetX + MINIMAL_CANVAS_EDGE_PADDING + 50 + (nodes.length * 10);
            const initialY = -panOffsetY + MINIMAL_CANVAS_EDGE_PADDING + 50 + (nodes.length * 10);

            const newNode = nodeData ?
                {...nodeData, name: newNodeName } : // Use potentially uniquified name if nodeData was passed
                {
                    id: generateId(),
                    name: newNodeName,
                    x: initialX,
                    y: initialY,
                    animationId: globalAnimationId || availableAnimations[0]?.id || '', // Use global animation ID
                    marker: '',
                    action: null, // NEW: Initialize action property
                    loop: false, // Loop only if it's the first "Idle" node
                    speed: 1.0,
                    isActive: true,
                     autoplay: true,
                    broadcastOnEntry: false,
                    broadcastOnExit: false
                };

            if (!nodeData) { // Only for newly created nodes, not imported ones
              nodes.forEach(n => n.isActive = false); // Deactivate others
              // NEW: Ensure no other initial node
              newNode.isActive = true;


              // Make the new node initial ONLY if there are no existing nodes
                if (nodes.length === 0) {
                    newNode.isInitial = true;
                }

            } else {
                // For imported nodes, isActive should already be set by the import logic
            }

            nodes.push(newNode);
            canvasContainer.appendChild(createNodeElement(newNode));
            fitCanvasToNodesMinimally();
            updateModeUI();
            updateNodeStyles();

            // --- NEW: Simulate re-selecting the global animation ---
            // This ensures the new node (and all others) are correctly synced
            // to the global animation, especially regarding markers.
            const currentlySelectedAnimationId = globalAnimationNativeSelect.value;
            if (currentlySelectedAnimationId) setGlobalAnimation(currentlySelectedAnimationId, false);
        }

        function addActionNode() {
            // Deactivate any other active nodes first
            nodes.forEach(n => n.isActive = false);
            updateNodeStyles();

            const newNode = { 
                id: generateId(), 
                type: 'action', 
                x: -panOffsetX + 100, y: -panOffsetY + 100,
                action: null, // Action nodes have an action property
                isActive: true // Set the new node to be active
            };
            nodes.push(newNode);
            // The createNodeElement function will automatically trigger a click, which opens the properties panel.
            canvasContainer.appendChild(createNodeElement(newNode));
        }

        function updateNodeDetailsChips(nodeElement, nodeData) {
          const detailsSpan = nodeElement.querySelector('.node-details'); detailsSpan.innerHTML = '';
          // --- MODIFIED: Show segment name instead of animation name ---
          const segmentChip = document.createElement('span');
          segmentChip.classList.add('node-detail-chip', 'chip-animation'); // Keep class for styling
          const segmentName = nodeData.marker ? nodeData.marker : 'Full Animation';
          segmentChip.innerHTML = `<i class="fas fa-play-circle"></i> ${segmentName}`;
          detailsSpan.appendChild(segmentChip);

          // Use node.marker for the marker chip
          if (nodeData.marker) {
              const markerChip = document.createElement('span');
              markerChip.classList.add('node-detail-chip', 'chip-marker'); // New class for marker chip
              markerChip.innerHTML = `<i class="fas fa-bookmark"></i> ${nodeData.marker}`;
              detailsSpan.appendChild(markerChip);
          }

          const loopChip = document.createElement('span');
          loopChip.classList.add('node-detail-chip', 'chip-loop');

          // MODIFIED LOGIC: Condition for "Loop: N times"
          let loopText = 'Loop: No'; // Default
          if (typeof nodeData.loop === 'number' && nodeData.loop > 0) {
              loopText = `Loop: ${nodeData.loop} times`;
          } else if (nodeData.loop === true) {
              loopText = 'Loop: Yes';
          }
          loopChip.innerHTML = `<i class="fas fa-redo-alt"></i> ${loopText}`;
          detailsSpan.appendChild(loopChip);
      }

        function updateNodeElement(nodeData) {
            const nodeElement = document.getElementById(nodeData.id)?.querySelector('.node');
            if (nodeElement) {
                nodeElement.querySelector('.node-title').textContent = nodeData.name;
                updateNodeDetailsChips(nodeElement, nodeData);
                fitCanvasToNodesMinimally();
                updateNodeStyles();
            }
        }

        // NEW: Function to update the visual display of an action node
        function updateActionNodeVisual(nodeElement, nodeData) {
            const displayElement = nodeElement.querySelector('.action-node-display'); // This is inside the .node div
            if (!displayElement) return;

            nodeElement.classList.remove('no-action');

            if (nodeData.action && globalState) {
                let actionText = '';
                const action = nodeData.action;
                switch (action.type) {
                    case 'Increment':
                        actionText = ` +${action.value || 1}`;
                        break;
                    case 'Decrement':
                        actionText = ` -${action.value || 1}`;
                        break;
                    case 'SetNumeric':
                    case 'SetBoolean':
                        actionText = ` ${action.value}`;
                        break;
                    case 'SetString':
                        actionText = ` "${action.value}"`;
                        break;
                    case 'Toggle':
                        actionText = ' Toggle';
                        break;
                    default:
                         actionText = 'No Action Set';
                         nodeElement.classList.add('no-action');
                }
                displayElement.innerHTML = `${actionText}<span class="action-target">${globalState.name}</span>`;
            } else {
                displayElement.textContent = 'No Action Set';
                nodeElement.classList.add('no-action'); // Add class to show fallback circle
            }
        }

        function deleteNode(nodeId) {
            const nodeWrapper = document.getElementById(nodeId); if (nodeWrapper) nodeWrapper.remove();
             const deletedNode = nodes.find(node => node.id === nodeId);
            nodes = nodes.filter(node => node.id !== nodeId);
            connections = connections.filter(conn => conn.fromNodeId !== nodeId && conn.toNodeId !== nodeId);


            if (deletedNode && deletedNode.isInitial) {
                // If the deleted node was the initial node, find a new one
                if (nodes.length > 0) {
                    nodes[0].isInitial = true; // Set the first remaining node as initial
                }
            }

            if (!nodes.some(node => node.isActive) && nodes.length > 0) {
                nodes[0].isActive = true;
            } else if (nodes.length === 0) {
                 // No active node if no nodes exist
            }

            fitCanvasToNodesMinimally();
            nodePropertiesModal.style.display = 'none';
            actionNodePropertiesContainer.style.display = 'none'; // NEW: Hide action modal too
            selectedNodeForEdit = null;
            updateModeUI();
            updateNodeStyles();
        }

        // NEW: Function to adjust the preview container's aspect ratio
        function adjustPreviewAspectRatio(animationId) {
            const animForAspectRatio = availableAnimations.find(a => a.id === animationId);

            if (animForAspectRatio && animForAspectRatio.jsonContent) {
                // Defer with requestAnimationFrame to run after browser layout/paint.
                requestAnimationFrame(() => {
                    const canvasWrapper = document.getElementById('canvas-wrapper');
                    if (!canvasWrapper) return;

                    try {
                        const animJson = JSON.parse(animForAspectRatio.jsonContent);
                        if (animJson.w && animJson.h && animJson.w > 0) {
                            const aspectRatio = animJson.h / animJson.w; // height / width
                            const animationHeight = canvasWrapper.offsetWidth * aspectRatio;
                            if (canvasWrapper.offsetWidth > 0) { // Only set height if width is calculated
                                canvasWrapper.style.height = `${animationHeight}px`;

                                // NEW: Explicitly tell the player to resize
                                if (modalDotLottiePlayer) {
                                    modalDotLottiePlayer.resize();
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Could not parse animation JSON for aspect ratio.", e);
                    }
                });
            }
        }

       


        async function openNodePropertiesModal(nodeData) {

                    // --- NEW: Update Panel Indicator with Animation Name ---
                    const panelIndicator = document.querySelector('#node-properties-modal .panel-type-indicator');
                    if (panelIndicator) {
                        const animation = availableAnimations.find(anim => anim.id === nodeData.animationId);
                        panelIndicator.textContent = animation ? animation.name : 'State Node'; // Fallback to 'State Node'
                    }
                    // --- END NEW ---

                    // --- NEW: Handle active state ---
                    // 1. Deactivate the global state node if it's active
                    const globalNodeEl = document.getElementById('global_state_node');
                    if (globalNodeEl) {
                        globalNodeEl.classList.remove('active');
                    }
                    // 2. Set the current node as active and update styles for all regular nodes
                    // NEW: Also deactivate action nodes
                    document.querySelectorAll('.action-node.active').forEach(el => el.classList.remove('active'));


                    nodes.forEach(n => n.isActive = (n.id === nodeData.id));
                    updateNodeStyles();
                    // --- END NEW ---

                    // Append the global state properties to the preview window if not already there
                    if (!statePreviewWindow.contains(globalStatePropertiesContainer)) {
                        statePreviewWindow.appendChild(globalStatePropertiesContainer);
                    }
                    // NEW: Ensure the correct panel is visible
                    globalStatePropertiesContainer.style.display = 'none';
                    actionNodePropertiesContainer.style.display = 'none';
                    nodePropertiesModal.style.display = 'flex';
                    if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

                    selectedNodeForEdit = nodeData;

                    nodeNameInput.value = nodeData.name; //

                    // Populate Animation and Marker Dropdowns
                    populateMarkerDropdown(nodeData.animationId, nodeData.marker); //

                    // Determine initial state of loopCheckbox based on outgoing connections
                    let shouldForceLoopCheckboxFalse = false;
                    let shouldForceFreezeCheckboxTrue = false;

                    const outgoingConnections = connections.filter(conn => conn.fromNodeId === nodeData.id);
                    console.log("Outgoing Connections:", JSON.stringify(outgoingConnections, null, 2));
                    if (outgoingConnections.some(conn => conn.interactionType === 'OnLoopComplete' || conn.interactionType === 'onComplete')) {
                        shouldForceLoopCheckboxFalse = true;
                        shouldForceFreezeCheckboxTrue = true;
                    }

                    // --- NEW LOGIC FOR LOOP CHECKBOX CONTROL ---
           const loopCheckboxContainer = document.getElementById('loop-checkbox').closest('.toggle-group'); // Get the parent .toggle-group
           const loopLabel = loopCheckboxContainer.querySelector('label'); // Get the label within the toggle group



                    if (shouldForceLoopCheckboxFalse) {
                // Disable interaction and change appearance
                console.log('happenined');
                loopCheckboxContainer.style.pointerEvents = 'none';
                loopCheckboxContainer.style.opacity = '0.4';
                loopLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                loopCheckbox.checked = false; // Force unchecked if controlled by transition
            } else {
                // Enable interaction and reset appearance
                loopCheckboxContainer.style.pointerEvents = 'auto';
                loopCheckboxContainer.style.opacity = '1.0';
                loopLabel.title = ''; // Clear tooltip
                // Original logic: set based on nodeData.loop
                const effectivelyLoops = (typeof nodeData.loop === 'boolean' && nodeData.loop === true) ||
                                       (typeof nodeData.loop === 'number' && nodeData.loop > 0);
                loopCheckbox.checked = effectivelyLoops;
            }


            // --- NEW: FREEZE ON FIRST FRAME CHECKBOX CONTROL ---
                        const freezeToggleLabel = freezeOnFirstFrameToggleGroup.querySelector('label');

                        if (shouldForceFreezeCheckboxTrue) { // Use the new flag
                            freezeOnFirstFrameToggleGroup.style.pointerEvents = 'none';
                            freezeOnFirstFrameToggleGroup.style.opacity = '0.4';
                            freezeToggleLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                            freezeOnFirstFrameCheckbox.checked = false; // Force checked (freeze)
                        } else {
                            freezeOnFirstFrameToggleGroup.style.pointerEvents = 'auto';
                            freezeOnFirstFrameToggleGroup.style.opacity = '1.0';
                            freezeToggleLabel.title = '';
                            // Set checkbox based on nodeData.autoplay property
                            freezeOnFirstFrameCheckbox.checked = !nodeData.autoplay; // checked = true means FREEZE, so autoplay = false
                        }



                    // Lottie Player and checkbox setup
                    if (modalDotLottiePlayer) {

                        modalDotLottiePlayer.setSpeed(nodeData.speed);
                        speedSlider.value = nodeData.speed;
                        speedValueSpan.textContent = nodeData.speed.toFixed(1) + 'x';

                        // Load the animation and play the correct marker
                        const animation = availableAnimations.find(anim => anim.id === nodeData.animationId); //
                        if (animation && animation.jsonContent) {
                            modalDotLottiePlayer.load({
                                data: JSON.parse(animation.jsonContent),
                                loop: true,
                            });

                            // Determine which marker to play
                            let markerToPlay = animation.markers.find(m => m.name === nodeData.marker);
                            
                            // If the node's marker is not set or not found, default to "Full Animation"
                            if (!markerToPlay) {
                                markerToPlay = animation.markers.find(m => m.name === 'Full Animation');
                            } 

                            // Play the determined marker
                            if (markerToPlay) {
                                modalDotLottiePlayer.setSegment(markerToPlay.start, markerToPlay.end);
                                modalDotLottiePlayer.play();
                            } else {
                                // Fallback if even "Full Animation" is missing
                                modalDotLottiePlayer.play();
                            }
                        }
                    } else {
                        // Fallback if player not ready (though it should be)
                         const effectivelyLoops = (typeof nodeData.loop === 'boolean' && nodeData.loop === true) ||
                                           (typeof nodeData.loop === 'number' && nodeData.loop > 0); //
                        loopCheckbox.checked = shouldForceLoopCheckboxFalse ? false : effectivelyLoops;
                        speedSlider.value = nodeData.speed;
                        speedValueSpan.textContent = nodeData.speed.toFixed(1) + 'x';
                    }

                    nodePropertiesModal.style.display = 'flex'; //

                    const broadcastEntryCheckbox = document.getElementById('broadcast-entry-checkbox'); //
                    const broadcastExitCheckbox = document.getElementById('broadcast-exit-checkbox'); //
                    const broadcastEntryNodeNameSpan = document.getElementById('broadcast-entry-node-name'); //
                    const broadcastExitNodeNameSpan = document.getElementById('broadcast-exit-node-name'); //

                    broadcastEntryCheckbox.checked = nodeData.broadcastOnEntry; //
                    broadcastExitCheckbox.checked = nodeData.broadcastOnExit; //
                    broadcastEntryNodeNameSpan.textContent = `${nodeData.name}_entry`; //
                    broadcastExitNodeNameSpan.textContent = `${nodeData.name}_exit`; //

                    initialNodeCheckbox.checked = nodeData.isInitial;
                    adjustPreviewAspectRatio(nodeData.animationId);
                }

        function closeNodePropertiesModal() {
            // This function is now effectively "close the right panel"
            if (!statePreviewWindow.classList.contains('hidden')) {
                previewToggleButton.click();
            }
            // We don't hide the modal itself, just the parent panel
            nodePropertiesModal.style.display = 'none';
            actionNodePropertiesContainer.style.display = 'none';
            selectedNodeForEdit = null;
        }

        function updateDynamicInteractionFields(selectedPresetId, details = {}) {
            // Hide all dynamic fields first
            loopCountField.style.display = 'none';
            layerNameField.style.display = 'none';
            customEventNameField.style.display = 'none';

            // Show and populate fields based on selectedPresetId
            if (selectedPresetId === 'onLoopComplete') {
                loopCountField.style.display = 'block';
                // Prioritize 'details.loopCount' (from imported connections)
                // then fall back to selectedNodeForEdit.loop (if it's a number),
                // then default to 1.
                loopCountInput.value = details.loopCount || (typeof selectedNodeForEdit.loop === 'number' ? selectedNodeForEdit.loop : 1);
            } else if (selectedPresetId === 'CustomEvent') {
                customEventNameField.style.display = 'block';
                customEventNameInput.value = details.customEventName || '';
            }

            // --- FIX: Show/hide the 'Edit Click Area' button based on the preset ---
            const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp'];
            if (pointerEvents.includes(selectedPresetId)) {
                layerNameField.style.display = 'block';
            } else {
                layerNameField.style.display = 'none';
            }

            // --- NEW: Hide the parent container if no fields are visible ---
            const anyFieldVisible = loopCountField.style.display !== 'none' ||
                                  layerNameField.style.display !== 'none' ||
                                  customEventNameField.style.display !== 'none' ||
                                  tweenedDurationField.style.display !== 'none' ||
                                  tweenedEasingField.style.display !== 'none';

            dynamicInteractionFields.style.display = anyFieldVisible ? 'block' : 'none';
        }


        function openConnectionEditorModal(connectionData) {
            // --- FIX: Work on a temporary copy of the connection data ---
            selectedConnectionForEdit = connectionData; // Keep reference to the original
            tempConnectionData = JSON.parse(JSON.stringify(connectionData)); // Create a deep copy for editing

            connectionModalTitle.textContent = "Transition Settings"; // Rename modal title

            // Populate Transition Type dropdown (and keep disabled)
            populateDropdowns(
                transitionTypeNativeSelect,
                transitionTypeDisplay,
                transitionTypeOptionsContainer,
                TRANSITION_TYPES,
                tempConnectionData.transitionType || 'Transition', // Use temp data
                false // No longer disabled
            );

            // Populate Interaction Presets dropdown
            populateDropdowns(
                interactionPresetNativeSelect,
                interactionPresetDisplay,
                interactionPresetOptionsContainer,
                INTERACTION_PRESETS,
                tempConnectionData.interactionType // Use temp data
            );

            // Update dynamic fields based on current interaction type
            updateDynamicInteractionFields(tempConnectionData.interactionType, tempConnectionData.interactionDetails || {});

            // NEW: Show/hide tweened fields based on transition type and destination node type
            const toNode = nodes.find(n => n.id === tempConnectionData.toNodeId);
            const isTweenable = tempConnectionData.transitionType === 'Tweened' && toNode?.type !== 'action';

            // Hide transition type dropdown if destination is an action node
            transitionTypeDropdownGroup.style.display = toNode?.type === 'action' ? 'none' : 'flex';


            if (isTweenable) {
                tweenedDurationField.style.display = 'block';
                tweenedEasingField.style.display = 'block';
                tweenedDurationInput.value = tempConnectionData.duration || 0.5;
                tweenedEasingInput.value = (tempConnectionData.easing || [0.42, 0, 0.58, 1]).join(', ');
            } else {
                tweenedDurationField.style.display = 'none';
                tweenedEasingField.style.display = 'none';
            }

            // Explicitly call updateActionsSection here
            updateActionsSection(tempConnectionData);

            connectionEditorModal.style.display = 'flex';
            document.querySelectorAll('.connection-line').forEach(path => {
                path.classList.toggle('selected-connection', path.dataset.connectionId === connectionData.id);
            });
        }

        function closeConnectionEditorModal() {
            connectionEditorModal.style.display = 'none';
            selectedConnectionForEdit = null;
            tempConnectionData = null; // Clear the temporary data
            document.querySelectorAll('.connection-line').forEach(path => {
                path.classList.remove('selected-connection');
            });
        }

        function showCustomConfirm(message, onConfirm) {
            const existingConfirmModal = document.getElementById('custom-confirm-modal');
            if (existingConfirmModal) existingConfirmModal.remove();

            const confirmModal = document.createElement('div');
            confirmModal.id = 'custom-confirm-modal';
            confirmModal.classList.add('modal');
            confirmModal.style.zIndex = '1003';
            confirmModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header"><h2>Confirmation</h2><span class="close-button">&times;</span></div>
                    <div class="modal-body"><p>${message}</p></div>
                    <div class="modal-footer" style="justify-content: flex-end; gap: 10px;">
                        <button class="cancel" style="margin-right: 10px;">Cancel</button>
                        <button class="save">Confirm</button>
                    </div>
                </div>`;
            document.body.appendChild(confirmModal);
            confirmModal.style.display = 'flex';
            const confirmButton = confirmModal.querySelector('.save');
            const cancelButton = confirmModal.querySelector('.cancel');
            const closeButton = confirmModal.querySelector('.close-button');

            const closeConfirm = (callback) => {
                confirmModal.style.display = 'none';
                if (callback && typeof callback === 'function') {
                    callback();
                }
                confirmModal.remove();
            };

            confirmButton.onclick = () => { onConfirm(); closeConfirm(); };
            cancelButton.onclick = () => closeConfirm(arguments[2]); // Pass the onCancel callback
            closeButton.onclick = () => closeConfirm(arguments[2]);
            confirmModal.addEventListener('click', (e) => { if (e.target === confirmModal) closeConfirm(arguments[2]); });
        }
        // --- End Modal Functions ---

        // --- NEW: Text Truncation Helper ---
        function truncateText(text, maxLength) {
            if (text.length > maxLength) {
                return text.substring(0, maxLength) + '...';
            }
            return text;
        }

        // --- Custom Alert Function ---
        function showCustomAlert(message) {
            customAlertMessage.textContent = message;
            customAlertOverlay.style.display = 'flex';
        }
        customAlertOkButton.addEventListener('click', () => {
            customAlertOverlay.style.display = 'none';
        });
        // --- End Custom Alert Function ---


        // --- NEW: Functions for Global State, Guards, and Actions ---

           function addOrShowGlobalStateNode() {
            if (globalState) {
                openGlobalStateModal();
                return;
            }
            globalState = {
                id: 'global_state_node',
                name: 'myVariable',
                type: 'Numeric',
                initialValue: 0,
                x: -panOffsetX + 50,
                y: -panOffsetY + 50,
            };
            const el = createGlobalStateElement(globalState);
            canvasContainer.appendChild(el);
            fitCanvasToNodesMinimally();
            openGlobalStateModal();
        }

        function openGlobalStateModal() {
            // --- NEW: Handle active state ---
            // 1. Deactivate all regular nodes
            nodes.forEach(n => n.isActive = false);
            updateNodeStyles();
            // 2. Add .active class to the global state node
            const globalNodeEl = document.getElementById('global_state_node');
            if (globalNodeEl) {
                globalNodeEl.classList.add('active');
            }
            // --- END NEW ---

            // Append the global state properties to the preview window if not already there
            if (!statePreviewWindow.contains(globalStatePropertiesContainer)) {
                statePreviewWindow.appendChild(globalStatePropertiesContainer);
            }

            // NEW: Show the global state panel and hide the node properties panel
            nodePropertiesModal.style.display = 'none';
            actionNodePropertiesContainer.style.display = 'none'; // FIX: Hide action node panel
            globalStatePropertiesContainer.style.display = 'flex';
            if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

            if (!globalState) return;
            globalStateNameInput.value = globalState.name;
            globalStateValueInput.value = globalState.initialValue;

            // --- NEW: Show/hide correct initial value control ---
            if (globalState.type === 'Boolean') {
                globalStateValueInputContainer.style.display = 'none';
                globalStateValueToggleSwitch.style.display = 'inline-block';
                globalStateValueToggle.checked = (globalState.initialValue === 'true' || globalState.initialValue === true);
            } else { // Numeric or String
                globalStateValueInputContainer.style.display = 'inline-block';
                globalStateValueToggleSwitch.style.display = 'none';
            }

            // Populate type dropdown
            const typeOptions = [{ id: 'Numeric', name: 'Numeric' }, { id: 'Boolean', name: 'Boolean' }];
            globalStateTypeDropdownGroup.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                    <label for="global-state-type-select">Variable Type</label>
                    <div class="custom-dropdown-container">
                        <div class="custom-dropdown-display" data-target-select="global-state-type-select"></div>
                        <div class="custom-dropdown-options"></div>
                        <select id="global-state-type-select" style="display: none;"></select>
                    </div>
                </div>
                <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;
            
            const display = globalStateTypeDropdownGroup.querySelector('.custom-dropdown-display');
            const optionsContainer = globalStateTypeDropdownGroup.querySelector('.custom-dropdown-options');
            const nativeSelect = globalStateTypeDropdownGroup.querySelector('select');
            
            populateDropdowns(nativeSelect, display, optionsContainer, typeOptions, globalState.type);

            // Dropdown event handling - This is the definitive fix.
            globalStateTypeDropdownGroup.onclick = (e) => { e.stopPropagation(); optionsContainer.classList.toggle('open'); };
            optionsContainer.onclick = (e) => {
                const option = e.target.closest('.custom-dropdown-option');
                if (option) {
                    e.stopPropagation(); // Stop the event here, AFTER we confirm an option was clicked.
                    nativeSelect.value = option.dataset.value;
                    display.textContent = option.textContent;
                    // --- FIX: Update the 'selected' class ---
                    optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    optionsContainer.classList.remove('open');
                    updateGlobalStateFromUI(); // Update instantly on type change
                    openGlobalStateModal(); // Re-run to show/hide the correct input control
                    redrawAll(); // Redraw connections to update any dependent text
                }
            };
        }

        function saveGlobalState() {
            if (!globalState) return;
            const newName = globalStateNameInput.value.trim();
            if (!newName) {
                showCustomAlert("Variable name cannot be empty.");
                return;
            }
            globalState.name = newName;
            globalState.type = document.getElementById('global-state-type-select').value;
            // --- NEW: Get value from the correct control ---
            if (globalState.type === 'Boolean') {
                globalState.initialValue = globalStateValueToggle.checked;
            } else {
                globalState.initialValue = globalStateValueInput.value;
            }

            // Update visual element
            const el = document.getElementById('global_state_node');
            if (el) {
                el.querySelector('div:nth-child(1)').textContent = globalState.name;
                el.querySelector('div:nth-child(2)').textContent = `(${globalState.type})`;
                el.querySelector('div:nth-child(3)').textContent = `Value: ${globalState.initialValue}`;
            }
            // Hide the panel after saving
            if (!statePreviewWindow.classList.contains('hidden')) {
                previewToggleButton.click();
            }
        }

        // NEW: Central function for live updates from the UI
        function updateGlobalStateFromUI() {
            if (!globalState) return;

            const newName = globalStateNameInput.value.trim();
            if (!newName) return; // Don't update if name is empty

            globalState.name = newName;
            const oldType = globalState.type;
            const newTypeFromSelect = document.getElementById('global-state-type-select').value;

            // --- MODIFIED: Add confirmation before resetting nodes ---
            const hasActionNodes = nodes.some(node => node.type === 'action');
            if (oldType && oldType !== newTypeFromSelect && hasActionNodes) {
                showCustomConfirm(
                    "Changing the variable type will reset all Action Nodes. Do you want to continue?",
                    () => {
                        // User confirmed. Proceed with the change.
                        globalState.type = newTypeFromSelect;
                        nodes.forEach(node => {
                            if (node.type === 'action') {
                                node.action = null; // Reset the action data
                                const actionNodeElement = document.getElementById(node.id);
                                if (actionNodeElement) {
                                   updateActionNodeVisual(actionNodeElement.querySelector('.node'), node); // Update the visual display
                                }
                            }
                        });
                        if (oldType === 'Boolean' && newTypeFromSelect === 'Numeric') {
                            globalState.initialValue = 0;
                        }
                        openGlobalStateModal(); // Refresh the modal with the new type
                    },
                    () => {
                        // User canceled. Revert the dropdown.
                        openGlobalStateModal(); // This will repopulate the dropdown with the old `globalState.type`
                    }
                );
                return; // Stop further execution of this function until user responds
            }
            // --- END MODIFIED ---
            globalState.type = newTypeFromSelect;

            // If switching from Boolean to Numeric, reset the value to 0.
            if (oldType === 'Boolean' && newTypeFromSelect === 'Numeric') {
                globalState.initialValue = 0;
                globalStateValueInput.value = 0;
            }

            // --- NEW: Get value from the correct control ---
            if (globalState.type === 'Boolean') {
                globalState.initialValue = globalStateValueToggle.checked;
            } else {
                globalState.initialValue = globalStateValueInput.value;
            }

            const el = document.getElementById('global_state_node');
            if (el) {
                el.querySelector('.global-state-name-display').textContent = truncateText(globalState.name, 12);
                // --- MODIFIED: Change boolean text ---
                if (globalState.type === 'Boolean') { // Use innerHTML to render styled text
                    const boolValue = (globalState.initialValue === true || globalState.initialValue === 'true');
                    el.querySelector('.global-state-value-display').innerHTML = `Starts ${boolValue ? '<strong style="color: #28a745;">true</strong>' : '<strong style="color: #dc3545;">false</strong>'}`;
                } else { // Use textContent for plain text
                    el.querySelector('.global-state-value-display').textContent = `Starts with: ${globalState.initialValue}`;
                }
                // --- END MODIFIED ---
            }
            redrawAll(); // Redraw to update connection text pills
        }

        // NEW: Function to delete the global state
        function deleteGlobalState() {
            if (!globalState) return;

            // Remove the visual element
            const el = document.getElementById('global_state_node');
            if (el) el.remove();

            // Clear the data
            globalState = null;
            guardConnections = [];

            // --- NEW: Reset all Action Nodes ---
            // Find all action nodes and reset their action property and visual state.
            nodes.forEach(node => {
                if (node.type === 'action') {
                    node.action = null; // Reset the action data
                    const actionNodeElement = document.getElementById(node.id);
                    if (actionNodeElement) {
                        updateActionNodeVisual(actionNodeElement, node); // Update the visual display
                    }
                }
            });

            // Close the panel and redraw
            closeNodePropertiesModal(); // This closes the side panel
            redrawAll();
            showCustomAlert("Global variable has been deleted.");
        }

        function addGuardConnection(fromId, toId) {
            if (fromId !== 'global_state_node' || !nodes.some(n => n.id === toId)) return;
            if (guardConnections.some(gc => gc.toNodeId === toId)) {
                showCustomAlert("This state already has a guard condition.");
                return;
            }
            const newGuardConn = {
                id: `guard_${generateId()}`,
                fromNodeId: fromId,
                toNodeId: toId,
                condition: 'Equal', // Default
                value: globalState.type === 'Boolean' ? 'true' : '0', // Default
            };
            guardConnections.push(newGuardConn);
            redrawAll(); // Redraw to show the new connection
            // Do not open the modal immediately. The user can click the connection to edit it.
            // openGuardConditionModal(newGuardConn); 
        }

        function deleteGuardConnection(id) {
            guardConnections = guardConnections.filter(gc => gc.id !== id);
            guardConditionModal.style.display = 'none';
            redrawAll();
        }

        function getConditionOptionsForType(type) {
            if (type === 'Numeric') return [{id: 'Equal', name: 'is equal to'}, {id: 'NotEqual', name: 'is not equal to'}, {id: 'GreaterThan', name: 'is greater than'}, {id: 'LessThan', name: 'is less than'}];
            if (type === 'Boolean') return [{id: 'Equal', name: 'is'}, {id: 'NotEqual', name: 'is not'}];
            if (type === 'String') return [{id: 'Equal', name: 'is equal to'}, {id: 'NotEqual', name: 'is not equal to'}];
            return [];
        }

        function createGlobalStateElement(stateData) {
            const el = document.createElement('div');
            el.id = stateData.id;
            el.classList.add('global-state-node');
            el.style.left = `${stateData.x}px`;
            el.style.top = `${stateData.y}px`;

            // --- MODIFIED: Change boolean text ---
            let valueText = `Starts with: ${stateData.initialValue}`;
            if (stateData.type === 'Boolean') {
                const boolValue = (stateData.initialValue === true || stateData.initialValue === 'true'); // Use innerHTML to render styled text
                valueText = `Starts ${boolValue ? '<strong style="color: #28a745;">true</strong>' : '<strong style="color: #dc3545;">false</strong>'}`;
            }
            el.innerHTML = `<div style="margin-bottom: 20px;">
                <div class="global-state-name-display" style="font-weight: bold; margin-bottom: 2px; color: #89562b;">${truncateText(stateData.name, 25)}</div>
                <div class="global-state-value-display" style="font-size: 12px; color: #555; margin-top: 2px;">${valueText}</div> <!-- This will now correctly render the HTML -->
            </div>`;

            let hasDragged = false; // NEW: Flag to distinguish drag from click

            el.addEventListener('click', (e) => {
                // If the click is on the port, do nothing here. The port has its own listener.
                if (e.target.classList.contains('node-port')) return;
                // NEW: If a drag just happened, don't open the modal.
                if (hasDragged) return;

                e.stopPropagation();
                openGlobalStateModal();
            });

            // Add the connection port
            const port = document.createElement('div');
            port.classList.add('node-port');
            port.style.left = '36.5%'; // Center based on parent, transform will adjust
            port.style.top = 'calc(50% + 14px)'; // Moved down
            port.style.width = '26px';
            port.style.height = '26px';
            port.style.borderRadius = '20px';
           port.style.backgroundColor = '#d2691e';
            port.dataset.nodeId = stateData.id;
            port.dataset.portType = 'bottom'; // Logical type
            port.innerHTML = '<i class="fas fa-link" style="font-size: 8px; color: white;"></i>'; // Add icon
            el.appendChild(port);

            // --- NEW: Drag-to-connect for Guard Connections ---
            port.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (isConnecting || isCreatingGuardConnection) return; // Prevent starting a new connection while another is in progress

                isCreatingGuardConnection = true;
                el.classList.add('selected-for-connection');

                // Define the fixed start coordinates for the ghost line from the global node's center
                const startCoords = {
                    x: globalState.x + 60, 
                    y: globalState.y + 93  // 50% (60px) + 25px offset + 8px half-port-size
                };

                // Immediately draw the ghost line to the current cursor position
                const canvasRect = canvasContainer.getBoundingClientRect();
                const initialEndCoords = {
                    x: e.clientX - canvasRect.left,
                    y: e.clientY - canvasRect.top
                };
                drawGuardGhostLine(startCoords, initialEndCoords);

                const onDragEnd = (upEvent) => {
                    // Check if the mouse is released over a valid target node
                    const targetNodeWrapper = upEvent.target.closest('.node-wrapper');
                    if (targetNodeWrapper) {
                        const targetNodeData = nodes.find(n => n.id === targetNodeWrapper.id);
                        if (targetNodeData && targetNodeData.type === 'action') {
                            // It's an action node, so we should not allow the connection.
                            showCustomAlert("Cannot create a conditional transition to an Action Node.");
                        } else {
                            // It's a regular state node, allow the connection.
                            addGuardConnection('global_state_node', targetNodeWrapper.id);
                        }
                    }

                    // Cleanup: End guard connection mode and remove listeners
                    isCreatingGuardConnection = false;
                    el.classList.remove('selected-for-connection');
                    drawGuardGhostLine(null, null); // Hide ghost line
                    document.removeEventListener('mouseup', onDragEnd);
                };

                // Add a one-time mouseup listener to the document to handle release
                document.addEventListener('mouseup', onDragEnd, { once: true });
            });
            // --- END OF NEW SEGREGATED LOGIC ---

            // Dragging logic
            let isDragging = false, offsetX, offsetY, startX, startY;
            el.addEventListener('mousedown', e => {
                // Only start drag if not clicking the port
                if (e.target.closest('.global-state-node') && !e.target.classList.contains('node-port')) {
                    isDragging = true;
                    el.style.cursor = 'grabbing';
                    offsetX = e.clientX - el.getBoundingClientRect().left;
                    offsetY = e.clientY - el.getBoundingClientRect().top;
                    startX = e.clientX; // Store initial mouse position
                    startY = e.clientY;
                    hasDragged = false; // Reset drag flag on new mousedown
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', e => { 
                if(isDragging) { 
                    // NEW: If mouse moves more than a few pixels, consider it a drag
                    if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
                        hasDragged = true;
                    }
                    globalState.x = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX; globalState.y = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY; el.style.left = `${globalState.x}px`; el.style.top = `${globalState.y}px`; 
                    // Throttled redraw using requestAnimationFrame
                    if (!isRedrawQueued) {
                        isRedrawQueued = true;
                        requestAnimationFrame(() => {
                            redrawAll();
                            isRedrawQueued = false;
                        });
                    }
                }
            });
            document.addEventListener('mouseup', () => { if(isDragging) { isDragging = false; el.style.cursor = 'grab'; fitCanvasToNodesMinimally(); setTimeout(() => { hasDragged = false; }, 0); }});

            return el;
        }

        // --- Helper function to determine if a path is "naturally" C-shaped ---
        // This heuristic checks for the 6-point C-shape pattern generated by the
        // default router when a detour (C_DETOUR_OFFSET) is involved.
        function isPathNaturallyCShape(pathPoints, connection, fromNode, toNode) {
            if (pathPoints.length !== 6) {
                // console.log(`isPathNaturallyCShape for ${connection.id}: Path length is not 6, returning false.`);
                return false;
            }

            const p1_coord = pathPoints[0];
            const p2_stub_from_p1 = pathPoints[1];
            const mid1 = pathPoints[2];
            const mid2 = pathPoints[3];
            const p3_stub_to_p_end = pathPoints[4]; // This is the stub leading to the target port
            // const p_end_coord = pathPoints[5]; // Not directly used in this heuristic for now

            const fromPortType = connection.fromPortType;

            // Validate p2_stub_from_p1 based on ROUTING_STUB
            let expected_p2_x = p1_coord.x, expected_p2_y = p1_coord.y;
            if (fromPortType === 'left') expected_p2_x -= ROUTING_STUB;
            else if (fromPortType === 'right') expected_p2_x += ROUTING_STUB;
            else if (fromPortType === 'top') expected_p2_y -= ROUTING_STUB;
            else if (fromPortType === 'bottom') expected_p2_y += ROUTING_STUB;

            const isP2StubApproximatelyCorrect = (Math.abs(p2_stub_from_p1.x - expected_p2_x) < 1 && Math.abs(p2_stub_from_p1.y - expected_p2_y) < 1);

            if (!isP2StubApproximatelyCorrect) {
                // console.log(`isPathNaturallyCShape for ${connection.id}: p2_stub not as expected, returning false.`);
                return false;
            }

            // Check the C-shape detour pattern
            let cDetourPatternMatched = false;
            if (fromPortType === 'left' || fromPortType === 'right') {
                // For horizontal ports, the detour is vertical:
                // mid1.x should align with p2_stub_from_p1.x
                // mid2.x should align with p3_stub_to_p_end.x
                // mid1.y should be equal to mid2.y (this is the detour level)
                if (Math.abs(mid1.x - p2_stub_from_p1.x) < 1 &&
                    Math.abs(mid2.x - p3_stub_to_p_end.x) < 1 &&
                    Math.abs(mid1.y - mid2.y) < 1) {
                    // Check if the Y detour is significant, implying C_DETOUR_OFFSET was used
                    const yMidPointOfStubs = (p2_stub_from_p1.y + p3_stub_to_p_end.y) / 2;
                    if (Math.abs(mid1.y - yMidPointOfStubs) > ROUTING_STUB * 1.5) { // Heuristic: detour is larger than 1.5x stub
                        cDetourPatternMatched = true;
                    }
                }
            } else { // 'top' or 'bottom'
                // For vertical ports, the detour is horizontal:
                // mid1.y should align with p2_stub_from_p1.y
                // mid2.y should align with p3_stub_to_p_end.y
                // mid1.x should be equal to mid2.x (this is the detour level)
                if (Math.abs(mid1.y - p2_stub_from_p1.y) < 1 &&
                    Math.abs(mid2.y - p3_stub_to_p_end.y) < 1 &&
                    Math.abs(mid1.x - mid2.x) < 1) {
                    const xMidPointOfStubs = (p2_stub_from_p1.x + p3_stub_to_p_end.x) / 2;
                    if (Math.abs(mid1.x - xMidPointOfStubs) > ROUTING_STUB * 1.5) { // Heuristic
                        cDetourPatternMatched = true;
                    }
                }
            }
            // if (cDetourPatternMatched) {
            //     console.log(`%cDEBUG: isPathNaturallyCShape for ${connection.id} detected NATURAL C-SHAPE. Points:`, JSON.parse(JSON.stringify(pathPoints)), "FromNode:", fromNode.name, "ToNode:", toNode.name);
            // } else {
            //     console.log(`DEBUG: isPathNaturallyCShape for ${connection.id} did NOT detect natural C-shape. Points:`, JSON.parse(JSON.stringify(pathPoints)), "FromNode:", fromNode.name, "ToNode:", toNode.name);
            // }
            return cDetourPatternMatched;
        }

        // --- NEW: Master drawing function ---
        function redrawAll() {
            connectionSvg.innerHTML = '';
            // Re-add ghost elements first to ensure they are at the bottom of the SVG z-index
            connectionSvg.appendChild(ghostConnectionLine);
            connectionSvg.appendChild(ghostConnectionArrow);

            drawConnections();
            drawGuardConnections();
        }


        async function drawConnections() {
            // This function now ONLY draws regular state-to-state connections.

            const nodePortConnectionsMap = {};
            connections.forEach(conn => {
                if ((conn.fromPortType === 'top' || conn.fromPortType === 'bottom') ||
                    (conn.toPortType === 'top' || conn.toPortType === 'bottom')) {
                    // console.warn(`Skipping drawing connection ${conn.id} as it uses a disabled port type.`);
                    return;
                }

                if (!nodePortConnectionsMap[conn.fromNodeId]) nodePortConnectionsMap[conn.fromNodeId] = {};
                if (!nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType]) nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType] = { outgoing: [], incoming: [] };
                nodePortConnectionsMap[conn.fromNodeId][conn.fromPortType].outgoing.push(conn);

                if (!nodePortConnectionsMap[conn.toNodeId]) nodePortConnectionsMap[conn.toNodeId] = {};
                if (!nodePortConnectionsMap[conn.toNodeId][conn.toPortType]) nodePortConnectionsMap[conn.toNodeId][conn.toPortType] = { outgoing: [], incoming: [] };
                nodePortConnectionsMap[conn.toNodeId][conn.toPortType].incoming.push(conn);
            });

            const activeNode = nodes.find(n => n.isActive);

            connections.forEach(conn => {
                 if ((conn.fromPortType === 'top' || conn.fromPortType === 'bottom') ||
                    (conn.toPortType === 'top' || conn.toPortType === 'bottom')) {
                    return;
                }
                const fromNode = nodes.find(n => n.id === conn.fromNodeId);
                const toNode = nodes.find(n => n.id === conn.toNodeId);

                if (fromNode && toNode) {
                    let actualForceCShapeForThisDraw = conn.forceCShape; // Start with the stored property

                    // Check for paired connection and adjust actualForceCShapeForThisDraw
                    const pairedConnection = connections.find(pConn =>
                        pConn.fromNodeId === conn.toNodeId && pConn.toNodeId === conn.fromNodeId
                    );

                    if (pairedConnection) { // This connection is part of a loop
                        if (conn.forceCShape === true) {
                            // This 'conn' is the one initially designated to be C-shaped.
                            // Let's check its pair's natural shape.
                            const pairedFromNode = toNode; // Pair's fromNode is current conn's toNode
                            const pairedToNode = fromNode;   // Pair's toNode is current conn's fromNode

                            const pairedPathPoints = calculateOrthogonalPathPoints(
                                pairedConnection,
                                pairedFromNode,
                                pairedToNode,
                                nodePortConnectionsMap, // Use the full map for correct indexing
                                false // Calculate natural path for the pair
                            );

                            if (isPathNaturallyCShape(pairedPathPoints, pairedConnection, pairedFromNode, pairedToNode)) {
                                // If the 'paired' connection (which should be straight) is NATURALLY C-shaped,
                                // then this 'conn' (originally forced C) should become straight.
                                // console.log(`%cLoop Logic SWAP: Paired ${pairedConnection.id} is naturally C. ${conn.id} becomes STRAIGHT.`, "color: blue;");
                                actualForceCShapeForThisDraw = false;
                            } else {
                                // If the 'paired' connection is straight, this 'conn' remains forced C.
                                // console.log(`%cLoop Logic KEEP: Paired ${pairedConnection.id} is straight. ${conn.id} remains C-FORCED.`, "color: green;");
                                actualForceCShapeForThisDraw = true; // Explicitly set to true
                            }
                        } else {
                            // This 'conn' is the one initially designated to be straight in the loop.
                            // It should always be drawn with its natural path (unless its partner becomes C-shaped naturally,
                            // in which case this 'conn' might need to become C if its partner's C is not ideal - this part is complex
                            // and the current logic simplifies it to: the conn.forceCShape=false one is always natural).
                            // For now, we keep it simple: the one not marked forceCShape is always drawn naturally.
                            actualForceCShapeForThisDraw = false;
                        }
                    }
                    // If not part of a pair, actualForceCShapeForThisDraw just remains conn.forceCShape

                    const uniquePathPoints = calculateOrthogonalPathPoints(
                        conn,
                        fromNode,
                        toNode,
                        nodePortConnectionsMap,
                        actualForceCShapeForThisDraw // Use the dynamically determined value
                    );

                    if (uniquePathPoints.length < 2) {
                        // console.warn("Path has less than 2 unique points for drawing:", conn.id, uniquePathPoints);
                        return;
                    }

                    // Generate the full path string with rounded corners
                    const d_str_full_rounded = getRoundedPathD(uniquePathPoints, ConnectionCornerRadius);

                    // Create a temporary path element to get total length
                    const tempPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempPathElement.setAttribute('d', d_str_full_rounded);
                    // connectionSvg.appendChild(tempPathElement); // Temporarily add to DOM to get length - NO, causes flicker

                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', d_str_full_rounded); // Always set the full rounded path
                    pathElement.classList.add('connection-line');
                    pathElement.dataset.connectionId = conn.id;

                    // Apply stroke-dasharray and stroke-dashoffset for visual truncation
                    // Must append to SVG to get total length correctly
                    connectionSvg.appendChild(pathElement);
                    const totalLength = pathElement.getTotalLength(); // Get length after appending
                    const desiredLength = Math.max(0, totalLength - 6); // End the line 6px before the tip
                    pathElement.style.strokeDasharray = totalLength;
                    pathElement.style.strokeDashoffset = totalLength - desiredLength; // This creates the gap


                    if (activeNode && conn.fromNodeId === activeNode.id) {
                        pathElement.classList.add('active-connection');
                    }

                    // Arrow tip and direction now use the full path's end point (p4_coord from uniquePathPoints)
                    const arrowTip = uniquePathPoints[uniquePathPoints.length - 1];
                    const preArrowTip = uniquePathPoints[uniquePathPoints.length - 2];

                    if (!preArrowTip) {
                        // console.warn("Could not determine preArrowTip for arrow:", conn.id, uniquePathPoints);
                        if (uniquePathPoints.length === 1) {
                            // preArrowTip = { x: arrowTip.x - 1, y: arrowTip.y }; // Arbitrary point for direction
                        } else {
                            return;
                        }
                    }

                    const dx_arrow = arrowTip.x - preArrowTip.x;
                    const dy_arrow = arrowTip.y - preArrowTip.y;

                    const angle = Math.atan2(dy_arrow, dx_arrow);
                    const arrowSize = 12; /* Made arrowhead slightly bigger */
                    const arrowWingAngle = Math.PI / 7;

                    let finalArrowYOffset = 0;
                    // Apply ARROW_Y_OFFSET only if the line segment is primarily horizontal
                    if (Math.abs(dx_arrow) > Math.abs(dy_arrow)) {
                        finalArrowYOffset = ARROW_Y_OFFSET;
                    }

                    const arrowX1 = arrowTip.x - arrowSize * Math.cos(angle - arrowWingAngle);
                    const arrowY1 = arrowTip.y - arrowSize * Math.sin(angle - arrowWingAngle) + finalArrowYOffset;
                    const arrowX2 = arrowTip.x - arrowSize * Math.cos(angle + arrowWingAngle);
                    const arrowY2 = arrowTip.y - arrowSize * Math.sin(angle + arrowWingAngle) + finalArrowYOffset;

                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // A path for a sharp, filled arrowhead
                    const d = `M ${arrowTip.x},${arrowTip.y + finalArrowYOffset} L ${arrowX1},${arrowY1} L ${arrowX2},${arrowY2} Z`;
                    arrow.setAttribute('d', d);
                    arrow.setAttribute('fill', '#3498db'); // Match line color
                    arrow.style.pointerEvents = 'none';

                    arrow.style.opacity = '1.0'; /* Make arrow fully opaque */
                    connectionSvg.appendChild(arrow);


                    // Text positioning: Calculate position on the VISIBLE path based on ConnectionTextPositionPercentage
                    // Use the actual pathElement that's in the DOM for getPointAtLength
                    const textAnchorPoint = pathElement.getPointAtLength(desiredLength * (ConnectionTextPositionPercentage / 100));


                    const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    textGroup.dataset.connectionId = conn.id; textGroup.classList.add('connection-text-group');
                    // Use the calculated point for positioning
                    textGroup.setAttribute('transform', `translate(${textAnchorPoint.x}, ${textAnchorPoint.y})`);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.classList.add('connection-text');

                    // --- MODIFIED: Display interaction type on the connection line ---
                    const preset = INTERACTION_PRESETS.find(p => p.id === conn.interactionType);
                    let connectionTextContent = preset?.shortName || preset?.name || conn.interactionType;
                    if (conn.interactionType === 'OnLoopComplete') {
                        connectionTextContent = `Loops: ${conn.interactionDetails.loopCount || 1}`;
                    } else if (conn.interactionType.startsWith('onPointer')) { // Keep layerName for pointer events
                        connectionTextContent = `${preset?.shortName || preset?.name || conn.interactionType}${conn.interactionDetails.layerName ? ': '+conn.interactionDetails.layerName : ''}`;
                    } else if (conn.interactionType === 'onClick') { // Simplify for 'onClick'
                        connectionTextContent = 'Click';
                    } else if (conn.interactionType === 'CustomEvent') {
                        connectionTextContent = `Event: ${conn.interactionDetails.customEventName || 'N/A'}`;
                    } else if (conn.interactionType === 'Direct') {
                         connectionTextContent = 'Direct';
                    }

                    // --- NEW: Add visual indicator for actions ---
                    if (conn.action && globalState) {
                        let actionText = '';
                        switch (conn.action.type) {
                            case 'Increment':
                                actionText = ` |  +${conn.action.value || 1}`;
                                break;
                            case 'Decrement':
                                actionText = ` |  -${conn.action.value || 1}`;
                                break;
                            case 'SetNumeric':
                            case 'SetBoolean':
                                actionText = ` |  ${conn.action.value}`;
                                break;
                            case 'SetString':
                                actionText = ` |  '${conn.action.value}'`;
                                break;
                            case 'Toggle':
                                actionText = ' | ';
                                break;
                        }
                        connectionTextContent += actionText;
                    }
                    // --- END NEW ---

                    text.textContent = connectionTextContent;
                    // --- END MODIFIED ---

                    textGroup.appendChild(text);

                    connectionSvg.appendChild(textGroup);

                    const textBBox = text.getBBox();
                    const textPadding = 6;
                    const rectWidth = textBBox.width + textPadding * 2;
                    const rectHeight = textBBox.height + textPadding * 2;
                    const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    textBg.setAttribute('x', textBBox.x - textPadding);
                    textBg.setAttribute('y', textBBox.y - textPadding);
                    textBg.setAttribute('width', rectWidth); textBg.setAttribute('height', rectHeight);
                    textBg.classList.add('connection-text-bg'); 
                    textBg.setAttribute('rx', rectHeight / 2); // Make it fully rounded (pill shape)
                    textBg.setAttribute('ry', rectHeight / 2); // Make it fully rounded (pill shape)
                    textGroup.prepend(textBg);

                    pathElement.addEventListener('click', (e) => { e.stopPropagation(); openConnectionEditorModal(conn); });
                    textGroup.addEventListener('click', (e) => { e.stopPropagation(); openConnectionEditorModal(conn); });
                }
            });
        }

        // --- NEW: Segregated function to draw only guard connections ---
        function drawGuardConnections() {
            if (!globalState) return;

            guardConnections.forEach(conn => {
                const fromNode = globalState;
                const toNode = nodes.find(n => n.id === conn.toNodeId);

                if (fromNode && toNode) {
                    // Start point: The center of the global state node
                    const startPoint = {
                        x: fromNode.x + 60,
                        y: fromNode.y + 60
                    };

                    // End point: The center of the target state node
                    const endPoint = {
                        x: toNode.x + (NODE_WIDTH / 2),
                        y: toNode.y + (NODE_HEIGHT / 2)
                    };

                    // --- NEW: Calculate control points for a Bezier curve ---
                    const dx = endPoint.x - startPoint.x;
                    const dy = endPoint.y - startPoint.y;

                    // Control points are placed horizontally from the start/end points
                    // to create a smooth, flowing curve. The offset is a fraction of the horizontal distance.
                    const controlPoint1 = { x: startPoint.x + dx * 0.5, y: startPoint.y };
                    const controlPoint2 = { x: endPoint.x - dx * 0.5, y: endPoint.y };

                    const d_str = `M ${startPoint.x} ${startPoint.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${endPoint.x} ${endPoint.y}`;

                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', d_str);
                    pathElement.classList.add('guard-connection-line');
                    pathElement.dataset.connectionId = conn.id;

                    pathElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openGuardConditionModal(conn);
                    });

                    connectionSvg.appendChild(pathElement);

                    // --- NEW: Add text pill for the guard condition ---
                    const textPosition = pathElement.getPointAtLength(pathElement.getTotalLength() * 0.5);

                    const textGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    textGroup.dataset.connectionId = conn.id;
                    textGroup.setAttribute('transform', `translate(${textPosition.x}, ${textPosition.y})`);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.classList.add('guard-connection-text');

                    // Get human-readable condition text
                    const conditionOptions = getConditionOptionsForType(fromNode.type);
                    const conditionText = conditionOptions.find(opt => opt.id === conn.condition)?.name || conn.condition;
                    text.textContent = `${conditionText} ${conn.value}`;

                    // Temporarily append to measure BBox for background rect
                    textGroup.appendChild(text);
                    connectionSvg.appendChild(textGroup);

                    const textBBox = text.getBBox();
                    const textPadding = 6;
                    const rectWidth = textBBox.width + textPadding * 2;
                    const rectHeight = textBBox.height + textPadding * 2;
                    const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    textBg.setAttribute('x', textBBox.x - textPadding);
                    textBg.setAttribute('y', textBBox.y - textPadding);
                    textBg.setAttribute('width', rectWidth);
                    textBg.setAttribute('height', rectHeight);
                    textBg.classList.add('guard-connection-text-bg');

                    textGroup.prepend(textBg); // Prepend so it's behind the text

                    // Add click listener to the group as well
                    textGroup.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openGuardConditionModal(conn);
                    });
                    // --- END NEW TEXT PILL ---
                }
            });
        }

        // Function to draw the ghost line and arrow
        function drawGhostLine(fromNodeId, fromPortType, mouseX, mouseY) {
            if (!isConnecting || !firstNodeSelected) {
                ghostConnectionLine.style.display = 'none';
                ghostConnectionArrow.style.display = 'none'; // Arrow is always hidden for ghost line now
                return;
            }

            const sourceNode = nodes.find(n => n.id === fromNodeId);
            if (!sourceNode) return;

            const startPoint = getPortCoordinates(sourceNode, fromPortType);
            let endPoint = { x: mouseX, y: mouseY };

            // Simple straight line for ghost connection
            let d_str = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
            ghostConnectionLine.setAttribute('d', d_str);
            ghostConnectionLine.style.display = 'block';
        }

        // --- NEW: Segregated function for the guard ghost line ---
        function drawGuardGhostLine(startPoint, endPoint) {
            // Use the same ghost-line element, but style it differently
            if (startPoint && endPoint) {
                const d_str = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
                ghostConnectionLine.setAttribute('d', d_str);
                ghostConnectionLine.style.stroke = '#dc3545'; // Solid Red
                ghostConnectionLine.style.strokeDasharray = 'none';
                ghostConnectionLine.style.display = 'block';
                ghostConnectionArrow.style.display = 'none';
            } else {
                // Hide it
                ghostConnectionLine.style.display = 'none';
            }
        }

        function addConnection(fromNodeId, fromPortTypeUserSelected, toNodeId, toPortTypeUserSelected) {
            if (fromPortTypeUserSelected === 'top' || fromPortTypeUserSelected === 'bottom' ||
                toPortTypeUserSelected === 'top' || toPortTypeUserSelected === 'bottom') {
                console.warn('Cannot create connections using top or bottom ports as they are disabled.');
                isConnecting = false; updateModeUI();
                return;
            }
            if (fromNodeId === toNodeId && fromPortTypeUserSelected === toPortTypeUserSelected) {
                 console.warn('Cannot connect a node to its own same port.');
                 isConnecting = false; updateModeUI();
                 return;
            }

            const existingConnectionInThisDirection = connections.some(c =>
                c.fromNodeId === fromNodeId && c.toNodeId === toNodeId
            );

            if (existingConnectionInThisDirection) {
                console.warn(`A connection from node ${fromNodeId} to node ${toNodeId} already exists.`);
                connectionExistsIndicator.style.display = 'block';
                setTimeout(() => { connectionExistsIndicator.style.display = 'none'; }, 3000);
                isConnecting = false; updateModeUI();
                return;
            }

            let finalFromPortType = fromPortTypeUserSelected;
            let finalToPortType = toPortTypeUserSelected;
            let forceCShapeForPath = false;

            const existingReverseConnection = connections.find(c =>
                c.fromNodeId === toNodeId && c.toNodeId === fromNodeId
            );

            if (existingReverseConnection) {
                // A loop is being formed.
                // The new connection (fromNodeId -> toNodeId) should use the opposite ports
                // of what the existingReverseConnection uses on these nodes.

                // Port used by existingReverseConnection on fromNodeId (which is existingReverseConnection.toNodeId)
                const portUsedOnFromNodeByExisting = existingReverseConnection.toPortType;
                // Port used by existingReverseConnection on toNodeId (which is existingReverseConnection.fromNodeId)
                const portUsedOnToNodeByExisting = existingReverseConnection.fromPortType;

                finalFromPortType = getOppositePort(portUsedOnFromNodeByExisting);
                finalToPortType = getOppositePort(portUsedOnToNodeByExisting);

                console.log(`Loop detected. New connection from ${fromNodeId} to ${toNodeId}.`);
                console.log(`  Existing (rev): ${existingReverseConnection.fromNodeId}.${existingReverseConnection.fromPortType} -> ${existingReverseConnection.toNodeId}.${existingReverseConnection.toPortType}`);
                console.log(`  New connection ports forced to: ${fromNodeId}.${finalFromPortType} -> ${toNodeId}.${finalToPortType}`);

                forceCShapeForPath = false; // The new connection (loop back) is initially straight.
                existingReverseConnection.forceCShape = true; // The first connection becomes the C-shape candidate.
            }


            const newConnection = {
                id: generateId(),
                fromNodeId,
                fromPortType: finalFromPortType,
                toNodeId,
                toPortType: finalToPortType,
                transitionType: 'Transition', // Default to standard Transition
                duration: 0.5, // Default duration
                easing: [0.42, 0, 0.58, 1], // Default easing
                interactionType: 'onComplete', // Default interaction preset
                interactionDetails: {}, // Initialize empty object for details
                forceCShape: forceCShapeForPath
            };
            connections.push(newConnection);



            fitCanvasToNodesMinimally();
            isConnecting = false;
            updateModeUI();
        }


        function deleteConnection(connectionId) {
            const deletedConn = connections.find(c => c.id === connectionId);
            connections = connections.filter(conn => conn.id !== connectionId);

            if (deletedConn) {
                // If the deleted connection was part of a loop and was the C-shape candidate,
                // its pair (which is now no longer part of a loop) should revert to not being forced.
                const pairedConnection = connections.find(pConn =>
                    pConn.fromNodeId === deletedConn.toNodeId && pConn.toNodeId === deletedConn.fromNodeId
                );
                if (pairedConnection && deletedConn.forceCShape === true) {
                    pairedConnection.forceCShape = false; // No longer needs to be a C-shape candidate
                    // console.log(`Loop broken by deleting ${deletedConn.id}. Paired connection ${pairedConnection.id} forceCShape reset to false.`);
                }
                 // If the deleted connection was the *straight* one in a loop, its pair (which was C-shape candidate)
                 // should also revert to not being forced C-shape as the loop is broken.
                else if (pairedConnection && deletedConn.forceCShape === false && pairedConnection.forceCShape === true) {
                    pairedConnection.forceCShape = false;
                     // console.log(`Loop broken by deleting ${deletedConn.id}. Paired C-shape candidate ${pairedConnection.id} forceCShape reset to false.`);
                }
            }

            fitCanvasToNodesMinimally();
            connectionEditorModal.style.display = 'none';
            selectedConnectionForEdit = null; updateModeUI();
        }


        canvasContainer.addEventListener('mousedown', startPan);
        connectionSvg.addEventListener('mousedown', startPan);
        function startPan(e) {
            if (e.target.closest('.node') || e.target.closest('.global-state-node') || e.target.classList.contains('connection-line') || e.target.classList.contains('guard-connection-line') || e.target.classList.contains('connection-text-bg')) return;
            
            canvasContainer.style.transition = 'none';
            isPanningCanvas = true;
            lastMouseX = e.clientX; lastMouseY = e.clientY;
            canvasContainer.style.cursor = 'grabbing'; connectionSvg.style.cursor = 'grabbing';
            if (flowchartArea.style.cursor !== 'grabbing') flowchartArea.style.cursor = 'grabbing';
            e.preventDefault(); e.stopPropagation();
        }
        
        flowchartArea.addEventListener('mousemove', (e) => {
            if (isPanningCanvas) {
                let deltaX = e.clientX - lastMouseX, deltaY = e.clientY - lastMouseY;
                let newPanOffsetX = panOffsetX + deltaX, newPanOffsetY = panOffsetY + deltaY;
                const caWidth = canvasContainer.offsetWidth;
                const caHeight = canvasContainer.offsetHeight;
                const faWidth = flowchartArea.offsetWidth;
                const faHeight = flowchartArea.offsetHeight;
                if (caWidth <= faWidth) newPanOffsetX = Math.max(0, Math.min(newPanOffsetX, faWidth - caWidth));
                else newPanOffsetX = Math.max(faWidth - caWidth, Math.min(newPanOffsetX, 0));
                if (caHeight <= faHeight) newPanOffsetY = Math.max(0, Math.min(newPanOffsetY, faHeight - caHeight));
                else newPanOffsetY = Math.max(faHeight - caHeight, Math.min(newPanOffsetY, 0));
                panOffsetX = newPanOffsetX; panOffsetY = newPanOffsetY;
                canvasContainer.style.left = `${panOffsetX}px`; canvasContainer.style.top = `${panOffsetY}px`;
                lastMouseX = e.clientX; lastMouseY = e.clientY;
            } else if (isConnecting && firstNodeSelected) {
                // Get the bounding box of the pannable SVG container.
                const canvasRect = canvasContainer.getBoundingClientRect();
                // Calculate the mouse position relative to the container's top-left corner.
                const svgMouseX = e.clientX - canvasRect.left;
                const svgMouseY = e.clientY - canvasRect.top;
                drawGhostLine(firstNodeSelected.id, firstPortType, svgMouseX, svgMouseY);

                // Handle destination port highlighting
                let hoveredNodeElement = null;
                for (const nodeData of nodes.filter(n => n.type !== 'action')) { // Don't highlight action nodes
                    const nodeElement = document.getElementById(nodeData.id);
                    if (nodeElement && nodeElement !== firstNodeSelected) {
                        const nodeRect = nodeElement.getBoundingClientRect();
                        if (e.clientX >= nodeRect.left && e.clientX <= nodeRect.right &&
                            e.clientY >= nodeRect.top && e.clientY <= nodeRect.bottom) {
                            hoveredNodeElement = nodeElement;
                            break;
                        }
                    }
                }

                if (hoveredNodeElement) {
                    if (currentHoveredDestinationNode && currentHoveredDestinationNode !== hoveredNodeElement) { 
                        currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port'); 
                        currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port'); 
                        if (currentHoveredDestinationNode !== firstNodeSelected) { 
                            currentHoveredDestinationNode.querySelector('.left-port').classList.add('hidden-by-js'); 
                            currentHoveredDestinationNode.querySelector('.right-port').classList.add('hidden-by-js'); 
                        }
                    }
                    currentHoveredDestinationNode = hoveredNodeElement;

                    const nodeRect = hoveredNodeElement.getBoundingClientRect();
                    const clickXRelativeToNode = e.clientX - nodeRect.left;
                    const hoveredPortType = (clickXRelativeToNode < hoveredNodeElement.offsetWidth / 2) ? 'left' : 'right';

                    const leftPort = hoveredNodeElement.querySelector('.left-port');
                    const rightPort = hoveredNodeElement.querySelector('.right-port');

                    leftPort.classList.remove('hidden-by-js'); 
                    rightPort.classList.remove('hidden-by-js'); 
                    leftPort.classList.remove('highlighted-destination-port');
                    rightPort.classList.remove('highlighted-destination-port');

                    if (hoveredPortType === 'left') {
                        leftPort.classList.add('highlighted-destination-port');
                    } else {
                        rightPort.classList.add('highlighted-destination-port');
                    }
                } else {
                    if (currentHoveredDestinationNode) { 
                        currentHoveredDestinationNode.querySelector('.left-port').classList.remove('highlighted-destination-port'); 
                        currentHoveredDestinationNode.querySelector('.right-port').classList.remove('highlighted-destination-port'); 
                        if (currentHoveredDestinationNode !== firstNodeSelected) { 
                            currentHoveredDestinationNode.querySelector('.left-port').classList.add('hidden-by-js'); 
                            currentHoveredDestinationNode.querySelector('.right-port').classList.add('hidden-by-js'); 
                        }
                        currentHoveredDestinationNode = null;
                    }
                }
            } else if (isCreatingGuardConnection && globalState) {
                // --- NEW: Handle ghost line for guard connection drag ---
                const startCoords = { x: globalState.x + 60, y: globalState.y + 93 };
                const canvasRect = canvasContainer.getBoundingClientRect();
                const endCoords = {
                    x: e.clientX - canvasRect.left,
                    y: e.clientY - canvasRect.top
                };
                // --- NEW: Prevent highlighting action nodes as targets ---
                const hoveredTarget = e.target.closest('.node-wrapper');
                if (hoveredTarget) {
                    const targetData = nodes.find(n => n.id === hoveredTarget.id);
                    if (targetData && targetData.type === 'action') {
                        document.body.style.cursor = 'not-allowed';
                    } else { document.body.style.cursor = ''; }
                } else { document.body.style.cursor = ''; }
                drawGuardGhostLine(startCoords, endCoords);
                // --- END NEW ---
            }
        });
        
        flowchartArea.addEventListener('mouseup', () => {
            if (isPanningCanvas) {
                isPanningCanvas = false;
                canvasContainer.style.cursor = 'grab'; connectionSvg.style.cursor = 'grab';
                if (flowchartArea.style.cursor !== 'default') flowchartArea.style.cursor = 'default';
                drawConnections(); 
                document.body.style.cursor = 'default'; // Reset cursor on mouse up
            }
        });
        
        flowchartArea.addEventListener('mouseleave', () => {
            if (isPanningCanvas) {
                isPanningCanvas = false;
                canvasContainer.style.cursor = 'grab';
                connectionSvg.style.cursor = 'grab';
                if (flowchartArea.style.cursor !== 'default') flowchartArea.style.cursor = 'default';
                drawConnections();
            }
        });

        // Function to close all custom dropdowns
        function closeAllCustomDropdowns() {
            document.querySelectorAll('.custom-dropdown-options.open').forEach(options => {
                options.classList.remove('open');
            });
        }

        // --- New Function: Clear Flowchart ---
        function clearFlowchart() {
            // Remove all node elements from canvasContainer
            const nodeElements = canvasContainer.querySelectorAll('.node-wrapper');
            nodeElements.forEach(nodeEl => nodeEl.remove());

            // Clear internal data arrays
            nodes = [];
            connections = [];

            // Reset global state related to flowchart elements
            selectedNodeForEdit = null;
            selectedConnectionForEdit = null;
            firstNodeSelected = null;
            currentHoveredDestinationNode = null;
            isConnecting = false;

            // Call redrawAll to clear the SVG visually
            redrawAll();

            // Reset UI modes
            updateModeUI();

            // Reset pan and canvas size to default or minimal
            panOffsetX = 0;
            panOffsetY = 0;
            canvasContainer.style.left = '0px';
            canvasContainer.style.top = '0px';
            fitCanvasToNodesMinimally(); // This will set to default empty canvas size
        }

        // --- New Function: Find Initial Node ID for Export ---
        function findInitialNodeId() {
          const initialNode = nodes.find(n => n.isInitial);
            if (initialNode) {
                return initialNode.name; // Return the name of the explicitly initial node
            }
            const activeNode = nodes.find(n => n.isActive);
            if (activeNode) {
                return activeNode.name;
            }
            if (nodes.length > 0) {
                return nodes[0].name; // Fallback to the first node if none are active
            }
            return null; // Or a default string like 'default_initial_state'
        }


        window.addEventListener('load', async() => {
            // --- NEW: Set the CSS custom property from the global JS variable ---
            document.documentElement.style.setProperty('--node-hover-padding', `${NODE_HOVER_AREA_PERCENTAGE}%`);
            // --- END NEW ---

            // --- NEW: Initialize and set up the global animation dropdown ---
            populateGlobalAnimationDropdown();

            globalAnimationControls.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = globalAnimationOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    globalAnimationOptionsContainer.classList.add('open');
                }
            });

            globalAnimationOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const selectedOption = e.target.closest('.custom-dropdown-option');
                if (selectedOption) {
                    const newAnimationId = selectedOption.dataset.value;
                    globalAnimationNativeSelect.value = newAnimationId;
                    globalAnimationDisplay.textContent = selectedOption.textContent;

                    globalAnimationOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    globalAnimationOptionsContainer.classList.remove('open');

                    // This is the key part: update the global state and all nodes
                    setGlobalAnimation(newAnimationId);
                }
            });
            // --- END NEW ---


            // Initialize DotLottie player for the modal preview
            modalDotLottiePlayer = new DotLottie({
                canvas: modalLottieCanvas,
                loop: true,
                autoplay: true,
                speed: 1.0
            });


            addNode(); // Add initial node or start blank if preferred

            flowchartArea.style.cursor = 'default';
            canvasContainer.style.cursor = 'grab'; connectionSvg.style.cursor = 'grab';
            canvasContainer.style.transition = 'none';

            // --- Event Listeners ---

            // NEW: Initial Node Toggle Logic
            initialNodeCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    if (initialNodeCheckbox.checked) {
                        // If checking this node as initial
                        nodes.forEach(node => {
                            node.isInitial = false; // Remove initial status from all other nodes
                            node.isActive = false; // Also deactivate other nodes
                        });
                        selectedNodeForEdit.isInitial = true; // Set this node as initial
                        selectedNodeForEdit.isActive = true; // Make it active too
                    } else {
                        // If unchecking this node as initial, automatically assign it to the next available node.
                        selectedNodeForEdit.isInitial = false;
                        const stillAnInitialNode = nodes.some(n => n.isInitial);

                        if (!stillAnInitialNode) {
                            // Find the first node that is NOT the one we just deselected.
                            const nextNode = nodes.find(n => n.id !== selectedNodeForEdit.id && n.type !== 'action');
                            if (nextNode) {
                                nextNode.isInitial = true; // Make it the new initial node.
                            } else if (nodes.filter(n => n.type !== 'action').length > 0) {
                                selectedNodeForEdit.isInitial = true; // Re-assign if it's the only one left.
                            }
                        }
                    }
                    updateNodeStyles(); // Re-render styles for all nodes
                }
            });


            // NEW: Event Listeners for Action Node Modal
            saveActionNodeProperties.addEventListener('click', () => {
                console.log('[LOG] Action Node save button clicked.');
                if (selectedNodeForEdit && selectedNodeForEdit.type === 'action') {
                    console.log(`[LOG] Saving properties for node: ${selectedNodeForEdit.id}`);
                    const actionType = document.getElementById('action-node-type-select')?.value;
                    if (actionType && actionType !== '') {
                        const actionValue = document.getElementById('action-node-value-input').value;
                        selectedNodeForEdit.action = {
                            type: actionType,
                            value: actionValue,
                        };
                        console.log('[LOG] Saved action object:', JSON.parse(JSON.stringify(selectedNodeForEdit.action)));
                    } else {
                        selectedNodeForEdit.action = null;
                        console.log('[LOG] No action selected. Action set to null.');
                    }
                    updateActionNodeVisual(document.getElementById(selectedNodeForEdit.id), selectedNodeForEdit);
                    closeNodePropertiesModal(); // This closes the side panel
                } else {
                    console.warn('[LOG] Save button clicked, but no action node is selected for edit.');
                }
            });

            // Make the slider clickable for the initial node toggle
            initialNodeToggleGroup.querySelector('.slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                initialNodeCheckbox.checked = !initialNodeCheckbox.checked;
                initialNodeCheckbox.dispatchEvent(new Event('change'));
            });


            const exportLottieButton = document.getElementById('export-lottie-button'); // Get the new button

            exportLottieButton.addEventListener('click', async () => {
                saveNodePropertiesButton.click(); // Ensure current node properties are saved before export
                const initialNodeName = findInitialNodeId();

                // Find the globally selected animation from the available animations.
                const selectedAnimation = availableAnimations.find(anim => anim.id === globalAnimationId);

                if (!selectedAnimation) {
                    showCustomAlert("Cannot export: The globally selected animation could not be found.");
                    return;
                }

                // Pass only the selected animation to the export function.
                await exportLottieFile(nodes, connections, initialNodeName, globalState, guardConnections, [selectedAnimation]);
            });

            // --- New Event Listeners for .lottie Import ---
            // --- NEW: Event Listeners for single Lottie .json import ---
            addAnimationJsonButton.addEventListener('click', () => {
                animationJsonFileInput.click();
            });

            animationJsonFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const jsonContentString = e.target.result;
                        const animationJson = JSON.parse(jsonContentString);

                        // Basic Lottie validation
                        if (!animationJson.v || !animationJson.w || !animationJson.h || !animationJson.op) {
                            showCustomAlert("The selected file does not appear to be a valid Lottie JSON.");
                            return;
                        }

                        const animationId = file.name.replace(/\.json$/i, '').replace(/[^a-z0-9]/gi, '_');

                        // Process the JSON to add "Full Animation" marker and normalize `ip`
                        const processedJson = processSingleLottieJson(animationJson);
                        const { markers } = extractMarkersFromLogic(JSON.stringify(processedJson));

                        const newAnimation = {
                            id: animationId,
                            name: animationId,
                            markers: markers,
                            jsonContent: JSON.stringify(processedJson),
                            clickLayers: new Set()
                        };

                        // Replace all existing animations with this new one.
                        availableAnimations = [newAnimation];
                        populateGlobalAnimationDropdown();
                        setGlobalAnimation(newAnimation.id); // Set the newly uploaded animation as the global one

                        showCustomAlert(`Loaded '${newAnimation.name}' as the new global animation.`);

                    } catch (error) {
                        console.error('Error processing JSON file:', error);
                        showCustomAlert(`Error parsing JSON file: ${error.message}`);
                    } finally {
                        animationJsonFileInput.value = ''; // Clear the file input
                    }
                };
                reader.readAsText(file);
            });

            loadLottieButton.addEventListener('click', () => {
                lottieFileInput.click(); // Trigger the hidden .lottie file input
            });

            lottieFileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showCustomAlert("No .lottie file selected.");
                    return;
                }

  availableAnimations =  [
      { id: 'ishnat', name: 'ishnat', markers: [{ name: 'intro_segment', start: 0, end: 50 }, { name: 'idle_loop', start: 51, end: 150 }, { name: 'success_burst', start: 151, end: 200 }, { name: 'error_shake', start: 201, end: 250 }] },
      { id: 'moshu', name: 'moshu', markers: [{ name: 'spin_loop', start: 0, end: 60 }, { name: 'fade_out', start: 61, end: 80 }] },
      { id: 'checking', name: 'checking', markers: [{ name: 'default_state', start: 0, end: 1 }, { name: 'hover_in', start: 1, end: 15 }, { name: 'hover_out', start: 15, end: 1 }] }
  ];
//console.log (JSON.stringify(availableAnimations, null, 2));
  const animationMarkers = await extractAnimationMarkersFromLottie(file);
  availableAnimations = animationMarkers;

  // Load the first animation's JSON into the player immediately after upload
  if (modalDotLottiePlayer && availableAnimations.length > 0 && availableAnimations[0].jsonContent) {
      modalDotLottiePlayer.load({
          // Use the global animation ID to load the correct animation
          data: JSON.parse(availableAnimations.find(a => a.id === globalAnimationId)?.jsonContent || availableAnimations[0].jsonContent),
          loop: true,
      });
  }

    console.log (JSON.stringify(animationMarkers, null, 2));

    // --- FIX: Refresh the properties panel if it's open for the active node ---
    populateGlobalAnimationDropdown(); // This will re-populate and trigger the update for all nodes
    // --- NEW: Simulate a click on the first animation in the dropdown ---
    const firstAnimationOption = globalAnimationOptionsContainer.querySelector('.custom-dropdown-option');
    if (firstAnimationOption) {
        console.log(`[LOG] Simulating click on first global animation: ${firstAnimationOption.textContent}`);
        firstAnimationOption.click();
    }
    // --- END NEW ---

                try {
                    // Call the extractStateMachineJson function
                    const extractedJsons = await extractStateMachineJson(file);

                    if (extractedJsons.length > 0) {
                        const firstStateMachineJson = extractedJsons[0]; // Take the first JSON found


                        // Ensure converter functions are available
                        if (typeof convertJsonToNodesAndConnections !== 'function' || typeof extractFrameRangeMarkersFromJson !== 'function') {
                            showCustomAlert('Error: State machine converter library not loaded correctly. Make sure statemachineconvertersimplified.js is loaded.');
                            return;
                        }

                        // Extract frame-range markers from the imported JSON
const processedJson = await processLottieStateMachineJson(firstStateMachineJson, availableAnimations);
                       const extractedFrameMarkers = extractFrameRangeMarkersFromJson(processedJson);
				  console.log("Loading first state machine JSON from .lottie:", JSON.stringify(processedJson, null, 2));
            console.log('Extracted Frame Markers from .lottie (StateMachine JSON):', extractedFrameMarkers);

            updateAvailableAnimationsWithNewMarkers(extractedFrameMarkers);

                        // --- FIX: Use the 'processedJson' which has been correctly structured ---
                        const importedData = convertJsonToNodesAndConnections(processedJson);

                        clearFlowchart(); // Clear existing canvas

                        nodes = importedData.nodes;
                        connections = importedData.connections;
                        globalState = importedData.globalState; // <-- This was the missing piece
                        guardConnections = importedData.guardConnections; // <-- This was the missing piece
                        const importedInitialNodeId = importedData.initialNodeId;

                        // --- FIX: Render the global state node if it was imported ---
                        if (globalState) {
                            const globalStateEl = createGlobalStateElement(globalState);
                            canvasContainer.appendChild(globalStateEl);
                        }
                        // --- END FIX ---

                        // Map animation names/IDs from imported JSON to availableAnimations IDs
                        nodes.forEach(node => {
                            const matchingAnimation = availableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
                            if (matchingAnimation) {
                                node.animationId = matchingAnimation.id;
                            } else {
                                console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations. Defaulting.`);
                                node.animationId = availableAnimations[0]?.id || '';
                            }
                        });

                        // Set the active node based on the imported initialNodeId
                        if (importedInitialNodeId) {
                          const initialNode = nodes.find(n => n.id === importedInitialNodeId);
                          if (initialNode) {
                              initialNode.isActive = true;
                              initialNode.isInitial = true; // NEW: Set isInitial for the imported initial node
                          } else if (nodes.length > 0) {
                              nodes[0].isActive = true; // Fallback if specified initial not found
                              nodes[0].isInitial = true; // NEW: Set isInitial for fallback
                          }
                      } else if (nodes.length > 0) {
                          nodes[0].isActive = true; // Fallback if no initial specified
                          nodes[0].isInitial = true; // NEW: Set isInitial for fallback
                      }

                        // Render new nodes
                        nodes.forEach(nodeData => {
                            canvasContainer.appendChild(createNodeElement(nodeData));
                        });

                        fitCanvasToNodesMinimally(); // Adjust canvas and apply positions
                        updateNodeStyles(); // Apply active styles
                        showCustomAlert("State machine loaded successfully from .lottie file!");



                    } else {
                        // This block runs if the .lottie file contains animations but no state machine.
                        // The user's intent is to load the animations and assign the first one to the current node.
                        showCustomAlert('Animations loaded. No state machine found in the .lottie file.');

                        const activeNode = nodes.find(n => n.isActive);
                        if (activeNode && availableAnimations.length > 0) {
                            // Get the first animation that was just loaded
                            const firstNewAnimation = availableAnimations[0];
                            
                            // Assign it to the currently active node
                            activeNode.animationId = firstNewAnimation.id;
                            activeNode.marker = ''; // Reset the marker as the animation has changed
                            
                            console.log(`Assigned new animation "${firstNewAnimation.name}" to node "${activeNode.name}".`);

                            // Update the node's visual representation on the canvas
                            updateNodeElement(activeNode);

                            // Re-open/refresh the properties modal for the active node to reflect the change
                            openNodePropertiesModal(activeNode);
                            
                            // --- FIX: Explicitly adjust aspect ratio after loading new animation ---
                            adjustPreviewAspectRatio(firstNewAnimation.id);
                        } else if (nodes.length > 0 && !activeNode) {
                            // --- FIX: If no node was active, just select the first one to be helpful ---
                            nodes[0].isActive = true;
                            updateNodeStyles();
                            // If no node was active, just select the first one to be helpful
                            nodes[0].isActive = true;
                            updateNodeStyles();
                            openNodePropertiesModal(nodes[0]);
                        }
                    }
                } catch (error) {
                    console.error('Error processing .lottie file:', error);
                    showCustomAlert(`Error loading .lottie file: ${error.message}. Please ensure it is a valid .lottie archive containing state machine JSONs in 'states/' folder.`);
                } finally {
                    lottieFileInput.value = ''; // Clear the file input
                }
            });
            // --- End New Event Listeners for .lottie Import ---





            // NEW: Add input event listener for nodeNameInput to save changes
       nodeNameInput.addEventListener('input', () => {
           // Simulate a click on the save button to trigger the save logic
           saveNodePropertiesButton.click();
       })

            const broadcastEntryCheckbox = document.getElementById('broadcast-entry-checkbox');
            const broadcastExitCheckbox = document.getElementById('broadcast-exit-checkbox');

            broadcastEntryCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    selectedNodeForEdit.broadcastOnEntry = broadcastEntryCheckbox.checked;
                }
            });

            broadcastExitCheckbox.addEventListener('change', () => {
                if (selectedNodeForEdit) {
                    selectedNodeForEdit.broadcastOnExit = broadcastExitCheckbox.checked;
                }
            });

            document.querySelector('#broadcast-entry-toggle-group .slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                broadcastEntryCheckbox.checked = !broadcastEntryCheckbox.checked;
                broadcastEntryCheckbox.dispatchEvent(new Event('change'));
            });

            document.querySelector('#broadcast-exit-toggle-group .slider.round').addEventListener('click', (e) => {
                e.stopPropagation();
                broadcastExitCheckbox.checked = !broadcastExitCheckbox.checked;
                broadcastExitCheckbox.dispatchEvent(new Event('change'));
            });

            // NEW: Event listener for Freeze on First Frame checkbox
                        freezeOnFirstFrameCheckbox.addEventListener('change', () => {
                            if (selectedNodeForEdit) {
                                selectedNodeForEdit.autoplay = !freezeOnFirstFrameCheckbox.checked; // If checked, autoplay is false
                                if (modalDotLottiePlayer) {
                                    if (selectedNodeForEdit.autoplay) {
                                        modalDotLottiePlayer.play();
                                    } else {
                                        // If freeze, go to start of current segment/animation and stop.
                                        const currentAnimation = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
                                        let startFrame = 0;
                                        if (currentAnimation) {
                                            // Prioritize the selected marker on the node.
                                            let markerToUse = currentAnimation.markers.find(m => m.name === selectedNodeForEdit.marker);
                                            
                                            // If no marker is selected on the node, default to "Full Animation".
                                            if (!markerToUse) {
                                                markerToUse = currentAnimation.markers.find(m => m.name === 'Full Animation');
                                            }

                                            if (markerToUse) startFrame = markerToUse.start;
                                        }

                                       modalDotLottiePlayer.freeze();
                                        modalDotLottiePlayer.setFrame(startFrame);
                                         console.log("this is the start frame: " + startFrame);
                                    }
                                }
                            }
                        });

                        // NEW: Event listener for Freeze on First Frame slider
                        document.querySelector('#freeze-on-first-frame-toggle-group .slider.round').addEventListener('click', (e) => {
                            e.stopPropagation();
                            freezeOnFirstFrameCheckbox.checked = !freezeOnFirstFrameCheckbox.checked;
                            freezeOnFirstFrameCheckbox.dispatchEvent(new Event('change'));
                        });

            animationDropdownGroup.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = animationOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    animationOptionsContainer.classList.add('open');
                }
            });

            markerDropdownGroup.addEventListener('click', (e) => {
                e.stopPropagation();
                const wasOpen = markerOptionsContainer.classList.contains('open');
                closeAllCustomDropdowns();
                if (!wasOpen) {
                    markerOptionsContainer.classList.add('open');
                }
            });

            animationOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const selectedOption = e.target.closest('.custom-dropdown-option');
                if (selectedOption) {
                    const value = selectedOption.dataset.value;
                    const text = selectedOption.textContent;
                    animationNativeSelect.value = value;
                    animationDisplay.textContent = text;
                    animationOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    animationOptionsContainer.classList.remove('open');
                    const changeEvent = new Event('change');
                    animationNativeSelect.dispatchEvent(changeEvent);


                    // Simulate a click on the currently active node
                    if (selectedNodeForEdit) {
                        const activeNodeElement = document.getElementById(selectedNodeForEdit.id);
                        if (activeNodeElement) {
                            activeNodeElement.click(); // This will re-open the modal and refresh its content
                        }
                    }
                }
            });

            markerOptionsContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                // NEW: Check for either a standard option or our custom button
                const selectedOption = e.target.closest('.custom-dropdown-option, [data-value="add_segment_action"]');
                if (selectedOption) {
                    const value = selectedOption.dataset.value;
                    // NEW: Handle special action for adding segments
                    if (value === 'add_segment_action') {
                        addSegmentsButton.click(); // Simulate click on the main button
                        closeAllCustomDropdowns();
                        return;
                    }
                    const text = selectedOption.textContent;
                    markerNativeSelect.value = value;
                    markerDisplay.textContent = text;
                    markerOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    selectedOption.classList.add('selected');
                    markerOptionsContainer.classList.remove('open');
                    const changeEvent = new Event('change');
                    markerNativeSelect.dispatchEvent(changeEvent);
                }
            });

            // --- FIX: Add a dedicated listener for the loop count input ---
            loopCountInput.addEventListener('input', () => {
                if (tempConnectionData && tempConnectionData.interactionDetails) {
                    // Immediately update the temporary data when the loop count changes
                    tempConnectionData.interactionDetails.loopCount = parseInt(loopCountInput.value, 10) || 1;
                }
            });


            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown-group')) {
                    closeAllCustomDropdowns();
                }
            });


            const loopSlider = document.querySelector('#loop-checkbox + .slider.round');
            // const loopCheckbox = document.getElementById('loop-checkbox'); // Already defined globally

            if (loopSlider && loopCheckbox) {
                loopSlider.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loopCheckbox.checked = !loopCheckbox.checked;
                    const changeEvent = new Event('change');
                    loopCheckbox.dispatchEvent(changeEvent);
                });
            }

            loopCheckbox.addEventListener('change', () => {
               if (selectedNodeForEdit) {
                   selectedNodeForEdit.loop = loopCheckbox.checked;
                   // These were incorrectly placed here, broadcast checkboxes have their own listeners
                   // selectedNodeForEdit.broadcastOnEntry = broadcastEntryCheckbox.checked;
                   // selectedNodeForEdit.broadcastOnExit = broadcastExitCheckbox.checked;
                   if (modalDotLottiePlayer) {

       }
                   updateNodeDetailsChips(document.getElementById(selectedNodeForEdit.id)?.querySelector('.node'), selectedNodeForEdit);
               }
            });


            addActionNodeButton.addEventListener('click', addActionNode); // NEW
              addNodeButton.addEventListener('click', () => { addNode(); isConnecting = false; updateModeUI(); });
              connectNodesButton.addEventListener('click', () => {
                  isConnecting = !isConnecting; updateModeUI();
                  if (isConnecting) connectModeIndicator.textContent = 'Click a port on the source node, then a port on the target node.';
              });
              flowchartArea.addEventListener('click', (e) => {
                  if (!e.target.closest('.node') && !e.target.closest('.connection-text-group') && !e.target.classList.contains('connection-line')) {
                        
                       // --- MODIFICATION: Prevent deselecting all nodes. At least one must remain active. ---
                      // nodes.forEach(n => n.isActive = false);
                      // updateNodeStyles();                                     
                  }
              });
              flowchartArea.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  if (isConnecting) { isConnecting = false; updateModeUI(); connectModeIndicator.textContent = 'Click a port on the source node, then a port on the target node.'; }
              });
              closeNodeModalButtons.forEach(button => button.addEventListener('click', closeNodePropertiesModal));

              animationNativeSelect.addEventListener('change', async() => {
               if (selectedNodeForEdit) {
                   // This listener is now obsolete because the dropdown is hidden.
                   // The global dropdown handles animation changes.
               }
           });

              markerNativeSelect.addEventListener('change', async() => {
                if (selectedNodeForEdit) {
                    const newMarkerName = markerNativeSelect.value;
                    selectedNodeForEdit.marker = newMarkerName; //
                    updateNodeDetailsChips(document.getElementById(selectedNodeForEdit.id)?.querySelector('.node'), selectedNodeForEdit);
                    if (true) {
          const currentAnimation = availableAnimations.find(anim => anim.id === selectedNodeForEdit.animationId);
          // --- FIX: If freeze is checked, go to start and stop, otherwise play ---
          if (freezeOnFirstFrameCheckbox.checked) {
              let startFrame = 0;
              // If "Full Animation" is selected, find that specific marker.
              const markerNameForLookup = newMarkerName === 'Full Animation' ? 'Full Animation' : newMarkerName;
              const marker = currentAnimation?.markers.find(m => m.name === markerNameForLookup);
              if (marker) {
                  startFrame = marker.start;
              }
              modalDotLottiePlayer.freeze();
              modalDotLottiePlayer.setFrame(startFrame);
          } else if (selectedNodeForEdit.marker && currentAnimation) {
              const marker = currentAnimation.markers.find(m => m.name === selectedNodeForEdit.marker);
              if (marker) {
                console.log('am i even herrreeee?')
                  modalDotLottiePlayer.setSegment(marker.start, marker.end);
                  modalDotLottiePlayer.play();
              } else {
                  // If marker not found (e.g., "Full Animation"), set segment to full range
                  if (modalDotLottiePlayer.totalFrames > 0) {
                      modalDotLottiePlayer.setSegment(0, modalDotLottiePlayer.totalFrames);
                  }
                  modalDotLottiePlayer.play();
              }
          } else {
              // If no marker selected, play full animation by setting segment to full range
              if (modalDotLottiePlayer.totalFrames > 0) { modalDotLottiePlayer.setSegment(0, modalDotLottiePlayer.totalFrames); }
              modalDotLottiePlayer.play();
          }
      }
                }


              });


              saveNodePropertiesButton.addEventListener('click', () => {


                      if (selectedNodeForEdit) {
                          const newName = nodeNameInput.value.trim();
                          if (!newName) {
                              showCustomAlert("Node name cannot be empty.");
                              return;
                          }
                          const isDuplicate = nodes.some(node => node.name === newName && node.id !== selectedNodeForEdit.id);
                          if (isDuplicate) {
                              showCustomAlert(`Node name "${newName}" already exists. Please choose a unique name.`);
                              return;
                          }
                          selectedNodeForEdit.autoplay = !freezeOnFirstFrameCheckbox.checked; // NEW: Save autoplay state
                          selectedNodeForEdit.name = newName;
                          selectedNodeForEdit.speed = parseFloat(speedSlider.value);

                          // NEW LOGIC: Determine node.loop based on checkbox AND active OnLoopComplete connection
                          const onLoopCompleteConn = connections.find(conn =>
                              conn.fromNodeId === selectedNodeForEdit.id && conn.interactionType === 'OnLoopComplete'
                          );

                          if (loopCheckbox.checked) {
                              // If the loop checkbox is checked AND there's an OnLoopComplete connection,
                              // set node.loop to the loopCount from that connection.
                              if (onLoopCompleteConn && typeof onLoopCompleteConn.interactionDetails.loopCount === 'number' && onLoopCompleteConn.interactionDetails.loopCount > 0) {
                                  selectedNodeForEdit.loop = onLoopCompleteConn.interactionDetails.loopCount;                              } else {
                                  // Otherwise, if checked but no specific loop count connection, it's boolean true.
                                  selectedNodeForEdit.loop = true; // This branch is fine.
                              }
                          } else {
                              // If checkbox is unchecked, loop is false, unless an onLoopComplete connection dictates otherwise.
                              selectedNodeForEdit.loop = onLoopCompleteConn ? (onLoopCompleteConn.interactionDetails.loopCount || 1) : false;
                          }

                          updateNodeElement(selectedNodeForEdit);
                          // Update broadcast text if name changed
                          const broadcastEntryNodeNameSpan = document.getElementById('broadcast-entry-node-name');
                          const broadcastExitNodeNameSpan = document.getElementById('broadcast-exit-node-name');
                          broadcastEntryNodeNameSpan.textContent = `${selectedNodeForEdit.name}_entry`;
                      }

                  });

              deleteNodeButton.addEventListener('click', () => {
                  const nodeToDelete = selectedNodeForEdit;
                  if (!nodeToDelete) { console.error("Delete Node button clicked, but no node is selected for editing."); return; }
                  showCustomConfirm('Are you sure you want to delete this node and its connections?', () => { deleteNode(nodeToDelete.id); });
              });

              speedSlider.addEventListener('input', () => {
                speedValueSpan.textContent = parseFloat(speedSlider.value).toFixed(1) + 'x';
                if (selectedNodeForEdit && speedValueSpan) {
                    selectedNodeForEdit.speed = parseFloat(speedSlider.value);
                }
                if (modalDotLottiePlayer) {
           modalDotLottiePlayer.setSpeed(selectedNodeForEdit.speed);
       }
              });

              closeConnectionEditorButtons.forEach(button => button.addEventListener('click', closeConnectionEditorModal));

              transitionTypeDropdownGroup.addEventListener('click', (e) => {
                  if (transitionTypeNativeSelect.disabled) return;
                  e.stopPropagation();
                  const wasOpen = transitionTypeOptionsContainer.classList.contains('open');
                  closeAllCustomDropdowns();
                  if (!wasOpen) {
                      transitionTypeOptionsContainer.classList.add('open');
                  }
              });

              transitionTypeOptionsContainer.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const selectedOption = e.target.closest('.custom-dropdown-option');
                  if (selectedOption) {
                      const value = selectedOption.dataset.value;
                      const text = selectedOption.textContent;
                      transitionTypeNativeSelect.value = value;
                      transitionTypeDisplay.textContent = text;
                      transitionTypeOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                      selectedOption.classList.add('selected');
                      transitionTypeOptionsContainer.classList.remove('open');
                      const changeEvent = new Event('change');
                      transitionTypeNativeSelect.dispatchEvent(changeEvent);
                  }
              });

              transitionTypeNativeSelect.addEventListener('change', () => {
                  const selectedType = transitionTypeNativeSelect.value;
                  if (selectedType === 'Tweened') {
                      tweenedDurationField.style.display = 'block';
                      tweenedEasingField.style.display = 'block';
                  } else {
                      tweenedDurationField.style.display = 'none';
                      tweenedEasingField.style.display = 'none';
                  }
              });


              interactionPresetDropdownGroup.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const wasOpen = interactionPresetOptionsContainer.classList.contains('open');
                  closeAllCustomDropdowns();
                  if (!wasOpen) {
                      interactionPresetOptionsContainer.classList.add('open');
                  }
              });

              interactionPresetOptionsContainer.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const selectedOption = e.target.closest('.custom-dropdown-option');
                  if (selectedOption) {
                      const value = selectedOption.dataset.value;
                      const text = selectedOption.textContent;
                      interactionPresetNativeSelect.value = value;
                      interactionPresetDisplay.textContent = text;
                      interactionPresetOptionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                      selectedOption.classList.add('selected');
                      interactionPresetOptionsContainer.classList.remove('open');
                      const changeEvent = new Event('change');
                      interactionPresetNativeSelect.dispatchEvent(changeEvent);
                  }
              });


              interactionPresetNativeSelect.addEventListener('change', () => {
                const selectedPresetId = interactionPresetNativeSelect.value;

                // --- FIX: Update the temporary data object, not the original ---
                if (tempConnectionData) {
                    tempConnectionData.interactionType = selectedPresetId;
                    // --- NEW: Log the context change ---
                    console.log(`[LOG] Interaction type changed in memory to: '${selectedPresetId}'`);
                }

                // Call the centralized function to update all dynamic fields
                updateDynamicInteractionFields(selectedPresetId, tempConnectionData.interactionDetails || {});

                // --- NEW: If onLoopComplete is selected, update the source node's loop property ---
                if (selectedPresetId === 'onLoopComplete') {
                    const fromNode = nodes.find(n => n.id === tempConnectionData.fromNodeId);
                    if (fromNode) {
                        fromNode.loop = parseInt(loopCountInput.value, 10) || 1;
                    }
                }
                              // This `selectedNodeForEdit` refers to the node whose properties are open in the Node Properties Modal.
                              // `selectedConnectionForEdit` refers to the connection open in the Connection Editor Modal.
                              // We should only modify `loopCheckbox` if the Node Properties Modal is open
                              // for the `fromNode` of the connection being edited.
                              if (selectedNodeForEdit && selectedConnectionForEdit && selectedNodeForEdit.id === selectedConnectionForEdit.fromNodeId) {
                    // Also update actions section visibility
                    // --- NEW: Get elements for the Freeze toggle ---
                    const freezeToggleContainer = document.getElementById('freeze-on-first-frame-toggle-group');
                    const freezeToggleLabel = freezeToggleContainer.querySelector('label');

                    updateActionsSection(tempConnectionData);
                                  let shouldForceLoopCheckboxFalse = false;

                                  // Check if the *newly selected* type for the current connection forces loop off
                              if (selectedPresetId === 'onLoopComplete' || selectedPresetId === 'onComplete') { // <-- FIX: Corrected case from 'OnLoopComplete'
                                  shouldForceLoopCheckboxFalse = true;
                              } else {
                                  // If the new type doesn't force it off, check other existing connections from this node
                                  const otherOutgoingConnections = connections.filter(
                                      conn => conn.fromNodeId === selectedNodeForEdit.id && conn.id !== selectedConnectionForEdit.id
                                  );
                                  if (otherOutgoingConnections.some(conn => conn.interactionType === 'OnLoopComplete' || conn.interactionType === 'onComplete')) {
                                      shouldForceLoopCheckboxFalse = true;
                                  }
                              }

                                  if (shouldForceLoopCheckboxFalse) {
                                      loopCheckbox.checked = false;
                                  } else {
                                      // If no connection forces loop off, set checkbox based on the node's actual loop property
                                      const effectivelyLoops = (typeof selectedNodeForEdit.loop === 'boolean' && selectedNodeForEdit.loop === true) ||
                                                             (typeof selectedNodeForEdit.loop === 'number' && selectedNodeForEdit.loop > 0);
                                      loopCheckbox.checked = effectivelyLoops;
                                  }

                                  // --- NEW: Logic to control the "Freeze On First Frame" toggle ---
                                  if (shouldForceLoopCheckboxFalse) { // We can reuse the same flag
                                      // If there's an onComplete/onLoopComplete, we MUST NOT freeze.
                                      freezeOnFirstFrameCheckbox.checked = false; // Turn toggle OFF
                                      freezeToggleContainer.style.pointerEvents = 'none';
                                      freezeToggleContainer.style.opacity = '0.4';
                                      freezeToggleLabel.title = 'Cannot freeze frame when using an On Complete or On Loop Complete trigger.';
                                  } else {
                                      // If no such trigger exists, re-enable the toggle.
                                      freezeToggleContainer.style.pointerEvents = 'auto';
                                      freezeToggleContainer.style.opacity = '1.0';
                                      freezeToggleLabel.title = '';
                                      // The checked state will be determined by the node's `autoplay` property when the modal is next opened.
                                  }
                              }
                      });


        // --- NEW: Functions for Global State, Guards, and Actions ---

        function addOrShowGlobalStateNode() {
            if (globalState) {
                openGlobalStateModal();
                return;
            }
            globalState = {
                id: 'global_state_node',
                name: 'myVariable',
                type: 'Numeric',
                initialValue: 0,
                x: -panOffsetX + 50,
                y: -panOffsetY + 50,
            };
            const el = createGlobalStateElement(globalState);
            canvasContainer.appendChild(el);
            fitCanvasToNodesMinimally();
            openGlobalStateModal();
        }

        function openGlobalStateModal() {
            if (!globalState) return;
            globalStateNameInput.value = globalState.name;
            globalStateValueInput.value = globalState.initialValue;

            // Populate type dropdown
            const typeOptions = [{ id: 'Numeric', name: 'Numeric' }, { id: 'Boolean', name: 'Boolean' }];
            globalStateTypeDropdownGroup.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                    <label for="global-state-type-select">Variable Type</label>
                    <div class="custom-dropdown-container">
                        <div class="custom-dropdown-display" data-target-select="global-state-type-select"></div>
                        <div class="custom-dropdown-options"></div>
                        <select id="global-state-type-select" style="display: none;"></select>
                    </div>
                </div>
                <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;
            
            const display = globalStateTypeDropdownGroup.querySelector('.custom-dropdown-display');
            const optionsContainer = globalStateTypeDropdownGroup.querySelector('.custom-dropdown-options');
            const nativeSelect = globalStateTypeDropdownGroup.querySelector('select');
            
            populateDropdowns(nativeSelect, display, optionsContainer, typeOptions, globalState.type);

            // Dropdown event handling
            globalStateTypeDropdownGroup.onclick = (e) => { e.stopPropagation(); optionsContainer.classList.toggle('open'); };
            optionsContainer.onclick = (e) => {
                e.stopPropagation(); // Prevent the event from bubbling up to globalStateTypeDropdownGroup
                const option = e.target.closest('.custom-dropdown-option');
                if (option) {
                    nativeSelect.value = option.dataset.value;
                    display.textContent = option.textContent;
                    optionsContainer.classList.remove('open');
                }
            };

            globalStateModal.style.display = 'flex';
        }

        function saveGlobalState() {
            if (!globalState) return;
            const newName = globalStateNameInput.value.trim();
            if (!newName) {
                showCustomAlert("Variable name cannot be empty.");
                return;
            }
            globalState.name = newName;
            globalState.type = document.getElementById('global-state-type-select').value;
            globalState.initialValue = globalStateValueInput.value;

            // Update visual element
            const el = document.getElementById('global_state_node');
            if (el) {
                el.querySelector('div:nth-child(1)').textContent = globalState.name;
                el.querySelector('div:nth-child(2)').textContent = `(${globalState.type})`;
                el.querySelector('div:nth-child(3)').textContent = `Value: ${globalState.initialValue}`;
            }
            globalStateModal.style.display = 'none';
        }

        function addGuardConnection(fromId, toId) {
            if (fromId !== 'global_state_node' || !nodes.some(n => n.id === toId)) return;
            if (guardConnections.some(gc => gc.toNodeId === toId)) {
                showCustomAlert("This state already has a guard condition.");
                return;
            }
            const newGuardConn = {
                id: `guard_${generateId()}`,
                fromNodeId: fromId,
                toNodeId: toId,
                transitionType: 'Transition', // Default to standard
                duration: 0.5,
                easing: [0.42, 0, 0.58, 1],
                condition: 'Equal', // Default
                value: globalState.type === 'Boolean' ? 'true' : '0', // Default
            };
            guardConnections.push(newGuardConn);
            drawConnections();
            openGuardConditionModal(newGuardConn);
        }

        function deleteGuardConnection(id) {
            guardConnections = guardConnections.filter(gc => gc.id !== id);
            drawConnections();
            guardConditionModal.style.display = 'none';
        }

        function getConditionOptionsForType(type) {
            if (type === 'Numeric') return [{id: 'Equal', name: 'is equal to'}, {id: 'NotEqual', name: 'is not equal to'}, {id: 'GreaterThan', name: 'is greater than'}, {id: 'LessThan', name: 'is less than'}];
            if (type === 'Boolean') return [{id: 'Equal', name: 'is'}, {id: 'NotEqual', name: 'is not'}];
            if (type === 'String') return [{id: 'Equal', name: 'is equal to'}, {id: 'NotEqual', name: 'is not equal to'}];
            return [];
        }

        /**
         * Inserts a new shape layer into a Lottie animation's JSON data, intended to be used as a clickable area.
         * The layer is a transparent rectangle covering the entire animation area.
         * @param {object} animationData - The Lottie JSON data object.
         * @param {string} layerName - The desired name for the new layer (e.g., "StateName_click_area").
         * @param {string} [markerName] - Optional. The name of a marker to define the layer's in and out points.
         * @returns {object|null} The modified Lottie JSON data, or null if input is invalid.
         */
        function addClickAreaLayer(animationData, layerName, markerName) {
            // --- NEW: Log when this function is called ---
            console.log(`[LOG] Adding a new full-frame interactive layer named: "${layerName}"`);

             if (!animationData || !animationData.w || !animationData.h || !animationData.op) {
                 console.error("Invalid Lottie data: Missing width, height, or out-point.");
                 return null;
             }
 
             // Create a deep copy to avoid side effects
             const newData = JSON.parse(JSON.stringify(animationData));
             
             const frameWidth = newData.w;
             const frameHeight = newData.h;
 
             // --- Duration Logic ---
             let inPoint = 0;
             let outPoint = newData.op; // Default to the full animation duration
 
             if (markerName && newData.markers && newData.markers.length > 0) {
                 const targetMarker = newData.markers.find(marker => marker.cm === markerName);
                 if (targetMarker) {
                     inPoint = targetMarker.tm;
                     outPoint = targetMarker.tm + targetMarker.dr;
                     console.log(`Found marker "${markerName}". Setting layer duration from frame ${inPoint} to ${outPoint}.`);
                 } else {
                     console.warn(`Marker "${markerName}" not found. Defaulting to full animation duration.`);
                 }
             }
             // --- End Duration Logic ---
 
             // --- Find the highest current layer index to ensure our new layer has a unique one ---
             const maxIndex = newData.layers.reduce((max, layer) => Math.max(max, layer.ind || 0), 0);
             const newLayerIndex = maxIndex + 1;
             
             const newFrameLayer = {
                 "ddd": 0, "ty": 4, "nm": layerName, "sr": 1, "ind": newLayerIndex,
                 "ks": {
                     "o": { "a": 0, "k": 100, "ix": 11 },
                     "r": { "a": 0, "k": 0, "ix": 10 },
                     "p": { "a": 0, "k": [frameWidth / 2, frameHeight / 2, 0], "ix": 2 },
                     "a": { "a": 0, "k": [0, 0, 0], "ix": 1 },
                     "s": { "a": 0, "k": [100, 100, 100], "ix": 6 }
                 },
                 "ao": 0,
                 "shapes": [{
                     "ty": "gr", "nm": "Frame Group", "np": 3,
                     "it": [
                         { "ty": "rc", "nm": "Rectangle", "d": 1, "p": { "a": 0, "k": [0, 0], "ix": 2 }, "s": { "a": 0, "k": [frameWidth, frameHeight], "ix": 3 }, "r": { "a": 0, "k": 0, "ix": 4 } },
                         { "ty": "st", "nm": "Red Stroke", "c": { "a": 0, "k": [1, 0, 0, 1], "ix": 3 }, "o": { "a": 0, "k": 100, "ix": 4 }, "w": { "a": 0, "k": 5, "ix": 2 } },
                         { "ty": "tr", "nm": "Transform", "p": { "a": 0, "k": [0, 0], "ix": 2 }, "a": { "a": 0, "k": [0, 0], "ix": 1 }, "s": { "a": 0, "k": [100, 100], "ix": 3 }, "r": { "a": 0, "k": 0, "ix": 6 }, "o": { "a": 0, "k": 100, "ix": 7 }, "sk": { "a": 0, "k": 0, "ix": 4 }, "sa": { "a": 0, "k": 0, "ix": 5 } }
                     ],
                     "ks": { "o": { "a": 0, "k": 100 }, "r": { "a": 0, "k": 0 }, "p": { "a": 0, "k": [0, 0] }, "a": { "a": 0, "k": [0, 0] }, "s": { "a": 0, "k": [100, 100] } }
                 }],
                 "ip": inPoint, "op": outPoint, "st": inPoint, "bm": 0
             };
 
             // Add the new layer to the end of the layers array to place it on top visually.
             newData.layers.push(newFrameLayer);
             
             return newData;
         }

        /**
         * Automatically finds the source node of a connection, checks if a click/hover layer is needed
         * for the selected interaction, and injects it into the Lottie JSON if it doesn't already exist.
         * @param {object} connection - The connection object being edited.
         * @param {string} interactionType - The newly selected interaction type (e.g., 'onClick').
         */
        function autoCreateInteractionLayer(connection, interactionType) {
            console.log(`[LOG] autoCreateInteractionLayer called for connection ${connection.id} with type: ${interactionType}`);
            // FIX: Use the correct lowercase 'on' prefix to match the values from INTERACTION_PRESETS.
            const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
            if (!pointerEvents.includes(interactionType)) {
                return; // Not an interaction that needs a layer
            }

            const fromNode = nodes.find(n => n.id === connection.fromNodeId);
            if (!fromNode) return;
            console.log(`[LOG] Found source node: ${fromNode.name}`);

            const animation = availableAnimations.find(anim => anim.id === fromNode.animationId);
            if (!animation || !animation.jsonContent) {
                console.error(`[LOG] ABORT: Lottie JSON for animation '${fromNode.animationId}' is not loaded.`);
                return;
            }
            console.log(`[LOG] Found animation data for: ${animation.name}`);

            // --- NEW: Generate transition-specific layer name ---
            const toNode = nodes.find(n => n.id === connection.toNodeId);
            const interactionName = interactionType.replace('on', '').toLowerCase();
            const layerName = `${fromNode.name}_${interactionName}_to_${toNode.name}`;

            // --- FIX: Check if a layer with the target name already exists in the JSON ---
            // This is more robust than the clickLayers set and prevents adding a duplicate layer.
            const currentJson = JSON.parse(animation.jsonContent);
            const layerAlreadyExists = currentJson.layers.some(layer => layer.nm === layerName);

            if (layerAlreadyExists) {
                console.log(`[LOG] autoCreateInteractionLayer: A layer named '${layerName}' already exists. Skipping default layer creation.`);
                return;
            }
            // --- END FIX ---

            // Add the click area layer
            console.log(`[LOG] Calling addClickAreaLayer with name: '${layerName}' and marker: '${fromNode.marker}'`);
            const modifiedJsonData = addClickAreaLayer(currentJson, layerName, fromNode.marker);

            if (modifiedJsonData) {
                // Define markerIdentifier to use for the clickLayers set.
                const markerIdentifier = fromNode.marker || 'full_animation';

                animation.jsonContent = JSON.stringify(modifiedJsonData);
                animation.clickLayers.add(markerIdentifier); // Mark this segment as having a click layer
                console.log(`[LOG] SUCCESS: Auto-created layer '${layerName}' and updated animation.jsonContent.`);
                showCustomAlert(`Auto-created layer: ${layerName}`);

                // NEW: Refresh the preview player if it's showing this animation
                if (selectedNodeForEdit && selectedNodeForEdit.id === fromNode.id && modalDotLottiePlayer) {
                    console.log("[LOG] Refreshing preview player with updated JSON data.");
                    // Reload the entire player instance to use the new data provided by the data provider function.
                    if (animation.jsonContent) {
                        modalDotLottiePlayer.load({ data: JSON.parse(animation.jsonContent) });
                    }
                }
            }
        }


                      saveConnectionEditorButton.addEventListener('click', () => {
    if (selectedConnectionForEdit) {
        // --- FIX: Apply changes from tempConnectionData to the original selectedConnectionForEdit ---
        const originalConnection = connections.find(c => c.id === selectedConnectionForEdit.id);
        if (!originalConnection) return;

        // Apply basic properties from the UI controls to the temp object first
        tempConnectionData.transitionType = transitionTypeNativeSelect.value;
        tempConnectionData.interactionType = interactionPresetNativeSelect.value;
        tempConnectionData.interactionDetails = tempConnectionData.interactionDetails || {}; // Ensure details object exists

        // --- FIX: Only trigger auto-creation for pointer-based interactions ---
        // This prevents creating layers for time-based events like 'onComplete'.
        const pointerEvents = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];
        if (pointerEvents.includes(tempConnectionData.interactionType)) {
            autoCreateInteractionLayer(tempConnectionData, tempConnectionData.interactionType);
        }
        // --- END NEW ---

        // --- NEW: Log all layer names from the relevant JSON ---
        const fromNode = nodes.find(n => n.id === tempConnectionData.fromNodeId);
        if (fromNode) {
            const animation = availableAnimations.find(anim => anim.id === fromNode.animationId);
            if (animation && animation.jsonContent) {
                try {
                    const currentJson = JSON.parse(animation.jsonContent);
                    if (currentJson.layers && Array.isArray(currentJson.layers)) {
                        const layerNames = currentJson.layers.map(layer => layer.nm || 'unnamed_layer');
                        console.log(`[LOG] Layer names in animation '${animation.name}' upon saving transition:`, layerNames);
                    }
                } catch (e) {
                    console.error("Could not parse animation JSON to log layer names.", e);
                }
            }
        }

        // Save the loop count if the trigger is 'onLoopComplete'
        if (tempConnectionData.interactionType === 'onLoopComplete') {
            const loopCountInput = document.getElementById('loop-count-input');
            tempConnectionData.interactionDetails.loopCount = parseInt(loopCountInput.value, 10) || 1;
        }

        // NEW: Save tweening properties
        if (tempConnectionData.transitionType === 'Tweened') {
            tempConnectionData.duration = parseFloat(tweenedDurationInput.value) || 0.5;
            try {
                const easingArray = tweenedEasingInput.value.split(',').map(s => parseFloat(s.trim()));
                if (easingArray.length === 4 && easingArray.every(n => !isNaN(n))) {
                    tempConnectionData.easing = easingArray;
                } else {
                    throw new Error("Invalid format.");
                }
            } catch (e) {
                showCustomAlert("Invalid Easing format. Please use four comma-separated numbers (e.g., 0.42, 0, 0.58, 1). Reverting to default.");
                tempConnectionData.easing = [0.42, 0, 0.58, 1]; // Revert to default on error
            }
        }

        // NEW: Save action
        if (globalState && actionsSection.style.display !== 'none') {
            const actionType = actionTypeNativeSelect.value;
            if (actionType) {
                tempConnectionData.action = {
                    type: actionType,
                    value: actionValueInput.value,
                };
            } else {
                tempConnectionData.action = null; // Clear action if 'None' is selected
            }
        }

        // Now, apply all the changes from the temp object to the original object
        Object.assign(originalConnection, tempConnectionData);

        updateSourceNodeLoopStatus(originalConnection.fromNodeId);
        redrawAll();
    }
    closeConnectionEditorModal();
});

              deleteConnectionButton.addEventListener('click', () => {
                   if (selectedConnectionForEdit) {
                      const connectionToDelete = selectedConnectionForEdit;
                      deleteConnection(connectionToDelete.id);
                  }
              });


            // --- New Event Listeners for Import/Export ---
            loadJsonButton.addEventListener('click', () => {
                jsonFileInput.click(); // Trigger the hidden file input
            });

            jsonFileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const jsonContent = e.target.result;
                const parsedJson = JSON.parse(jsonContent);
		//console.log('UPLOADED STATEMACHINE'+JSON.stringify(parsedJson));
                if (typeof convertJsonToNodesAndConnections !== 'function') {
                    showCustomAlert('Error: State machine converter library not loaded correctly.');
                    return;
                }

                // NEW STEP 1: Extract frame-range markers from the imported JSON
                const extractedFrameMarkers = extractFrameRangeMarkersFromJson(parsedJson);
		//console.log('Extracted Frame Markers from JSON:', extractedFrameMarkers); // Add this line


                // NEW STEP 2: Update availableAnimations with these new markers
                updateAvailableAnimationsWithNewMarkers(extractedFrameMarkers);

                const importedData = convertJsonToNodesAndConnections(parsedJson);
                clearFlowchart(); // Clear existing canvas

                nodes = importedData.nodes;
                connections = importedData.connections;
                globalState = importedData.globalState; // NEW
                guardConnections = importedData.guardConnections; // NEW
                const importedInitialNodeId = importedData.initialNodeId;

                // NEW: Render global state node if it exists
                if (globalState) {
                    const globalStateEl = createGlobalStateElement(globalState);
                    canvasContainer.appendChild(globalStateEl);
                    // Dragging for global state node
                    let isDragging = false, offsetX, offsetY;
                    globalStateEl.addEventListener('mousedown', e => { isDragging = true; offsetX = e.clientX - globalStateEl.getBoundingClientRect().left; offsetY = e.clientY - globalStateEl.getBoundingClientRect().top; });
                    document.addEventListener('mousemove', e => { if(isDragging) { globalState.x = e.clientX - canvasContainer.getBoundingClientRect().left - offsetX; globalState.y = e.clientY - canvasContainer.getBoundingClientRect().top - offsetY; globalStateEl.style.left = `${globalState.x}px`; globalStateEl.style.top = `${globalState.y}px`; drawConnections(); }});
                    document.addEventListener('mouseup', () => { if(isDragging) { isDragging = false; fitCanvasToNodesMinimally(); }});
                }


                // No change needed here for node.animationId as convertJsonToNodesAndConnections
                // handles mapping JSON names to internal IDs already.
                nodes.forEach(node => {
                    const matchingAnimation = availableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
                    if (matchingAnimation) {
                        node.animationId = matchingAnimation.id;
                    } else {
                        console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations. Defaulting.`);
                        node.animationId = availableAnimations[0]?.id || '';
                    }
                });

                // Set the active node based on the imported initialNodeId
                if (importedInitialNodeId) {
                    const initialNode = nodes.find(n => n.id === importedInitialNodeId);
                    if (initialNode) {
                        initialNode.isActive = true;
                    } else if (nodes.length > 0) {
                        nodes[0].isActive = true; // Fallback if specified initial not found
                    }
                } else if (nodes.length > 0) {
                    nodes[0].isActive = true; // Fallback if no initial specified
                }

                // Render new nodes
                nodes.forEach(nodeData => {
                    canvasContainer.appendChild(createNodeElement(nodeData));
                });

                fitCanvasToNodesMinimally(); // Adjust canvas and apply positions
                updateNodeStyles(); // Apply active styles


            } catch (error) {
                console.error('Error parsing JSON file:', error);
                showCustomAlert('Error: Could not parse the JSON file. Please ensure it is a valid state machine JSON.');
            } finally {
                jsonFileInput.value = '';
            }
        };
        reader.readAsText(file);
    }
});
            exportJsonButton.addEventListener('click', () => {

              saveNodePropertiesButton.click();
                if (typeof convertNodesAndConnectionsToJson !== 'function') {
                    showCustomAlert('Error: State machine converter library not loaded correctly.');
                    return;
                }

                const initialId = findInitialNodeId();
                if (!initialId && nodes.length > 0) {
                    showCustomAlert("Warning: No initial state is clearly defined. Defaulting to the first node or a placeholder.");
                }

                const stateMachineJson = convertNodesAndConnectionsToJson(nodes, connections, initialId, globalState, guardConnections, availableAnimations);
                const jsonString = JSON.stringify(stateMachineJson, null, 2); // Pretty print

                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stateMachine.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

        });

        // --- NEW: Event Listeners for Global State, Guards, Actions ---

        addGlobalStateButton.addEventListener('click', () => {
            addOrShowGlobalStateNode();
        });

        saveGuardConditionButton.addEventListener('click', () => {
            if (selectedGuardConnectionForEdit) {
                // Save condition and value
                // --- FIX: Save the selected condition from the dropdown ---
                selectedGuardConnectionForEdit.condition = guardConditionTypeNativeSelect.value;
                selectedGuardConnectionForEdit.value = guardValueInput.value;

                // NEW: Save transition type and tweening properties
                const guardTransitionTypeSelect = document.getElementById('guard-transition-type-select');
                selectedGuardConnectionForEdit.transitionType = guardTransitionTypeSelect.value;

                if (selectedGuardConnectionForEdit.transitionType === 'Tweened') {
                    const durationInput = document.getElementById('guard-tweened-duration-input');
                    const easingInput = document.getElementById('guard-tweened-easing-input');
                    selectedGuardConnectionForEdit.duration = parseFloat(durationInput.value) || 0.5;
                    try {
                        const easingArray = easingInput.value.split(',').map(s => parseFloat(s.trim()));
                        if (easingArray.length === 4 && easingArray.every(n => !isNaN(n))) {
                            selectedGuardConnectionForEdit.easing = easingArray;
                        } else {
                            throw new Error("Invalid format.");
                        }
                    } catch (e) {
                        showCustomAlert("Invalid Easing format. Please use four comma-separated numbers. Reverting to default.");
                        selectedGuardConnectionForEdit.easing = [0.42, 0, 0.58, 1];
                    }
                }

                guardConditionModal.style.display = 'none';
                selectedGuardConnectionForEdit = null;
                redrawAll();
            }
        });

        // NEW: Add event listener for the new guard transition type dropdown
        document.getElementById('guard-transition-type-dropdown-group').addEventListener('click', (e) => {
            e.stopPropagation();
            const optionsContainer = document.getElementById('guard-transition-type-options');
            optionsContainer.classList.toggle('open');
        });
        document.getElementById('guard-transition-type-options').addEventListener('click', (e) => {
            const option = e.target.closest('.custom-dropdown-option');
            if (option) {
                document.getElementById('guard-transition-type-select').value = option.dataset.value;
                document.getElementById('guard-transition-type-select').dispatchEvent(new Event('change'));
            }
        });

        // Attach listener for the global state save button
        saveGlobalStateButton.addEventListener('click', () => {
            // The button's only job is now to close the panel. Saving happens live.
            if (!statePreviewWindow.classList.contains('hidden')) {
                previewToggleButton.click();
            }
        });

            // NEW: Event listener for deleting an action node
            deleteActionNodeButton.addEventListener('click', () => {
                const nodeToDelete = selectedNodeForEdit;
                if (!nodeToDelete || nodeToDelete.type !== 'action') {
                    console.error("Delete Action Node button clicked, but no action node is selected for editing.");
                    return;
                }
                showCustomConfirm('Are you sure you want to delete this action node?', () => { deleteNode(nodeToDelete.id); });
            });

        // NEW: Event listener for deleting the global state
            deleteGlobalStateButton.addEventListener('click', () => {
                showCustomConfirm('Are you sure you want to delete the global variable and all its conditions?', deleteGlobalState);
            });

            deleteGuardConnectionButton.addEventListener('click', () => {
                if (selectedGuardConnectionForEdit) {
                    deleteGuardConnection(selectedGuardConnectionForEdit.id);
                }
            });
            guardConditionModal.querySelectorAll('.close-button').forEach(b => b.addEventListener('click', () => guardConditionModal.style.display = 'none'));

            // Action dropdown logic
            actionTypeDropdownGroup.addEventListener('click', (e) => { e.stopPropagation(); actionTypeOptionsContainer.classList.toggle('open'); });
            actionTypeOptionsContainer.addEventListener('click', (e) => {
                const option = e.target.closest('.custom-dropdown-option');
                if (option) {
                    actionTypeNativeSelect.value = option.dataset.value;
                    actionTypeDisplay.textContent = option.textContent;
                    actionTypeOptionsContainer.classList.remove('open');
                    updateActionValueField(option.dataset.value);
                }
            });

            // NEW: Event listeners for Guard Condition Modal dropdown
            guardConditionTypeOptionsContainer.addEventListener('click', (e) => {
                // This is now the main dropdown for the guard condition type
                e.stopPropagation();
                const optionsContainer = document.getElementById('guard-condition-type-options');
                const nativeSelect = document.getElementById('guard-condition-type-select');
                const option = e.target.closest('.custom-dropdown-option');
                // --- FIX START ---
                if (option) {
                    const value = option.dataset.value;
                    const display = guardConditionTypeDropdownGroup.querySelector('.custom-dropdown-display');

                    // Update the native select, which holds the actual value
                    nativeSelect.value = value;
                    // Update the custom display text
                    display.textContent = option.textContent;
                    // Update the 'selected' class for styling
                    optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    // Close the dropdown
                    optionsContainer.classList.remove('open');
                }
                // --- FIX END ---
            });

            // NEW: Click listener for the new dropdown group
            const guardConditionDropdownGroup = document.getElementById('guard-condition-type-dropdown-group');
            if (guardConditionDropdownGroup) {
                guardConditionDropdownGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const optionsContainer = document.getElementById('guard-condition-type-options');
                    const wasOpen = optionsContainer.classList.contains('open');
                    closeAllCustomDropdowns();
                    if (!wasOpen) optionsContainer.classList.add('open');
                });
            }

            // NEW: Live update listeners for global state inputs
            globalStateNameInput.addEventListener('input', updateGlobalStateFromUI);
            globalStateValueInput.addEventListener('input', updateGlobalStateFromUI);
            // --- NEW: Listener for the boolean toggle ---
            globalStateValueToggle.addEventListener('change', updateGlobalStateFromUI);
            globalStateValueToggleSwitch.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent parent click events
                globalStateValueToggle.click(); // Programmatically click the hidden checkbox
            });


function updateAvailableAnimationsWithNewMarkers(newMarkersData) {
//console.log('ths is  beforeudpate'+availableAnimations);

    newMarkersData.forEach(newAnimData => {
        let existingAnim = availableAnimations.find(a => a.id === newAnimData.id);

        if (!existingAnim) {
            // If the animation itself doesn't exist, add it
            existingAnim = { id: newAnimData.id, name: newAnimData.name, markers: [] };
            availableAnimations.push(existingAnim);
        }

        newAnimData.markers.forEach(newMarker => {
            // Only add the new marker if it doesn't already exist in the existing animation's markers
            if (!existingAnim.markers.some(m => m.name === newMarker.name)) {
                existingAnim.markers.push(newMarker);
            }
        });
    });


  //  console.log('--- updateAvailableAnimationsWithNewMarkers: after update ---');
    //console.log(JSON.parse(JSON.stringify(availableAnimations))); // Log a deep copy of the state after modifications
}










function readFileAsArrayBuffer(file) {
       return new Promise((resolve, reject) => {
           const reader = new FileReader();
           reader.onload = () => resolve(reader.result);
           reader.onerror = error => reject(error);
           reader.readAsArrayBuffer(file);
       });
   }


   /**
    * Extracts and parses all JSON files located in the 'states/' directory within a .lottie archive.
    * @param {File} dotLottieFile - The .lottie file (zip archive) to process.
    * @returns {Promise<Array<object>>} A promise that resolves with an array of parsed JSON objects
    * found in the 'states/' directory. Returns an empty array if no
    * JSON files are found or if JSZip is not loaded.
    */
   async function extractStateMachineJson(dotLottieFile) {
       if (typeof JSZip === 'undefined') {
           console.error("JSZip library is not loaded. Please ensure it's available in the global scope (e.g., via a <script> tag).");
           return [];
       }

       const arrayBuffer = await readFileAsArrayBuffer(dotLottieFile);
       const zip = new JSZip();
       const loadedZip = await zip.loadAsync(arrayBuffer);

       const stateMachineJsons = [];

       for (const filename in loadedZip.files) {
           const fileEntry = loadedZip.files[filename];
           if (!fileEntry.dir && (filename.startsWith('states/') || filename.startsWith('s/')) && filename.endsWith('.json')) {
               try {
                   const jsonContent = await fileEntry.async('text');
                   stateMachineJsons.push(JSON.parse(jsonContent));
               } catch (e) {
                   console.warn(`Could not parse JSON file from states/: ${filename}`, e);
               }
           }
       }
       return stateMachineJsons;
   }




   function extractMarkersFromLogic(jsonString) { // Renamed to avoid conflict if another function with similar name exists
          const markers = [];
          let parseError = null;
          if (!jsonString) { // Handle cases where content might be null (e.g., read error)
               return { markers, error: "JSON content is missing." };
          }
          try {
              const animationJson = JSON.parse(jsonString);
              if (animationJson && animationJson.markers && Array.isArray(animationJson.markers)) {
                  animationJson.markers.forEach(marker => {
                      const startTime = typeof marker.tm === 'number' ? marker.tm : (typeof marker.t === 'number' ? marker.t : undefined);
                      if (marker.cm && typeof startTime === 'number' && typeof marker.dr === 'number') {
                          markers.push({
                              name: marker.cm,
                              start: startTime,
                              end: startTime + marker.dr
                          });
                      } else {
                          console.warn('Invalid or incomplete marker (cm, tm/t, dr) found in JSON:', marker);
                      }
                  });
              }
          } catch (e) {
              console.error("Error parsing JSON for marker extraction (cm, tm/t, dr):", e);
              parseError = `Error parsing JSON: ${e.message}`;
          }
          return { markers, error: parseError };
      }



      // New function to update the source node's loop property
      // Refined function to update the source node's loop property based on connection types
  function updateSourceNodeLoopStatus(sourceNodeId) {
      const sourceNode = nodes.find(n => n.id === sourceNodeId);
      if (!sourceNode) {
          // console.warn(`updateSourceNodeLoopStatus: Source node with ID ${sourceNodeId} not found.`);
          return;
      }

      const outgoingConnections = connections.filter(conn => conn.fromNodeId === sourceNodeId);
      const onLoopCompleteConnections = outgoingConnections.filter(conn => conn.interactionType === 'onLoopComplete'); // <-- FIX: Corrected case from 'OnLoopComplete'
      const onCompleteConnections = outgoingConnections.filter(conn => conn.interactionType === 'onComplete');

      const previousLoopState = sourceNode.loop;
      let newLoopState = previousLoopState; // Assume no change initially
      let nodeLoopActuallyChanged = false;

      if (onLoopCompleteConnections.length > 0) {
          // Priority 1: An "OnLoopComplete" connection exists.
          // Use its loopCount. Default to 1 if not a positive number.
          const firstOnLoopCompleteConn = onLoopCompleteConnections[0];
          let loopCount = 1; // Default loop count

          if (firstOnLoopCompleteConn.interactionDetails &&
              typeof firstOnLoopCompleteConn.interactionDetails.loopCount === 'number' &&
              firstOnLoopCompleteConn.interactionDetails.loopCount > 0) {
              loopCount = firstOnLoopCompleteConn.interactionDetails.loopCount;
          }

          if (sourceNode.loop !== loopCount) {
              newLoopState = loopCount;
              nodeLoopActuallyChanged = true;
          }
      } else if (onCompleteConnections.length > 0) {
          // Priority 2: No "OnLoopComplete", but an "onComplete" connection exists.
          if (sourceNode.loop !== false) {
              newLoopState = false;
              nodeLoopActuallyChanged = true;
          }
      } else {
          // Priority 3: No "OnLoopComplete" or "onComplete" connections from this node.
          // This function will not alter node.loop in this case.
          // The node's loop status will be determined by its explicitly saved properties
          // (e.g., if the user checked the loop checkbox in its properties modal and saved).
          // We don't automatically set it to true or false here if no connection dictates it.
      }

      if (nodeLoopActuallyChanged) {
          sourceNode.loop = newLoopState;
          // console.log(`Node ${sourceNode.name} (${sourceNode.id}) loop property changed to: ${sourceNode.loop}`);
      }

      // Sync the loopCheckbox if the Node Properties Modal is currently open for this source node
      // Sync the loopCheckbox and FreezeOnFirstFrameCheckbox if the Node Properties Modal is currently open for this source node
          if (selectedNodeForEdit && selectedNodeForEdit.id === sourceNode.id) {
              const loopCheckboxContainer = document.getElementById('loop-checkbox').closest('.toggle-group');
              const loopLabel = loopCheckboxContainer.querySelector('label');
              const freezeToggleLabel = freezeOnFirstFrameToggleGroup.querySelector('label'); // NEW

              let shouldForceLoopCheckboxFalse = false;
              let shouldForceFreezeCheckboxTrue = false; // NEW

              if (onLoopCompleteConnections.length > 0 || onCompleteConnections.length > 0) {
                  shouldForceLoopCheckboxFalse = true;
                  shouldForceFreezeCheckboxTrue = true; // NEW
              }

              // Loop checkbox sync
              if (shouldForceLoopCheckboxFalse) {
                  loopCheckboxContainer.style.pointerEvents = 'none';
                  loopCheckboxContainer.style.opacity = '0.4';
                  loopLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                  loopCheckbox.checked = false;
              } else {
                  loopCheckboxContainer.style.pointerEvents = 'auto';
                  loopCheckboxContainer.style.opacity = '1.0';
                  loopLabel.title = '';
                  const effectivelyLoops = (typeof sourceNode.loop === 'boolean' && sourceNode.loop === true) ||
                                         (typeof sourceNode.loop === 'number' && sourceNode.loop > 0);
                  loopCheckbox.checked = effectivelyLoops;
              }

              // NEW: Freeze on First Frame checkbox sync
              if (shouldForceFreezeCheckboxTrue) {
                  freezeOnFirstFrameToggleGroup.style.pointerEvents = 'none';
                  freezeOnFirstFrameToggleGroup.style.opacity = '0.4';
                  freezeToggleLabel.title = 'Controlled by outgoing transition (On Complete / On Loop Complete)';
                  freezeOnFirstFrameCheckbox.checked = false; // FIX: Force UNCHECKED (no freeze)
              } else {
                  freezeOnFirstFrameToggleGroup.style.pointerEvents = 'auto';
                  freezeOnFirstFrameToggleGroup.style.opacity = '1.0';
                  freezeToggleLabel.title = '';
                  freezeOnFirstFrameCheckbox.checked = !sourceNode.autoplay; // checked = true means FREEZE, so autoplay = false
              }
          }

      // Always update the source node's visual details chip on the canvas
      const sourceNodeElement = document.getElementById(sourceNode.id);
      if (sourceNodeElement) {
          updateNodeDetailsChips(sourceNodeElement, sourceNode);
      }
  }




   /**
 * Extracts and parses all JSON files located in the 'animations/' directory within a .lottie archive,
 * and for each, returns its name and all marker names defined within it.
 *
 * @param {File} dotLottieFile - The .lottie file (zip archive) to process.
 * @returns {Promise<Array<{animationName: string, markers: Array<string>}>>}
 * A promise that resolves with an array of objects, where each object
 * contains the animation's file name (without extension) and an array of its marker names.
 * Returns an empty array if no JSON files are found or if JSZip is not loaded,
 * or if animations do not contain a 'markers' property.
 */
 async function extractAnimationMarkersFromLottie(dotLottieFile) {
    if (typeof JSZip === 'undefined') {
        console.error("JSZip library is not loaded. Cannot process .lottie file.");
        throw new Error("JSZip library is required for .lottie processing.");
    }

    const arrayBuffer = await readFileAsArrayBuffer(dotLottieFile);
    const zip = new JSZip();
    const loadedZip = await zip.loadAsync(arrayBuffer);
    const animationsData = []; // Renamed from availableAnimations to avoid confusion with global

    for (const filename in loadedZip.files) {
        const fileEntry = loadedZip.files[filename];

        if (!fileEntry.dir && (filename.startsWith('animations/') || filename.startsWith('a/')) && filename.toLowerCase().endsWith('.json')) {
            let animationId;
            if (filename.startsWith('animations/')) {
                animationId = filename.replace('animations/', '').replace(/\.json$/i, '');
            } else {
                animationId = filename.replace('a/', '').replace(/\.json$/i, '');
            }
            const animationName = animationId; // Default name to ID
            let animationEntry = { id: animationId, name: animationName, markers: [], jsonContent: null, error: null, clickLayers: new Set() }; // Add jsonContent and clickLayers

            try {
                let jsonContentString = await fileEntry.async('text');
                if (jsonContentString) {
                    let animationJson = JSON.parse(jsonContentString);

                    // 1. Modify the ip property and add the "Full Animation" marker
                    const originalIp = animationJson.ip || 0;
                    if (originalIp !== 0) {
                        animationJson.ip = 0;
                        console.log(`[LOG] Animation '${animationId}': Original ip was ${originalIp}, set to 0.`);
                    }

                    // Ensure markers array exists
                    if (!animationJson.markers) {
                        animationJson.markers = [];
                    }

                    // Add the new "Full Animation" marker
                    const fullAnimationMarker = {
                        cm: "Full Animation",
                        tm: originalIp, // Start from the original in-point
                        dr: animationJson.op - originalIp // Duration is out-point minus original in-point
                    };
                    animationJson.markers.unshift(fullAnimationMarker); // Add to the beginning of the array
                    console.log(`[LOG] Animation '${animationId}': Added 'Full Animation' marker.`, fullAnimationMarker);

                    // Re-serialize the modified JSON
                    jsonContentString = JSON.stringify(animationJson);

                    // 2. Store the modified JSON and extract markers from it
                    animationEntry.jsonContent = jsonContentString;
                    const markerData = extractMarkersFromLogic(jsonContentString);
                    animationEntry.markers = markerData.markers;
                    if (markerData.error) {
                        animationEntry.error = `Marker extraction error: ${markerData.error}`;
                        console.warn(`Error processing markers for ${filename}: ${markerData.error}`);
                    }
                } else {
                    animationEntry.error = "JSON content was empty or unreadable.";
                }
            } catch (e) {
                console.warn(`Could not read or process animation JSON from ${filename}:`, e);
                animationEntry.error = `Failed to read/process ${filename}: ${e.message}`;
            }
            animationsData.push(animationEntry);
        }
    }
    return animationsData; // Return the collected animations data
}


/**
 * Generates a minimal Lottie manifest JSON object.
 * @param {Array<Object>} animations - Array of animation objects (from availableAnimations).
 * @param {Array<Object>} nodes - Array of node objects (for state names).
 * @returns {Object} The manifest JSON object.
 */
function generateLottieManifest(animations, nodes) {
    // Dynamically create an entry for each animation being bundled.
    const animationEntries = animations.map(anim => ({ id: anim.id }));

    return {
        version: "2",
        generator: "@dotlottie/dotlottie-js@1.3.1",
        animations: animationEntries, // Use the dynamically generated array
        stateMachines: [
            { id: "stateMachine" } // This matches the hardcoded "stateMachine.json" filename.
        ]
    };
}

/**
 * Exports the current state machine and associated animations as a .lottie file.
 * @param {Array<Object>} nodesData - The array of current node objects.
 * @param {Array<Object>} connectionsData - The array of current connection objects.
 * @param {string|null} initialNodeName - The name of the initial node for the state machine JSON.
 * @param {Array<Object>} animationsToInclude - The array of animation data including their JSON content.
 */
async function exportLottieFile(nodesData, connectionsData, initialNodeName, globalState, guardConnections, animationsToInclude) {
    if (typeof JSZip === 'undefined') {
        showCustomAlert("Error: JSZip library is not loaded, cannot export .lottie.");
        return;
    }

    if (animationsToInclude.length === 0) {
        showCustomAlert("Cannot export .lottie: No animations are loaded.");
        return;
    }

    const zip = new JSZip();

    // 1. Add manifest.json
    const manifest = generateLottieManifest(animationsToInclude, nodesData);
    zip.file("manifest.json", JSON.stringify(manifest, null, 2));

    // 2. Add animations to 'animations/' folder
    const animationsFolder = zip.folder("a");
    animationsToInclude.forEach(anim => {
        if (anim.jsonContent) {
            animationsFolder.file(`${anim.id}.json`, anim.jsonContent);
        } else {
            console.warn(`Animation '${anim.id}' does not have 'jsonContent'. Skipping addition to .lottie.`);
        }
    });

    // 3. Add state machine JSON to 'states/' folder
    const statesFolder = zip.folder("s");
    const stateMachineJson = convertNodesAndConnectionsToJson(nodesData, connectionsData, initialNodeName, globalState, guardConnections, animationsToInclude);
    statesFolder.file("stateMachine.json", JSON.stringify(stateMachineJson, null, 2));

    // 4. Generate the .lottie (zip) file and trigger download
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'exportedStateMachine.lottie'; // Default filename
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showCustomAlert("State machine and animations exported as .lottie file!");
    } catch (error) {
        console.error("Error generating .lottie file:", error);
        showCustomAlert(`Error exporting .lottie file: ${error.message}`);
    }
}




/**
 * Processes a state machine JSON object (e.g., from a .lottie file) by:
 * - Extracting and updating frame markers based on the JSON's segments.
 * - Mapping animation IDs for nodes, defaulting where necessary.
 *
 * This function returns a new, processed JSON object. It internally causes
 * updates to the global 'availableAnimations' list.
 *
 * @param {object} rawStateMachineJson - The raw, parsed state machine JSON object to process.
 * @param {Array<object>} allAvailableAnimations - The array of all animations currently available in the application.
 * This array is used for lookups and is expected to be updated globally
 * by the internal call to updateAvailableAnimationsWithNewMarkers.
 * @returns {object} A new JSON object representing the processed state machine.
 */
async function processLottieStateMachineJson(rawStateMachineJson, allAvailableAnimations) {
    // Basic validation for converter functions. If missing, we cannot process correctly.


    // Deep clone the incoming JSON to ensure we don't modify the original argument indirectly.
    const stateMachineJson = JSON.parse(JSON.stringify(rawStateMachineJson));

    // Get the ID of the first animation available, to be used as a default.
    const firstAvailableAnimationId = allAvailableAnimations.length > 0 ? allAvailableAnimations[0].id : '';


	 const importedData = convertJsonToNodesAndConnections(stateMachineJson, allAvailableAnimations);
    let processedNodes = importedData.nodes;
    let processedConnections = importedData.connections;
    let processedInitialNodeId = importedData.initialNodeId;

    let anyNodeHadAnimationIdDefined = false;

    // Step 3: Process nodes to map animation IDs and handle defaults.
    processedNodes.forEach(node => {
        if (node.animationId) {
            anyNodeHadAnimationIdDefined = true;
            const matchingAnimation = allAvailableAnimations.find(anim => anim.name === node.animationId || anim.id === node.animationId);
            if (matchingAnimation) {
                node.animationId = matchingAnimation.id;
            } else {
                console.warn(`Animation "${node.animationId}" from imported JSON not found in available animations for node "${node.name}". Defaulting to first available.`);
                node.animationId = firstAvailableAnimationId;
            }
        } else {
            node.animationId = ''; // Initialize to empty for later checks.
        }
    });

    // Step 4: Apply logic if no animationId was defined in any state in the original JSON.
    if (!anyNodeHadAnimationIdDefined && firstAvailableAnimationId) {
        console.log(`No animationId found in any imported state. Assigning all states to first animation: "${firstAvailableAnimationId}"`);
        processedNodes.forEach(node => {
            node.animationId = firstAvailableAnimationId;
        });
    }

    // Step 5: Final fallback to ensure no node has an empty animationId if animations are available.
    processedNodes.forEach(node => {
         if (!node.animationId && allAvailableAnimations.length > 0) {
             node.animationId = allAvailableAnimations[0].id;
         }
    });

    // Step 6: Convert the processed internal data (nodes/connections) back into the
    // state machine JSON format expected by your application.
    // We need the initial node's *name* for convertNodesAndConnectionsToJson.
    const initialNodeForReturn = processedNodes.find(n => n.id === processedInitialNodeId);
    const initialNodeNameForReturn = initialNodeForReturn ? initialNodeForReturn.name : null;

    const finalStateMachineJson = convertNodesAndConnectionsToJson(
        processedNodes,
        processedConnections,
        initialNodeNameForReturn,
        importedData.globalState, // Pass through global state
        importedData.guardConnections, // Pass through guard connections
        allAvailableAnimations
    );

    return finalStateMachineJson;
}

// --- NEW: Function to update action node properties from the UI instantly ---
function updateActionNodeFromUI() {
    if (selectedNodeForEdit && selectedNodeForEdit.type === 'action') {
        const actionType = document.getElementById('action-node-type-select')?.value;
        if (actionType && actionType !== '') {
            const actionValue = document.getElementById('action-node-value-input').value;
            selectedNodeForEdit.action = {
                type: actionType,
                value: actionValue,
            };
        } else {
            selectedNodeForEdit.action = null;
        }
        // Update the visual representation on the canvas
        updateActionNodeVisual(document.getElementById(selectedNodeForEdit.id), selectedNodeForEdit);
    }
}
// --- END NEW ---

function openActionNodePropertiesModal(nodeData) {
    // Handle active state
    nodes.forEach(n => n.isActive = (n.id === nodeData.id));
    updateNodeStyles();
    const globalNodeEl = document.getElementById('global_state_node');
    if (globalNodeEl) globalNodeEl.classList.remove('active');
    const actionNodeEl = document.getElementById(nodeData.id);
    if (actionNodeEl) actionNodeEl.classList.add('active');

    // Show the correct panel
    if (!statePreviewWindow.contains(actionNodePropertiesContainer)) {
        statePreviewWindow.appendChild(actionNodePropertiesContainer);
    }
    nodePropertiesModal.style.display = 'none';
    globalStatePropertiesContainer.style.display = 'none';
    actionNodePropertiesContainer.style.flexDirection = 'column'; // FIX: Ensure vertical layout
    actionNodePropertiesContainer.style.display = 'flex';
    if (statePreviewWindow.classList.contains('hidden')) previewToggleButton.click();

    selectedNodeForEdit = nodeData;

    // Populate the editor
    const editorContent = document.getElementById('action-node-editor-content');
    editorContent.innerHTML = ''; // Clear previous content

    if (globalState) {
        const template = document.getElementById('action-editor-template').content.cloneNode(true);
        const dropdownGroup = template.querySelector('.dropdown-group');
        const valueField = template.querySelector('.dynamic-field-group');

        // Create dropdown elements
        dropdownGroup.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                <label for="action-node-type-select">ACTION ON TRIGGER</label>
                <div class="custom-dropdown-container">
                    <div class="custom-dropdown-display" data-target-select="action-node-type-select"></div>
                    <div class="custom-dropdown-options"></div>
                    <select id="action-node-type-select" style="display: none;"></select>
                </div>
            </div>
            <i class="fas fa-chevron-down dropdown-indicator" style="margin: auto; margin-right: 1rem;"></i>`;
        
        // Create value input elements
        valueField.innerHTML = `
            <label for="action-node-value-input">Value:</label>
            <input type="text" id="action-node-value-input" style="
                border-radius: 16px;
                background-color: #e6f6ff7a;
                border: 2px solid #b8cde329;
                padding: 12px 16px;
                width: 100%;
                box-sizing: border-box;
                font-size: 15px;
            ">`;

        editorContent.appendChild(template);

        // Get newly created elements
        const display = editorContent.querySelector('.custom-dropdown-display');
        const optionsContainer = editorContent.querySelector('.custom-dropdown-options');
        const nativeSelect = editorContent.querySelector('select');

        // Populate and set up listeners (reusing logic from connection editor)
        updateActionsSection({ action: nodeData.action }, display, optionsContainer, nativeSelect, valueField);

        dropdownGroup.addEventListener('click', (e) => { e.stopPropagation(); optionsContainer.classList.toggle('open'); });
        optionsContainer.addEventListener('click', (e) => {
            const option = e.target.closest('.custom-dropdown-option');
            if (option) {
                e.stopPropagation(); // Stop the event from bubbling to the dropdownGroup
                nativeSelect.value = option.dataset.value;
                display.textContent = option.textContent;
                // --- FIX: Update the 'selected' class ---
                optionsContainer.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                // --- END FIX ---
                optionsContainer.classList.remove('open');
                updateActionValueField(option.dataset.value, '', valueField);
                updateActionNodeFromUI(); // Instantly save on change
            }
        });

        // Add listener for the value input
        valueField.querySelector('input').addEventListener('input', updateActionNodeFromUI);
    } else {
        // --- NEW: Show the user-friendly prompt ---
        editorContent.innerHTML = `
            <div class="action-node-prompt">
                <p>To use Action Nodes, you first need to create a Global Variable.</p>
                <button id="create-global-node-from-action-panel">Create Global Variable</button>
            </div>
        `;
        // Add a listener to the new button
        const createGlobalNodeBtn = document.getElementById('create-global-node-from-action-panel');
        if (createGlobalNodeBtn) {
            createGlobalNodeBtn.addEventListener('click', () => {
                addOrShowGlobalStateNode(); // This function creates the node and opens its properties
            });
        }
    }
}

function openGuardConditionModal(guardConn) {
    selectedGuardConnectionForEdit = guardConn;

    // --- MODIFIED: Dynamically update the condition label inside the dropdown ---
    const conditionLabel = document.getElementById('guard-condition-label');
    if (conditionLabel && globalState && globalState.name) {
        let varName = globalState.name;
        if (varName.length > 20) { // Shorten if too long for the dropdown
            varName = varName.substring(0, 20) + '...';
        }
        conditionLabel.textContent = `IF '${varName}'`;
    }
    // --- END MODIFIED ---

    // --- NEW: Dropdown Logic ---
    const guardConditionTypeDropdownGroup = document.getElementById('guard-condition-type-dropdown-group');
    const guardConditionTypeDisplay = guardConditionTypeDropdownGroup.querySelector('.custom-dropdown-display');
    const guardConditionTypeOptionsContainer = document.getElementById('guard-condition-type-options');
    const guardConditionTypeNativeSelect = document.getElementById('guard-condition-type-select');
    const conditionOptions = getConditionOptionsForType(globalState.type);

    populateDropdowns(
        guardConditionTypeNativeSelect,
        guardConditionTypeDisplay,
        guardConditionTypeOptionsContainer,
        conditionOptions,
        guardConn.condition
    );
    // --- END NEW ---

    // --- NEW: Populate Transition Type Dropdown ---
    const guardTransitionTypeDropdownGroup = document.getElementById('guard-transition-type-dropdown-group'); // This is the clickable group
    const guardTransitionTypeDisplay = guardTransitionTypeDropdownGroup.querySelector('.custom-dropdown-display'); // This shows the selected text
    const guardTransitionTypeOptions = document.getElementById('guard-transition-type-options'); // This is the container for the options
    const guardTransitionTypeSelect = document.getElementById('guard-transition-type-select'); // This is the hidden native select

    populateDropdowns(
        guardTransitionTypeSelect,
        guardTransitionTypeDisplay,
        guardTransitionTypeOptions,
        TRANSITION_TYPES,
        guardConn.transitionType || 'Transition'
    );

    // --- NEW: Handle dynamic fields for tweening ---
    const guardDynamicFieldsContainer = document.getElementById('guard-dynamic-fields');
    guardDynamicFieldsContainer.innerHTML = ''; // Clear previous fields

    const handleGuardTransitionTypeChange = () => {
        guardDynamicFieldsContainer.innerHTML = ''; // Clear on change
        if (guardTransitionTypeSelect.value === 'Tweened') {
            guardDynamicFieldsContainer.innerHTML = `
                <div class="dynamic-field-group">
                    <label for="guard-tweened-duration-input">Duration (seconds):</label>
                    <input type="number" id="guard-tweened-duration-input" min="0" step="0.1" value="${guardConn.duration || 0.5}">
                </div>
                <div class="dynamic-field-group">
                    <label for="guard-tweened-easing-input">Easing (Cubic Bezier):</label>
                    <input type="text" id="guard-tweened-easing-input" placeholder="e.g., 0.42, 0, 0.58, 1" value="${(guardConn.easing || [0.42, 0, 0.58, 1]).join(', ')}">
                </div>
            `;
        }
    };

    guardTransitionTypeSelect.removeEventListener('change', handleGuardTransitionTypeChange); // Remove old listener
    guardTransitionTypeSelect.addEventListener('change', handleGuardTransitionTypeChange);
    handleGuardTransitionTypeChange(); // Initial call to set up fields
    // --- END NEW ---

    guardValueInput.value = guardConn.value;
    guardConditionModal.style.display = 'flex';
}

function updateActionsSection(connection, customDisplay, customOptionsContainer, customNativeSelect, customValueField) {
    const toNode = nodes.find(n => n.id === connection.toNodeId);
    const isActionNodeDest = toNode?.type === 'action';

    // If destination is an action node, hide the section. Otherwise, show if globalState exists.
    if (isActionNodeDest || !globalState) {
        actionsSection.style.display = 'none';
    } else {
        actionsSection.style.display = 'block';
        let actionOptions = [{ id: '', name: 'None' }];

        // Use provided elements or fallback to the connection modal's elements
        const display = customDisplay || actionTypeDisplay;
        const optionsContainer = customOptionsContainer || actionTypeOptionsContainer;
        const nativeSelect = customNativeSelect || actionTypeNativeSelect;


        if (globalState.type === 'Numeric') {
            actionOptions.push({ id: 'Increment', name: `Increment '${globalState.name}'` });
            actionOptions.push({ id: 'Decrement', name: `Decrement '${globalState.name}'` });
            actionOptions.push({ id: 'SetNumeric', name: `Set '${globalState.name}' to...` });
        } else if (globalState.type === 'Boolean') {
            actionOptions.push({ id: 'Toggle', name: `Toggle '${globalState.name}'` });
            actionOptions.push({ id: 'SetBoolean', name: `Set '${globalState.name}' to...` });
        } else if (globalState.type === 'String') {
            actionOptions.push({ id: 'SetString', name: `Set '${globalState.name}' to...` });
        }

        const currentActionType = connection.action ? connection.action.type : '';
        populateDropdowns(nativeSelect, display, optionsContainer, actionOptions, currentActionType);
        updateActionValueField(currentActionType, connection.action ? connection.action.value : '', customValueField);
    }
}

function updateActionValueField(actionType, value = '', customValueField) {
    const fieldContainer = customValueField || actionValueField;
    const input = fieldContainer.querySelector('input');
    if (!input) return;

    if (actionType === 'Increment' || actionType === 'Decrement') {
        fieldContainer.style.display = 'block';
        fieldContainer.querySelector('label').textContent = 'By Value:';
        input.value = value || '1'; // Default to 1 for inc/dec
        input.type = 'number';
    } else if (actionType === 'SetNumeric' || actionType === 'SetString' || actionType === 'SetBoolean') {
        fieldContainer.style.display = 'block';
        fieldContainer.querySelector('label').textContent = 'Set To Value:';
        input.value = value;
        if (actionType === 'SetNumeric') {
            input.type = 'number';
        } else {
            input.type = 'text';
        }
    } else {
        fieldContainer.style.display = 'none';
    }

}

/**
 * Processes a single Lottie JSON object by normalizing its in-point (ip) and adding a "Full Animation" marker.
 * This ensures consistency with animations loaded from .lottie archives.
 * @param {object} animationJson - The parsed Lottie JSON object.
 * @returns {object} A new, processed Lottie JSON object.
 */
function processSingleLottieJson(animationJson) {
    // Create a deep copy to avoid modifying the original object
    const newJson = JSON.parse(JSON.stringify(animationJson));

    const originalIp = newJson.ip || 0;
    // Normalize the main in-point to 0
    if (originalIp !== 0) {
        newJson.ip = 0;
        console.log(`[LOG] Single Lottie JSON: Original ip was ${originalIp}, set to 0.`);
    }

    // Ensure the markers array exists
    if (!newJson.markers) {
        newJson.markers = [];
    }

    // Add the "Full Animation" marker based on the original in-point and out-point
    const fullAnimationMarker = {
        cm: "Full Animation",
        tm: originalIp,
        dr: newJson.op - originalIp
    };
    newJson.markers.unshift(fullAnimationMarker);
    return newJson;
}


// --- NEW: Central function to set the global animation and update all nodes ---
function setGlobalAnimation(newAnimationId, showAlert = true) {
    globalAnimationId = newAnimationId;

    // Update all existing nodes
    nodes.forEach(node => {
        node.animationId = newAnimationId;
        node.marker = ''; // Reset marker as it belongs to the old animation
        const nodeElement = document.getElementById(node.id);
        if (nodeElement) {
            updateNodeDetailsChips(nodeElement.querySelector('.node'), node);
        }
    });

    // If the properties panel is open, refresh it
    if (selectedNodeForEdit) {
        openNodePropertiesModal(selectedNodeForEdit);
    }

    // Optionally notify the user
    if (showAlert) {
        const animName = availableAnimations.find(a => a.id === newAnimationId)?.name || 'the selected animation';
        showCustomAlert(`All states now use: ${animName}`);
    }
}

/**
 * Cleans a Lottie JSON object by removing interactive layers that no longer have a corresponding transition in the state machine.
 * @param {object} lottieJson - The parsed Lottie JSON data.
 * @param {string} sourceStateName - The name of the state from which transitions originate.
 * @param {Array<object>} allConnections - The global `connections` array of the flowchart.
 * @param {Array<object>} allNodes - The global `nodes` array of the flowchart.
 * @returns {{cleanedJson: object, removedCount: number}} - An object containing the cleaned JSON and the count of removed layers.
 */
function cleanOrphanedInteractiveLayers(lottieJson, sourceStateName, allConnections, allNodes) {
    if (!lottieJson || !lottieJson.layers) {
        return { cleanedJson: lottieJson, removedCount: 0 };
    }

    const nodeIdToNameMap = new Map(allNodes.map(node => [node.id, node.name]));
    const nameToNodeIdMap = new Map(allNodes.map(node => [node.name, node.id]));
    const sourceNodeId = nameToNodeIdMap.get(sourceStateName);
    let removedCount = 0;

    const pointerInteractionTypes = ['onClick', 'onPointerEnter', 'onPointerExit', 'onPointerDown', 'onPointerUp', 'onPointerMove'];

    const originalLayers = lottieJson.layers;
    const cleanedLayers = originalLayers.filter(layer => {
        const layerName = layer.nm;
        const nameParts = layerName.split('_');

        // Check if it's a potential interactive layer for the source state (e.g., "StateA_click_to_StateB")
        if (nameParts.length >= 4 && nameParts[0] === sourceStateName && nameParts[2] === 'to') {
            const destStateName = nameParts.slice(3).join('_');
            const destNodeId = nameToNodeIdMap.get(destStateName);

            // Check if a valid transition exists in the state machine data
            const transitionExists = allConnections.some(conn =>
                conn.fromNodeId === sourceNodeId &&
                conn.toNodeId === destNodeId &&
                pointerInteractionTypes.includes(conn.interactionType)
            );

            if (!transitionExists) {
                console.log(`[GC] Removing orphaned layer: '${layerName}' as no matching transition was found.`);
                removedCount++;
                return false; // Filter out (remove) this layer
            }
        }
        return true; // Keep the layer
    });

    lottieJson.layers = cleanedLayers;
    return { cleanedJson: lottieJson, removedCount };
}


// --- NEW: Event listener for the "Edit Click Area" button ---
editClickAreaButton.addEventListener('click', () => {
    // --- FIX: Use tempConnectionData for generating the layer name ---
    if (!tempConnectionData) {
        showCustomAlert("No connection is selected for editing.");
        return;
    }

    const fromNode = nodes.find(n => n.id === tempConnectionData.fromNodeId);
    if (!fromNode) {
        showCustomAlert("Could not find the source node for this connection.");
        return;
    }

    const animationData = availableAnimations.find(anim => anim.id === fromNode.animationId);
    if (!animationData || !animationData.jsonContent) {
        showCustomAlert("Could not find the Lottie JSON for the source node's animation.");
        return;
    }

    // --- NEW: Generate transition-specific layer name ---
    const toNode = nodes.find(n => n.id === tempConnectionData.toNodeId);
    const interactionName = tempConnectionData.interactionType.replace('on', '').toLowerCase();
    const layerName = `${fromNode.name}_${interactionName}_to_${toNode.name}`;

    const markerName = fromNode.marker || 'Full Animation'; // Use marker name or default

    // Show the modal and set the iframe source
    clickAreaModal.style.display = 'flex';
    clickAreaIframe.src = 'statemachinebuilder/clickmarker/cick marker.html';
    
    // Wait for the iframe to load before sending data
    clickAreaIframe.onload = () => {
        // --- NEW: Clean orphaned layers before sending data ---
        let lottieJson = JSON.parse(animationData.jsonContent);
        const { cleanedJson, removedCount } = cleanOrphanedInteractiveLayers(lottieJson, fromNode.name, connections, nodes);

        if (removedCount > 0) {
            console.log(`[LOG] Cleaned ${removedCount} orphaned interactive layer(s) from the Lottie data before opening the editor.`);
            // Update the master animation data with the cleaned version
            animationData.jsonContent = JSON.stringify(cleanedJson);
        }

        const messageData = {
            type: 'lottieDataForMarker',
            animationData: cleanedJson, // Send the cleaned JSON
            markerName: markerName,
            layerName: layerName,
            animationId: animationData.id // Pass the unique ID
        };

        console.log('[LOG] Sending data to Click Area Editor iframe:', messageData);

        clickAreaIframe.contentWindow.postMessage(messageData, '*');
    };
});

// --- FIX: Correctly trigger the save action in the click area iframe ---
document.getElementById('save-click-area-button').addEventListener('click', () => {
    const iframe = document.getElementById('click-area-iframe');
    if (iframe && iframe.contentWindow) {
        // The click-marker tool's save button is now the primary one, so we just click it.
        iframe.contentWindow.document.getElementById('download-button')?.click();
    }
});
// --- END FIX ---



    </script>
</body>
</html>
